<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>平凡而诗意</title>
  
  <subtitle>Jackpop</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://jackpopc.github.io/"/>
  <updated>2019-10-08T14:22:49.460Z</updated>
  <id>https://jackpopc.github.io/</id>
  
  <author>
    <name>Jackpop</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>大数据处理 | Spark&amp;HDFS集群配置及基本使用</title>
    <link href="https://jackpopc.github.io/2019/10/08/spark/"/>
    <id>https://jackpopc.github.io/2019/10/08/spark/</id>
    <published>2019-10-08T14:06:40.000Z</published>
    <updated>2019-10-08T14:22:49.460Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Spark简介"><a href="#Spark简介" class="headerlink" title="Spark简介"></a><strong>Spark简介</strong></h2><p><img src="https://s2.ax1x.com/2019/10/08/uhcnzV.png" alt="uhcnzV.png"></p><p>Spark是由加州伯克利大学AMP实验室于2009年开发并于2013年加入Apache的开源大数据并行计算框架，它凭借自身独有的优势迅速成为Apache三大分布式计算框架之一，对比于常用的hadoop，它具有低时延、速度快、通用性强等优点。<a id="more"></a>此外，Spark具有完善的生态系统，在资源调度方面它拥有Mesos和YARN，在存储方面它支持本地文件系统、HDFS、Amazon S3、HBase等，在数据仓库方面它拥有Hive SQL、Spark SQL，在接口方面它拥有mlib、GraphX等。</p><p>除了运算和生态方面的优势，Spark在数据处理方式方面同时支持批计算和流计算，虽然Spark在流计算方面不如storm、flink能够支持毫秒级别，但是对于大多数对实时性要求不高的在线计算已经足够使用。</p><p>基于上述众多优点使得Spark成为一个非常热门和受欢迎的大数据处理框架，目前在很多大型公司被广泛使用。</p><p>Spark不仅可以支持集群模式，还可以支持单机模式，但是我认为之所以使用大数据处理框架，它的主要优势就体现在多机并行方面，随着数据集的增加和节点数量的增加，它的对比于传统并行模式和其他大数据处理框架的优势更加明显。单机Spark配置相对集群配置相对简单一些，也节省很多步骤，因此，本文就讲解一下集群Spark配置方式，本文的配置是建立在已经配制好JDK的基础上，所以不再详细介绍JDK的安装和配置。</p><h2 id="Hadoop集群环境搭建"><a href="#Hadoop集群环境搭建" class="headerlink" title="Hadoop集群环境搭建"></a><strong>Hadoop集群环境搭建</strong></h2><p><img src="https://s2.ax1x.com/2019/10/08/uhcMsU.png" alt="uhcMsU.png"></p><p>Spark可以读取多种数据源的数据，例如Amazon s3、HBase、HDFS、本地文件系统，由于数据存放在某一个节点路径下，在Spark集群的其他节点无法直接读取相应路径下的数据，而HBase、Amazon s3这些存储服务在很多场景下很难满足，例如学校实验室。因此本文就以HDFS为例来进行讲解。</p><p>Hadoop主要包括两个部门，HDFS文件存储系统用于存储数据源，MapReduce用于从文件存储系统读取数据并进行分布式处理，由于本文只用到文件存储系统HDFS，用不到MapReduce，所以本文就配置一下集群Hadoop，讲解HDFS的使用，不深入研究MapReduce的使用。</p><p><strong>准备工作</strong></p><p>首先要保证集群中不同节点能够互相通信，然后为每个节点配置对应的hostname，后面会用到，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ vim /etc/hosts</span><br><span class="line">10.110.113.132  master</span><br><span class="line">10.110.113.133  slave0</span><br><span class="line">10.110.113.134  slave1</span><br><span class="line">10.110.113.135  slave2</span><br></pre></td></tr></table></figure><p>上述master和slave是每个节点的hostname，可以作为IP的地带，通过ping的方式可以测试hostname是否正常通信，可以在master节点上测试是否连接到不同的slave节点，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ping slave0</span><br><span class="line">或者</span><br><span class="line">$ ping 10.110.113.133</span><br></pre></td></tr></table></figure><p><strong>注：</strong>hostname的配置可以通过sudo vim /etc/hostname修改文件进行配置。</p><p><strong>ssh无密码登陆集群机器</strong></p><p>由于集群配置hadoop涉及多台机器，当在master节点启动或者关闭集群hadoop时需要输入所有slave节点的密码，这样显然太麻烦，因此需要配置无密码登陆，这样后续启动时就不需要输入密码，</p><p>首先，如果节点没有安装ssh需要安装ssh，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install ssh</span><br></pre></td></tr></table></figure><p>然后，在每个节点上输入下面命令，测试是否能够正常登陆每个节点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh localhost</span><br></pre></td></tr></table></figure><p>为了保证master节点能够无密码登陆所有slave节点，需要首先生成master节点的公钥，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen  -t  rsa</span><br></pre></td></tr></table></figure><p>一直点击确定即可，然后会在home路径下生成两个文件，id_rsa和id_rsa.pub，这时需要把id_rsa.pub的内容追加到authorized_keys后面，然后把master节点id_rsa.pub拷贝到所有slave节点并追加到所有slave节点authorized_keys的后面，</p><p>首先在master节点执行操作，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cat ~/.ssh/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys</span><br></pre></td></tr></table></figure><p>然后把master节点生成的id_rsa.pub拷贝到所有slave节点，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ scp ~/.ssh/id_rsa.pub user_name@slave0:/home/user_name/</span><br><span class="line">$ scp ~/.ssh/id_rsa.pub user_name@slave1:/home/user_name/</span><br><span class="line">$ scp ~/.ssh/id_rsa.pub user_name@slave2:/home/user_name/</span><br></pre></td></tr></table></figure><p>上述user_name是slave节点的用户名，然后把id_rsa.pub追加到每个slave节点authorized_keys的后面，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cat ~/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys</span><br></pre></td></tr></table></figure><p>然后可以在master节点上通过下方命令测试是否能够正常登陆每个slave节点，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ssh slave0</span><br><span class="line">$ ssh slave1</span><br><span class="line">$ ssh slave2</span><br></pre></td></tr></table></figure><p><strong>注意：</strong>上述都是假设master和每个slave节点的用户名user_name一样的前提下，如果不一样需要修改~/.ssh/config文件。</p><p><strong>安装Hadoop</strong></p><p><img src="https://s2.ax1x.com/2019/10/08/uhcKMT.png" alt="uhcKMT.png"></p><p>打开下面链接进入到下载页面，点击下载binary文件，把hadoop-3.2.1.tar.gz文件下载到home路径下，</p><p><a href="https://hadoop.apache.org/releases.html" target="_blank" rel="noopener">https://hadoop.apache.org/releases.html</a></p><p>然后解压下载的文件到指定目录，同时需要修改对应目录的拥有者，因为hadoop在启动后会记录日志文件，如果不修改拥有者则没有权限写入文件，无法正常启动，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo tar -zxvf ~/下载/hadoop-3.2.1.tar.gz -C /usr/local  </span><br><span class="line">$ cd /usr/local/</span><br><span class="line">$ sudo mv ./hadoop-3.2.1/ ./hadoop          </span><br><span class="line">$ sudo chown -R user_name ./hadoop</span><br></pre></td></tr></table></figure><p>然后，把hadoop路径加入到环境变量里，如果需要长期有效，需要修改~/.bashrc，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export HADOOP_HOME=/usr/local/hadoop</span><br><span class="line">export PATH=$PATH:$HADOOP_HOME/bin:$HADOOP_HOME/sbin</span><br></pre></td></tr></table></figure><p>然后保存退出，执行下面命令让环境变量生效，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ source ~/.bashrc</span><br></pre></td></tr></table></figure><p><strong>集群配置</strong></p><p>首先进入到Hadoop配置文件所在目录，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cd /usr/local/hadoop/etc/hadoop</span><br></pre></td></tr></table></figure><p>然后修改slave节点配置文件，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ vim slaves</span><br><span class="line">slave0</span><br><span class="line">slave1</span><br><span class="line">slave2</span><br></pre></td></tr></table></figure><p><strong>注意：</strong>上述slave0~2不是IP地址，是前面配置的hostname。</p><p>首先配置core-site.xml，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">   &lt;property&gt;</span><br><span class="line">      &lt;name&gt;hadoop.tmp.dir&lt;/name&gt;</span><br><span class="line">      &lt;value&gt;file:/usr/local/hadoop/tmp&lt;/value&gt;</span><br><span class="line">      &lt;description&gt;Abase for other temporary directories.&lt;/description&gt;</span><br><span class="line">   &lt;/property&gt;</span><br><span class="line">   &lt;property&gt;</span><br><span class="line">      &lt;name&gt;fs.defaultFS&lt;/name&gt;</span><br><span class="line">      &lt;value&gt;hdfs://master:9000&lt;/value&gt;</span><br><span class="line">   &lt;/property&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure><p>上述内容只需要修改<value>hdfs://master:9000</value>这一句即可，其他的不需要修改，需要根据自己定义的master节点的hostname进行修改，例如你的master节点的hostname是hadoop，那么就需要修改成<value>hdfs://hadoop:9000</value>，端口默认为9000，</p><p>然后配置hdfs-site.xml，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;dfs.replication&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;1&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure><p>这里dfs.replication默认值是3，它的含义是数据副本备份的数量，如果slave节点数量小于这个数的话则会报错，所以为了防止报错可以把这个值改为1，当然如果slave节点大于等于3的话也可以不修改。</p><p>如果需要使用MapReduce还需要配置mapred-site.xml，因为本文只使用HDFS而不实用MapReduce，因此就不配置mapred-site.xml了。</p><p>另外，如果需要yarn资源调度的话，需要修改yarn-site.xml，yarn是一个资源调度和分配工具，Spark本身自带资源管理器，也可以与yarn、Mesos结合使用，本文就使用Spark自带的资源管理器。</p><p>最后，需要在hadoop中配置JAVA环境，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ vim /usr/local/hadoop/etc/hadoop/hadoop-env.sh</span><br><span class="line">export JAVA_HOME=/path/to/java</span><br></pre></td></tr></table></figure><p>上述/path/to/java需要替换成自己JAVA安装的路径。</p><p><strong>slave节点配置</strong></p><p>上述全部操作都是在master节点进行的，下面需要配置slave节点。配置slave节点比较容易，只需要把文件打包复制到各个slave节点，解压即可，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ tar -zcf ~/hadoop.tar.gz /usr/local/hadoop</span><br><span class="line">$ scp ~/hadoop.tar.gz slave0:~/</span><br><span class="line">$ scp ~/hadoop.tar.gz slave1:~/</span><br><span class="line">$ scp ~/hadoop.tar.gz slave2:~/</span><br></pre></td></tr></table></figure><p>然后在各个slave节点上都执行下面相同操作，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo rm -rf /usr/local/hadoop</span><br><span class="line">$ sudo tar -zxvf ~/hadoop.tar.gz -C /usr/local</span><br><span class="line">$ sudo chown -R user_name /usr/local/hadoop</span><br></pre></td></tr></table></figure><p><strong>启动Hadoop集群</strong></p><p>通过上述的配置，master节点和slave节点的Hadoop都配置好了，下面需要做的就是启动集群上每个节点的Hadoop，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cd /usr/local/hadoop</span><br><span class="line">$ ./bin/hdfs namenode -format</span><br><span class="line">$ ./sbin/start-all.sh</span><br></pre></td></tr></table></figure><p><strong>注意：</strong>./bin/hdfs namenode -format这一句命令很重要，不能缺少。如果前面没有配置ssh免密登陆，执行./sbin/start-all.sh时会让输入密码。</p><p>然后在每个节点上执行下面命令，会在master节点上看到多了一个NameNode，slave节点上会多出DataNode，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ jps</span><br></pre></td></tr></table></figure><h2 id="HDFS简单使用"><a href="#HDFS简单使用" class="headerlink" title="HDFS简单使用"></a><strong>HDFS简单使用</strong></h2><p>HDFS的使用和Linux命令非常相似，例如上传数据用put，创建目录用mkdir，查看目录内容用ls，删除目录用rm，但是也有不同之处，下面就来看一下简单的示例，</p><p><strong>创建目录</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./bin/hdfs dfs -mkdir -p /hello</span><br></pre></td></tr></table></figure><p><strong>上传文件到HDFS</strong></p><p>首先先新建一个本地文件，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ vim ~/test.txt</span><br><span class="line">hello world</span><br><span class="line">hello world</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure><p>然后使用下面命令进行上传，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./bin/hdfs dfs -put ~/test.txt /hello</span><br></pre></td></tr></table></figure><p><strong>查看目录和文件内容</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ ./bin/hdfs dfs -ls /hello</span><br><span class="line">/hello/test.txt</span><br><span class="line">$ ./bin/hdfs dfs -cat /hello/test.txt</span><br><span class="line">hello world</span><br><span class="line">hello world</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure><p>然后我们就可以用Spark访问hdfs文件系统的文件，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">text_file = sc.textFile(&quot;hdfs://master:9000/hello/text.txt&quot;)</span><br></pre></td></tr></table></figure><p>文件的路径分为两部分，一部分是前面core-site.xml中配置的hostname:port，一部分是HDFS上传文件的相对路径。</p><h2 id="Spark集群环境搭建"><a href="#Spark集群环境搭建" class="headerlink" title="Spark集群环境搭建"></a><strong>Spark集群环境搭建</strong></h2><p><img src="https://s2.ax1x.com/2019/10/08/uhcQLF.png" alt="uhcQLF.png"></p><p>如果已经理解了上述Hadoop集群环境的搭建，那么学习Spark集群环境的搭建会容易很多，因为Hadoop和Spark不仅安装包目录结构非常相似，在配置方面也十分接近。均是在master节点上进行所有配置，然后打包复制到每个slave节点，然后启动集群Spark即可，下面就来详细介绍一下Spark集群环境的搭建。</p><p><strong>下载安装</strong></p><p><img src="https://s2.ax1x.com/2019/10/08/uhc1Z4.png" alt="uhc1Z4.png"></p><p>进入Spark的下载目录，</p><p><a href="https://spark.apache.org/downloads.html" target="_blank" rel="noopener">https://spark.apache.org/downloads.html</a></p><p>可以看到Spark分多个版本，有基于Hadoop构建好的，有没基于Hadoop构建的，有基于Hadoop2.6之前版本构建的，也有基于Hadoop2.7以后版本构建的，由于前面讲解Hadoop集群环境搭建时采用的是Hadoop 3.2.1，因此，而且本文需要使用HDFS依赖Hadoop，因此需要下载<strong>Pre-built</strong> <strong>for</strong> <strong>Apache Hadoop 2.7 and later</strong>,</p><p>把spark-2.4.4-bin-hadoop2.7.tgz文件下载到home路径下，然后解压到指定目录，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tar -zxvf ~/spark-2.4.4-bin-hadoop2.7.tgz -C /usr/local/</span><br></pre></td></tr></table></figure><p>然后进入目录并像Hadoop那样，修改Spark目录的拥有者，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cd /usr/local</span><br><span class="line">$ sudo mv ./spark-2.4.4-bin-hadoop2.7 ./spark</span><br><span class="line">$ sudo chowm -R user_name ./spark</span><br></pre></td></tr></table></figure><p><strong>配置环境变量</strong></p><p>修改bashrc，配置环境变量，把Spark的bin和sbin路径加入到环境变量，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ vim ~/.bashrc</span><br><span class="line">export SPARK_HOME=/usr/local/spark</span><br><span class="line">export PATH=$PATH:$SPARK_HOME/bin:$SPARK_HOME/sbin</span><br><span class="line">export PYTHONPATH=$SPARK_HOME/python:$SPARK_HOME/python/lib/py4j-0.10.7-src.zip:$PYTHONPATH</span><br><span class="line">export PYSPARK_PYTHON=python3</span><br></pre></td></tr></table></figure><p><strong>Master节点配置</strong></p><p>进入Spark目录，修改spark-env.sh文件，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd /usr/local/spark</span><br><span class="line">$ vim ./conf/spark-env.sh</span><br></pre></td></tr></table></figure><p>在spark-env.sh中添加下面内容，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export SPARK_DIST_CLASSPATH=$(/usr/local/hadoop/bin/hadoop classpath)</span><br><span class="line">export HADOOP_CONF_DIR=/usr/local/hadoop/etc/hadoop</span><br><span class="line">export  SPARK_MASTER_IP=10.110.113.132</span><br></pre></td></tr></table></figure><p>SPARK_MASTER_IP指定的是master节点的IP，后面启动集群Spark时slave节点会注册到SPARK_MASTER_IP，如果这一项不配置，Spark集群则没有可使用资源，</p><p><strong>修改slaves文件</strong></p><p>配置完master节点信息之后需要配置slave节点信息，slave节点的信息配置在slaves文件里，由于Spark目录下没有这个文件，因此需要首先从slaves.template拷贝一下，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd /usr/local/spark/</span><br><span class="line">$ cp ./conf/slaves.template ./conf/slaves</span><br></pre></td></tr></table></figure><p>然后添加如下内容，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">slave0</span><br><span class="line">slave0</span><br><span class="line">slave1</span><br></pre></td></tr></table></figure><p>需要注意的是，slaves文件里配置的是运行作业任务的节点(worker)，这样的话master的节点只作为控制节点，而不作为工作节点，如果需要把master节点的资源也充分利用起来，需要把master节点也加入到slaves文件中。</p><p><strong>slave节点配置</strong></p><p>首先在master节点上把配制好的目录进行打包，拷贝到每个slave节点上，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ cd /usr/local</span><br><span class="line">$ tar -zcf ~/spar.tar.gz ./spark</span><br><span class="line">$ scp ~/spark/tar.gz slave0:~/</span><br><span class="line">$ scp ~/spark/tar.gz slave1:~/</span><br><span class="line">$ scp ~/spark/tar.gz slave2:~/</span><br></pre></td></tr></table></figure><p>然后在每个slave节点上执行下方命令，把文件解压到相应路径下，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo rm -rf /usr/local/spark</span><br><span class="line">$ sudo tar -zxvf ~/spark.tar.gz -C /usr/local</span><br><span class="line">$ sudo chown -R user_name /usr/local/spark</span><br></pre></td></tr></table></figure><p>这样就完成了slave节点的配置。</p><p><strong>启动Spark集群</strong></p><p>如果要使用HDFS的话，在启动Spark集群前需要先启动Hadoop集群，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd /usr/local/hadoop/</span><br><span class="line">$ ./sbin/start-all.sh</span><br></pre></td></tr></table></figure><p>然后进入Spark目录，启动Spark集群，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd /usr/local/spark</span><br><span class="line">$ ./sbin/start-all.sh</span><br></pre></td></tr></table></figure><p>需要说明一下，前面配置Hadoop集群是提到，需要配置ssh免密登陆，对于Spark也是同样的道理，如果不配置ssh免密登陆的话，执行./sbin/start-all.sh会提示输入密码。</p><p>除了使用./sbin/start-all.sh启动Spark集群外，还可以分开启动，先启动master节点，然后启动slave节点，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ./sbin/start-master.sh</span><br><span class="line">$ ./sbin/start-slaves.sh</span><br></pre></td></tr></table></figure><p>如果前面没有完成<strong>Master节点配置</strong>指定master节点IP，那么执行./sbin/start-slaves.sh时则无法注册master节点的IP，这样集群计算资源则无法使用。除了配置spark-env.sh指定master节点IP外，还可以通过下面方式指定注册的master节点IP，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./sbin/start-slave.sh 10.110.113.132</span><br></pre></td></tr></table></figure><p>然后分别在master节点和slave节点执行下面命令会看到分别多出一个Master进程和Worker进程。</p><h2 id="Spark基本使用"><a href="#Spark基本使用" class="headerlink" title="Spark基本使用"></a><strong>Spark基本使用</strong></h2><p><strong>运行原理</strong></p><p>如果使用过tensorflow的话，应该对Spark的使用很容易理解，Spark的计算过程和tensorflow有相似之处。</p><p>回忆一下，我们在使用tensorflow时需要首先构造一个计算图，然后实例化一个session，然后用session.run来启动图运算。</p><p>其实Spark也是这样，RDD(弹性分布式数据集)是Spark中最重要的概念之一，它提供了一个共享内存模型。Saprk的执行过程中主要包括两个动作：转换与行动。其中转换操作就如同tensorflow中的构造计算图的过程，在这个过程中Spark构造一个有向无环图(DAG)，但是不进行运算，输入为RDD输出则是一个不同的RDD，当执行行动操作时就如同tensorflow中的session.run，开始执行运算。</p><p>Spark中有很多转换操作，例如，</p><ul><li>groupByKey</li><li>reduceByKey</li><li>sortByKey</li><li>map</li><li>filter</li><li>join</li><li>……</li></ul><p>行动操作包括，</p><ul><li>count</li><li>collect</li><li>first</li><li>foreach</li><li>reduce</li><li>take</li><li>……</li></ul><p><strong>运行模式</strong></p><p>Spark中通过master url来执行Spark的运行模式，Spark的运行模式包括本地运行、集群运行、yarn集群等，关于Spark master url的指定不同运行模式的含义如下，</p><p><strong>URL值运行模式</strong>local使用1个线程本地化运行local[K]使用K个线程本地化运行local[*]使用逻辑CPU个数数量的线程来本地化运行spark://HOST:PORT指定集群模式运行Sparkyarn-cluster集群模式连接YARN集群yarn-client客户端模式连接YARN集群mesos://HOST:PORT连接到指定的Mesos集群</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a><strong>示例</strong></h2><p>下面就以一个简单的示例把前面Hadoop和Spark串联在一起，讲解一下HDFS+Spark的使用方法。</p><p><strong>上传数据到HDFS</strong></p><p>新建一个hello_world.txt的本地文件，并在文件中添加3行hello world，然后上传至HDFS，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ cd /usr/local/hadoop/</span><br><span class="line">$ ./bin/hdfs dfs -mkdir -p /usr/hadoop</span><br><span class="line">$ touch hello_world.txt</span><br><span class="line">$ echo -e &quot;hello world \nhello world \nhello world&quot; &gt;&gt; hello_world.txt</span><br><span class="line">$ ./bin/hdfs dfs -put ./hello_world.txt /usr/hadoop</span><br></pre></td></tr></table></figure><p><strong>编写Spark程序</strong></p><p>新建一个spark.py的Python文件，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vim spark.py</span><br></pre></td></tr></table></figure><p>添加如下内容，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">from pyspark import SparkConf</span><br><span class="line">from pyspark import SparkContext</span><br><span class="line"></span><br><span class="line">conf = SparkConf().setAppName(&quot;FirstProject&quot;).setMaster(&quot;local[*]&quot;)</span><br><span class="line">sc = SparkContext.getOrCreate(conf)</span><br><span class="line">rdd = sc.textFile(&quot;hdfs:///master:9000/usr/hadoop/hello_world.txt&quot;)</span><br><span class="line">rdd.map(lambda line: line).foreach(print)</span><br></pre></td></tr></table></figure><p>然后运行程序，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ python spark.py</span><br><span class="line">hello world</span><br><span class="line">hello world</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure><p>以上就是Spark的集群配置过程和基本使用方法。</p><hr><h2 id="往期内容"><a href="#往期内容" class="headerlink" title="往期内容"></a>往期内容</h2><p><a href="https://jackpopc.github.io/2019/09/14/jupyter/#more">开发工具 | 你真的会用jupyter吗？</a></p><p><a href="https://jackpopc.github.io/2019/09/01/cnn-dropout/">【动手学计算机视觉】第十四讲：正则化之Dropout</a></p><p><a href="https://jackpopc.github.io/2019/09/13/lenet/">【动手学计算机视觉】第十五讲：卷积神经网络之LeNet</a></p><blockquote><p>更多精彩内容，请关注公众号【平凡而诗意】，或者收藏我的个人主页~</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Spark简介&quot;&gt;&lt;a href=&quot;#Spark简介&quot; class=&quot;headerlink&quot; title=&quot;Spark简介&quot;&gt;&lt;/a&gt;&lt;strong&gt;Spark简介&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/10/08/uhcnzV.png&quot; alt=&quot;uhcnzV.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;Spark是由加州伯克利大学AMP实验室于2009年开发并于2013年加入Apache的开源大数据并行计算框架，它凭借自身独有的优势迅速成为Apache三大分布式计算框架之一，对比于常用的hadoop，它具有低时延、速度快、通用性强等优点。
    
    </summary>
    
      <category term="IT技术" scheme="https://jackpopc.github.io/categories/IT%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="大数据" scheme="https://jackpopc.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="Spark" scheme="https://jackpopc.github.io/tags/Spark/"/>
    
      <category term="Hadoop" scheme="https://jackpopc.github.io/tags/Hadoop/"/>
    
  </entry>
  
  <entry>
    <title>【进阶Python】第五讲：迭代器与生成器</title>
    <link href="https://jackpopc.github.io/2019/10/08/generatorr-iterator/"/>
    <id>https://jackpopc.github.io/2019/10/08/generatorr-iterator/</id>
    <published>2019-10-08T14:03:51.000Z</published>
    <updated>2019-10-08T14:38:27.556Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h2><p>迭代是Python中常用且非常强大的一个功能，它可以用于访问集合、列表、字符串、字典等数据结构的元素。我们经常使用循环和条件语句，我们也清楚哪些是可以迭代访问，但是具体它们之间有什么有什么异同之处？有哪些特点？什么是迭代器、什么是生成器、什么是可迭代对象？这些问题对于初学者而言却是很少去细致的研究，本文就来详细阐述一下它们之间的关系已经它们的特别之处。<a id="more"></a></p><h2 id="可迭代对象"><a href="#可迭代对象" class="headerlink" title="可迭代对象"></a><strong>可迭代对象</strong></h2><p><img src="https://s2.ax1x.com/2019/10/08/uhyvcT.png" alt="uhyvcT.png"></p><p>在讲解迭代器和生成器之前，先介绍一下可迭代对象。</p><p>可迭代对象是Python中一个非常庞大的概念，它主要包括如下三类：</p><ul><li>迭代器</li><li>序列</li><li>字典</li></ul><p>从上图可以看出不同概念之间的关系，迭代器是可迭代对象的一个子集，而生成器又是迭代器的一个子集，是一种特殊的迭代器。除了迭代器之外，Python中还有序列、字典等可迭代对象。</p><p>现在已经直观的了解了可迭代对象与迭代器、生成器之间的关系，那么用Python语言怎么表述它们的区别呢？</p><ul><li><strong>可迭代对象需要实现<strong>iter</strong>方法</strong></li><li><strong>迭代器不仅要实现<strong>iter</strong>方法，还需要实现<strong>next</strong>方法</strong></li></ul><p>在使用层面，可迭代对象可以通过<strong>in</strong>和<strong>not in</strong>访问对象中的元素，举一个例子，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">X = set([1,2,3,4,5])</span><br><span class="line">print(X)</span><br><span class="line">print(type(X))</span><br><span class="line">print(1 in X)</span><br><span class="line">print(2 not in X)</span><br><span class="line">for x in X:</span><br><span class="line">    print(x)</span><br><span class="line">    </span><br><span class="line"># 输出</span><br><span class="line">&#123;1, 2, 3, 4, 5&#125;</span><br><span class="line">&lt;class &apos;set&apos;&gt;</span><br><span class="line">True</span><br><span class="line">False</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td></tr></table></figure><p>前面提到，可迭代对象实现了<strong><strong>iter</strong></strong>方法，但是它没有实现<strong><strong>next</strong></strong>，这也是判定迭代器和其他可迭代对象的关键之处，可以看一下通过next访问上述示例中可迭代对象<strong>X</strong>会报错，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">next(X)</span><br><span class="line"></span><br><span class="line"># 输出</span><br><span class="line">TypeError: &apos;set&apos; object is not an iterator</span><br></pre></td></tr></table></figure><p>报的错误是<strong>‘set’ object is not an iterator</strong>，它指明了set集合是一个可迭代对象，但不是迭代器，下面就来介绍一下迭代器。</p><h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a><strong>迭代器</strong></h2><p>迭代器是可迭代对象的一个子集，它是一个可以记住遍历的位置的对象，它与列表、元组、集合、字符串这些可迭代对象的区别就在于next方法的实现，其他列表、元组、集合、字符串这些可迭代对象可以很简单的转化成迭代器，通过Python内置的<strong>iter</strong>函数能够轻松把可迭代对象转化为迭代器，下面来看一个例子，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">X = [1,2,3,4,5]</span><br><span class="line">print(type(X))</span><br><span class="line">Y = iter(X)</span><br><span class="line">print(type(Y))</span><br><span class="line">print(next(Y))</span><br><span class="line">print(next(Y))</span><br><span class="line">print(next(Y))</span><br><span class="line"></span><br><span class="line"># 输出</span><br><span class="line">&lt;class &apos;list&apos;&gt;</span><br><span class="line">&lt;class &apos;list_iterator&apos;&gt;</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure><p>从上述示例中我们可以看出两点：</p><ul><li>通过iter函数把list转化成了迭代器</li><li>可迭代器能够记住遍历位置，能够通过next方法不断从前往后访问</li></ul><p>除了Python内置的<strong>iter</strong>之外，还可以通过Python内置的工具包<strong>itertools</strong>创建迭代器，其中函数包括，</p><ul><li>count</li><li>cycle</li><li>repeat</li><li>accumulate</li><li>chain</li><li>compress</li><li>dropwhile</li><li>islice</li><li>product</li><li>permutations</li><li>combinations</li><li>……</li></ul><p><strong>itertools</strong>中包含很多用于创建迭代器的实用方法，如果感兴趣嗯可以访问官方文档进行详细了解。</p><p>当然，也可以自己通过实现<strong><strong>iter</strong></strong>和<strong><strong>next</strong></strong>方法来定义迭代器，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Iterator(object):</span><br><span class="line">    def __init__(self, array):</span><br><span class="line">        self.x = array</span><br><span class="line">        self.index = 0</span><br><span class="line">    </span><br><span class="line">    def __iter__(self):</span><br><span class="line">        return self</span><br><span class="line">    </span><br><span class="line">    def __next__(self):</span><br><span class="line">        if self.index &lt; len(self.x):</span><br><span class="line">            value = self.x[self.index]</span><br><span class="line">            self.index += 1</span><br><span class="line">        else:</span><br><span class="line">            raise StopIteration</span><br><span class="line">        return value</span><br><span class="line">    </span><br><span class="line">it = Iterator([1,2,3,4,5])</span><br><span class="line">print(type(it))</span><br><span class="line">for i in it:</span><br><span class="line">    print(i)</span><br><span class="line"></span><br><span class="line"># 输出</span><br><span class="line">&lt;class &apos;__main__.Iterator&apos;&gt;</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td></tr></table></figure><h2 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a><strong>生成器</strong></h2><p>从文章开头的流程图可以直观的看出，生成器是迭代器的子集，换句话说，生成器一定是迭代器，但是迭代器不全是生成器对象。</p><p>提及生成器就不得不提及一个Python中的关键字<strong>yiled</strong>，在Python中一个函数可以用yiled替代return返回值，这样的话这个函数就变成了一个生成器对象，举个例子对比一下，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def generator(array):</span><br><span class="line">    for i in array:</span><br><span class="line">        return i</span><br><span class="line">    </span><br><span class="line">gen = generator([1,2,3,4,5])</span><br><span class="line">print(type(gen))</span><br><span class="line"></span><br><span class="line"># 输出</span><br><span class="line">&lt;class &apos;int&apos;&gt;</span><br></pre></td></tr></table></figure><p>这是我们常见的return返回方式，这样的话generator函数获取的是一个int型对象，下面看一下换成yield关键字，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def generator(array):</span><br><span class="line">    for i in array:</span><br><span class="line">        yield(i)</span><br><span class="line">        </span><br><span class="line">gen = generator([1,2,3,4,5])</span><br><span class="line">print(type(gen))</span><br><span class="line"></span><br><span class="line"># 输出</span><br><span class="line">&lt;class &apos;generator&apos;&gt;</span><br></pre></td></tr></table></figure><p>这样的话获取的是一个生成器generator，除了yield之外，在Python3.3之后还加入了<strong>yield from</strong>获取生成器，允许一个生成器将其部分操作委派给另一个生成器，使得生成器的用法变得更加简洁，<strong>yield from</strong>后面需要加上可迭代对象，这样可以把可迭代对象变成生成器，当然，这里的可迭代对象不仅包含列表、元组，还包含迭代器、生成器。<strong>yield from</strong>相对于<strong>yield</strong>的有几个主要优点：</p><ul><li>代码更加简洁</li><li>可以用于生成器嵌套</li><li>易于异常处理</li></ul><p>下面就从简洁代码方面举个例子说明一下，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">def generator(array):</span><br><span class="line">    for sub_array in array:</span><br><span class="line">        yield from sub_array</span><br><span class="line"></span><br><span class="line">gen = generator([(1,2,3), (4,5,6,7)])</span><br><span class="line"></span><br><span class="line"># 输出</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td></tr></table></figure><p>当我们需要访问多层/多维可迭代对象时，我们就不需要逐层的去用<strong>for … in …</strong>去访问，可以简单的通过yiled from把生成器委派给子生成器，除此之外还可以通过<strong>生成器表达式</strong>的方法得到生成式，后面会介绍。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">print(next(gen))</span><br><span class="line">print(next(gen))</span><br><span class="line"></span><br><span class="line"># 输出</span><br><span class="line">1</span><br><span class="line">2</span><br></pre></td></tr></table></figure><p>通过上面示例可以看出，生成器可以像迭代器那样使用iter和next方法。</p><p>读到这里可以会有疑惑，从这个示例看来生成器和迭代器并没有什么区别啊？为什么生成器还可以称得上是Python中的一大亮点？</p><p>首先它对比于迭代器在编码方面更加简洁，这是显而易见的，其次生成器运行速度更快，最后一点，也是需要着重说明的一点：节省内存。</p><p>也许在一些理论性实验、学术论文阶段可以不考虑这些工程化的问题，但是在公司做项目时，内存和资源占用是无法逃避的问题 。如果我们使用其他可迭代对象处理庞大的数据时，当创建或者返回值时会申请用于存储整个可迭代对象的内存，显然这是非常浪费的，因为有的元素当前我们用不到，也不会去访问，但它却一直占用这内存。这时候就体现了生成器的优点，它不是一次性把所有的结果都返回，而是当我们每读取一次，它会返回一个结果，当我们不读取时，它就是一个生成器表达式，几乎不占用内存。</p><h2 id="生成器表达式"><a href="#生成器表达式" class="headerlink" title="生成器表达式"></a><strong>生成器表达式</strong></h2><p>首先来看一个对比示例，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">X = [1, 2, 3, 4, 5]</span><br><span class="line">it = [i for i in X]</span><br><span class="line">gen = (i for i in X)</span><br><span class="line">print(type(X))</span><br><span class="line">print(type(it))</span><br><span class="line">print(type(gen))</span><br><span class="line"></span><br><span class="line"># 输出</span><br><span class="line">&lt;class &apos;list&apos;&gt;</span><br><span class="line">&lt;class &apos;list&apos;&gt;</span><br><span class="line">&lt;class &apos;generator&apos;&gt;</span><br></pre></td></tr></table></figure><p>首先说一下<strong>it = [i for i in X]</strong>，这种用法叫做<strong>列表生成式</strong>，在很多编程规范中非常推崇的一种替代for循环的方式，仔细看一下代码会发现，<strong>it = [i for i in X]</strong>与<strong>gen = (i for i in X)</strong>的区别非常小，只是一个用了中括号，一个用了小括号，但是它们的区别缺失非常大的，使用中括号的叫做列表生成式，获得的返回值是一个列表，而使用小括号叫做生成器表达式，获得的返回结果是一个生成器，这也是前面提到的，除了使用yield和yield from两个关键字外还可以使用生成器表达式获得生成器。</p><hr><h2 id="往期内容"><a href="#往期内容" class="headerlink" title="往期内容"></a>往期内容</h2><p><a href="https://jackpopc.github.io/2019/09/14/jupyter/#more">开发工具 | 你真的会用jupyter吗？</a></p><p><a href="https://jackpopc.github.io/2019/09/01/cnn-dropout/">【动手学计算机视觉】第十四讲：正则化之Dropout</a></p><p><a href="https://jackpopc.github.io/2019/09/13/lenet/">【动手学计算机视觉】第十五讲：卷积神经网络之LeNet</a></p><blockquote><p>更多精彩内容，请关注公众号【平凡而诗意】，也可以收藏我的个人主页~</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;迭代是Python中常用且非常强大的一个功能，它可以用于访问集合、列表、字符串、字典等数据结构的元素。我们经常使用循环和条件语句，我们也清楚哪些是可以迭代访问，但是具体它们之间有什么有什么异同之处？有哪些特点？什么是迭代器、什么是生成器、什么是可迭代对象？这些问题对于初学者而言却是很少去细致的研究，本文就来详细阐述一下它们之间的关系已经它们的特别之处。
    
    </summary>
    
      <category term="Python" scheme="https://jackpopc.github.io/categories/Python/"/>
    
    
      <category term="编程" scheme="https://jackpopc.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Python" scheme="https://jackpopc.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>实用工具 | 推荐10款令人惊艳的免费手机APP</title>
    <link href="https://jackpopc.github.io/2019/09/22/app/"/>
    <id>https://jackpopc.github.io/2019/09/22/app/</id>
    <published>2019-09-22T03:54:28.000Z</published>
    <updated>2019-09-22T06:18:15.987Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我是一个对各种软件、APP充满着好奇心的人，空闲的时候就会打开应用市场，花费上几分钟时间看一下最近有没有什么新鲜的APP。</p><p>我也是一个非常挑剔的人，尽管一个APP相对于整部手机的内存可以忽略不计，但是当体验APP时不足以令我惊艳时我还是会毫不犹豫的把它卸载。</p><p><a id="more"></a>久而久之，我手机上的APP并没有多起来，但是经过各种筛选留下来的我认为都是有很多亮点的。本文就推荐10款不错的APP，后续如果遇到什么好用的APP会再次推荐。</p><blockquote><p>备注：个人使用的是荣耀手机，所以下述APP均可在华为应用市场下载，其他Android系统的品牌手机应该也可以找到对应的APP。</p></blockquote><h1 id="1-一个木涵"><a href="#1-一个木涵" class="headerlink" title="1. 一个木涵"></a>1. 一个木涵</h1><p><img src="https://s2.ax1x.com/2019/09/22/uptnmD.png" alt="uptnmD.png"></p><p>我认为这款APP可以称得上”APP中的百宝箱”，它一款APP集合了几十甚至上百款APP的功能，它的包括但不限于如下功能，</p><ul><li>OCR图片文字识别</li><li>文件清理</li><li>植物识别</li><li>动物识别</li><li>菜品识别</li><li>果蔬识别</li><li>历史上的今天</li><li>进制转换</li><li>画板</li><li>时间屏幕</li><li>汇率转换</li><li>快递查询</li><li>网速测试</li><li>指南针</li><li>二维码生成</li><li>GIF合成</li><li>表情制作</li><li>获取壁纸</li><li>……</li></ul><h1 id="2-全历史"><a href="#2-全历史" class="headerlink" title="2. 全历史"></a>2. 全历史</h1><p><img src="https://s2.ax1x.com/2019/09/22/uptu0e.png" alt="uptu0e.png"></p><p>当我体验一段时间全历史这款APP时我被惊艳了，令人耳目一新。</p><p>我是一个历史爱好者，也是我坚持时间最长的一个兴趣爱好，但是这么多年来有关历史的书籍、工具从没有让我眼前一亮的感觉，大多数都是枯燥乏味、千篇一律、高深莫测，也许这就是越来越少的人喜欢历史的原因吧。</p><p>当我看到这一款APP时，我感觉它真的与众不同，它包含历史地图、关系图谱、国家历史、古书籍、画作、疆域变迁等内容。以<b>时间轴</b>的方式直观展现历史的变迁和上下承接关系，非常吸引人。另外，关系图谱这项功能引起了我的极大兴趣，它直观的展现你所关注人物的关系网络，甚至可以推至几百年前，让你觉得原来历史这么奇妙。</p><h1 id="3-咔嗒"><a href="#3-咔嗒" class="headerlink" title="3. 咔嗒"></a>3. 咔嗒</h1><p><img src="https://s2.ax1x.com/2019/09/22/uptKTH.png" alt="uptKTH.png"></p><p>多媒体盛行的时代，图像在里面占据着不可替代的地位。我同样也是一个摄影爱好者，每当去到一个地方喜欢拍着一些体现不同风土人情、自然风貌的照片。但是我又是一个对修图一窍不通的人，因此每当和朋友谈起不修图时我美其名曰”我喜欢自然、原始的样貌”。其实，适当的修图能够让一幅图像更加有意境，更加吸引人。但是PS这些技术太难学了，虽然近几年所谓的“一键美化”工具层出不穷，但是我觉得99%的APP都是噱头，与其说一键美化，倒不如说是“一键不伦不类”。</p><p>当体验咔嗒这款APP时我并没有抱多大希望，但是体验后顿时让我改观，效果真的让其他美化APP黯然失色。它是一款基于AI的美化工具，能够精准识别图像中的物体，例如汽车、天空、海、建筑物等，然后根据不同的场景选择对应的滤镜对其进行美化，真正可以称得上“一键美化”，上图中左图为原图，右图为一键美化的图片，没有经过任何手动调整的图片。</p><h1 id="4-不做手机控"><a href="#4-不做手机控" class="headerlink" title="4. 不做手机控"></a>4. 不做手机控</h1><p><img src="https://s2.ax1x.com/2019/09/22/uptltA.png" alt="uptltA.png"></p><p>手机在我们生活中的地位越来越无法取代，学习时、工作时、走路时、吃饭时、排队时…无论何时何地总是不乏低头族。慢慢的手机成了让人又爱又恨的东西，它的确给生活带来了很大的便捷和乐趣，但是也的确占据了很多宝贵的时光。可是没办法，自制力是一件很难做到的事情，仅凭自己的意志太困难了。</p><p>和美化工具一样，近几年批判手机负面影响的人越来越多的同时，习惯养成类APP也层出不穷，但是我认为大多数都是在向用户进行妥协，在一些不痛不痒的地带进行约束，制约权还是在用户自身。我觉得不做手机控是一个另类，它相比于其他APP要求更高的权限，当然，它的控制力度更强，当你在计划工作时间内它可以约束除白名单外的任何APP，连自己都无法解开，除非消耗积分。此外，它还有睡眠计划、白噪声、手机使用统计等实用功能，让你对自己的使用情况一目了然。</p><h1 id="5-Stork"><a href="#5-Stork" class="headerlink" title="5. Stork"></a>5. Stork</h1><p><img src="https://s2.ax1x.com/2019/09/22/upt1fI.png" alt="upt1fI.png"></p><p>Stork中文名文献鸟，是一款由斯坦福大学研究人员开发的一款文献追踪神器。</p><p>对于高校学生、科研人员，或者从事偏研究性质岗位的工作人员而言，需要不断的跟踪自己所在领域的前言成果。当然这有很多种方法，可以用谷歌学术订阅对应作者的动态，可以每天关注arXiv，但是我个人并不喜欢这样的方式，以谷歌学术为例，假如我订阅李飞飞的相关文章，她每年挂名的文章可能多达几十篇，而且我认为其中90%是不值得花费时间看的，换句话说，通过arXiv和谷歌学术追踪到的信息很多是没价值的。</p><p>而Stork不同，你可以灵活使用这款APP，可以像谷歌学术那样通过作者名进行订阅，也可以通过关键字进行订阅，它会按照你自己规定的推送频率给你邮件推送相关文章，按照影响因子进行排序，同时还会提供相应文章的下载链接，非常方便。</p><h1 id="6-句读"><a href="#6-句读" class="headerlink" title="6. 句读"></a>6. 句读</h1><p><img src="https://s2.ax1x.com/2019/09/22/uptYX8.png" alt="uptYX8.png"></p><p>优美的句子总是在不经意之间直击人的心灵深处，</p><blockquote><p>人在无端微笑时，不是百无聊赖，就是痛苦难当。(王小波《黄金时代》)</p></blockquote><p>我只所以继续句读这款APP是因为它的特立独行，信息爆炸的时代，各种文字类相关的APP都变了味道，每天推送数不清的文章，而大多数都是没有任何印象的内容，这就锻炼一个人从嘈杂内容中过滤有价值信息的能力。还好有这款句读APP，它每天精选一句话，仅仅一句话，从社区中提炼出一句热门、优美的句子。也许每天你只需要停留5秒钟，久而久之就会发现自己收获了很多。</p><h1 id="7-白描"><a href="#7-白描" class="headerlink" title="7. 白描"></a>7. 白描</h1><p><img src="https://s2.ax1x.com/2019/09/22/uptNnS.png" alt="uptNnS.png"></p><p>图片和PDF转换成可编辑的文字一直以来都是一件令人困扰的事情，转化后的文本混乱，质量差。因此，一直以来我并不信任各种所谓的OCR工具，直到遇到白描这款APP，能够精准、高效的识别图片中的文字，转换后的文本整洁、干净，同时速度非常快，可以看一下上图中识别图片中文字的效果。</p><p>另外需要说明一下，普通用户每天限制识别5次，我觉得这对于大多数用户已经足够使用甚至用不完。</p><h1 id="8-夜间护眼"><a href="#8-夜间护眼" class="headerlink" title="8. 夜间护眼"></a>8. 夜间护眼</h1><p><img src="https://s2.ax1x.com/2019/09/22/upta7Q.png" alt="upta7Q.png"></p><p>我们对手机的依赖越来越重，看书、追剧、看新闻、社交等等，每天眼睛对着屏幕的时间占比非常高，久而久之，对眼睛的伤害自然很严重。一些手机制造商逐渐的开始在手机中加入夜间模式，其实完全没有必要苦苦等待一个定制化的系统功能，不如尝试一下夜间护眼这款APP，它支持夜间、助眠、阅读、游戏等模式，还支持手动调节屏幕颜色，能够针对不同场景设置不同的屏幕颜色，这样在保证我们使用手机的舒适感的情况下同时保护了我们的眼睛。</p><p>此外，它还有很多实用的小功能，例如强制横屏让你的手机秒变平板、视力测试等。</p><h1 id="9-讯飞语记"><a href="#9-讯飞语记" class="headerlink" title="9. 讯飞语记"></a>9. 讯飞语记</h1><p><img src="https://s2.ax1x.com/2019/09/22/upt0ts.png" alt="upt0ts.png"></p><p>我认为养成记录是一个很不错的习惯，俗话说“好记忆不如一个烂笔头”，但是道理都懂，记录是一件让人觉得很麻烦的事情。讯飞语记让这件事情变的简单起来，讯飞在语音识别领域的积淀自然不用多讲，非常厉害，它能够通过对你说话的语音进行快速、准确的识别，然后做好记事记录。此外，它不仅限于一款语音记事APP，它还支持文字识别、待办事项，同时还可以用于笔记排版。</p><p>此外，语言方面讯飞语记在语言/方言方面支持普通话、英语、粤语、四川话、东北话、河南话、山东话、上海话、武汉话、闽南语。</p><h1 id="10-藏书馆"><a href="#10-藏书馆" class="headerlink" title="10. 藏书馆"></a>10. 藏书馆</h1><p><img src="https://s2.ax1x.com/2019/09/22/uptI91.png" alt="uptI91.png"></p><p>也许，电子阅读有很多利润可图，因此，越来越多的互联网、传统出版公司开始进入这一块领域。那些被夸赞的天花烂坠的阅读APP试用了很多，无一例外，均采用<strong>少量免费诱导，然后让你不得不付费的手段</strong>，直到我遇到藏书馆这款APP，可以说让我<strong>豁然开朗</strong>，和其他电子阅读千篇一律的模式不同，藏书馆采用<strong>开放、共享</strong>的运营模式，其他书友可以在这里分享他们的书籍，然后你可以免费的借阅，这就给这款阅读APP带来两个无法比拟的优势：</p><ul><li>免费</li><li>资源丰富</li></ul><p>例如，前段时间朋友向我推荐了一本曼昆的《经济学原理》，我在多款APP上都没有找到这本书籍，最终却在藏书馆这款APP上找到很多阅读资源。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;我是一个对各种软件、APP充满着好奇心的人，空闲的时候就会打开应用市场，花费上几分钟时间看一下最近有没有什么新鲜的APP。&lt;/p&gt;
&lt;p&gt;我也是一个非常挑剔的人，尽管一个APP相对于整部手机的内存可以忽略不计，但是当体验APP时不足以令我惊艳时我还是会毫不犹豫的把它卸载。&lt;/p&gt;
&lt;p&gt;
    
    </summary>
    
      <category term="实用工具" scheme="https://jackpopc.github.io/categories/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="实用工具" scheme="https://jackpopc.github.io/tags/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/"/>
    
      <category term="APP" scheme="https://jackpopc.github.io/tags/APP/"/>
    
      <category term="手机" scheme="https://jackpopc.github.io/tags/%E6%89%8B%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>通用技术 | 正则表达式</title>
    <link href="https://jackpopc.github.io/2019/09/21/regex/"/>
    <id>https://jackpopc.github.io/2019/09/21/regex/</id>
    <published>2019-09-21T11:52:57.000Z</published>
    <updated>2019-09-22T06:17:55.788Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>正则表达式(Regular Expression)是一种既简单，又使用非常广泛的一种技术，我在题目中称其为”必会技术”，这并不夸张，无论是从事开发工作还是做一些文案类工作，甚至日常使用电脑搜索一个文件，都会接触到正则表达式。当然，在很多场景下不使用正则表达式也可以完成同样的工作，但是相对要麻烦很多。</p><a id="more"></a>正则表达式，不熟悉的人第一眼看上去很容易把它认为是一种数学或者其他理工科中的一种表达公式，其实它和公式并没有太大关系。正则表达式是一种文本匹配模式，它能够使用一个或多个简单的字符，去描述匹配一些复杂句法的规则，例如网页、身份证号、出生年月日、家庭住址等。正是因为它的简单且不失强大的特性，它在很多地方都有着应用，一下举几个例子，- everything文件搜索- Python、JS、PHP相关开发- pycharm、sublime等编辑器及IDE- 爬虫- ......也许说到这里还是有一些同学感觉云里雾里，下面就以一个简单的例子来说明一下。<b>假如</b>，给你一个长篇的文章或者上万字的网页，你想从其中匹配出里面的信息，例如<b>身份证号</b>，你会怎么办？当然，这有很多种方法，甚至可以采用最笨的遍历方法去寻找，但是这并不是一个聪明的选择，我们这时就可以使用一个简短的正则表达式来进行匹配，假设下面是要匹配的文本，在陆游的《钗头凤·红酥手》和唐婉的《钗头凤·世情薄》之间插入一个18位、末位为X的假身份证号，<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">红酥手，黄縢酒，满城春色宫墙柳。东风恶，欢情薄。一怀愁绪，几年离索。错、错、错。</span><br><span class="line">春如旧，人空瘦，泪痕红浥鲛绡透。桃花落，闲池阁。山盟虽在，锦书难托。莫、莫、莫！</span><br><span class="line">23453419901011908X</span><br><span class="line">世情薄，人情恶，雨送黄昏花易落。晓风干，泪痕残，欲笺心事，独语斜阑。难，难，难！</span><br><span class="line">人成各，今非昨，病魂常似秋千索。角声寒，夜阑珊，怕人寻问，咽泪装欢。瞒，瞒，瞒！</span><br></pre></td></tr></table></figure><p>对于文本中身份证号的匹配就可以使用下面这段正则表达式，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(\d&#123;18&#125;)|([0-9]&#123;17&#125;(X|x$))</span><br></pre></td></tr></table></figure><p>看一下匹配结果，</p><p><img src="https://s2.ax1x.com/2019/09/22/upNPu8.png" alt="upNPu8.png"></p><p>在解释上述正则表达式含义之前，我们首先想一下身份证号有哪些特点，</p><ul><li>身份证号长度为15位或者18位</li><li>末位为数字或者大写X或者小写x</li></ul><p>以上述文本为例，身份证号长度为18、末位为X，下面来看一下上述正则表达式，</p><p>正则表达式中竖线 <b>|</b> 表示“或”的意思，可以在多个片段中进行选择，所以上述正则表达式可以分为2部分，</p><ol><li>(\d{18})</li><li>([0-9]{17}(X|x$))</li></ol><p>其中<b>(\d{18})</b>中<b>\d</b>匹配任意数字，后面大括号是对前面子表达式的限定符，括号里为整数，表示的含义是匹配前面子表达式的次数，因此这个表达式的含义就是匹配<b>\d</b>18次，换句话说就是匹配数字18次，而有些身份证号就是18位的纯数字，因此这个表达式可以匹配18位纯数字的身份证号。</p><p>然后再看<b>([0-9]{17}(X|x$))</b>，这里面[0-9]和\d的含义是相同的，匹配0-9之间的数字，后面的17的含义是匹配前面数字17次，然后<b>X|x$</b>的含义是以X或x结尾，$是匹配结尾的含义，因此这个表达式的含义就是匹配另外一种身份证号，前面为数字末位为X或x的身份证号。</p><p>到这里，就应该了解了上述正则表达式的含义，匹配两种身份号，一种为纯数字，一种末位为X或x。</p><p>当然，正则表达式的价值远不止于匹配身份证号这么简单，它可以用于一些自然语言处理的数据粗提取，可以用于网页爬虫去匹配一些网页内容、网页链接，同时还可以用于linux命令行的字符、文件匹配。</p><p>读到这里应该就明白，正则表达式就是<b>一些具有特殊含义字符以不同方式组合在一起形成的文本匹配模式</b>，因此，学习正则表达式的关键点也就很明确了，需要了解不同字符的含义，下面就来详细介绍一下。</p><h1 id="字符分类"><a href="#字符分类" class="headerlink" title="字符分类"></a>字符分类</h1><p>我把正则表达式的字符分为如下三类分别进行讲解，</p><ul><li>元字符</li><li>限定字符</li><li>特殊字符</li></ul><h1 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h1><p><b>开头和结尾</b></p><div class="table-container"><table><thead><tr><th style="text-align:center">字符</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">^</td><td style="text-align:center">匹配字符字符串的开始位置</td></tr><tr><td style="text-align:center">$</td><td style="text-align:center">匹配字符字符串的结尾位置</td></tr></tbody></table></div><p>假如待匹配的文本如下，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hello</span><br><span class="line">elloh</span><br><span class="line">llohe</span><br></pre></td></tr></table></figure><p>正则表达式及匹配结果为，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">^h.+   # 正则表达式</span><br><span class="line">hello  # 匹配结果</span><br><span class="line"></span><br><span class="line">.+e$   # 匹配结果</span><br><span class="line">llohe  # 匹配结果</span><br></pre></td></tr></table></figure><p><b>匹配次数相关字符</b></p><div class="table-container"><table><thead><tr><th style="text-align:center">字符</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">*</td><td style="text-align:center">匹配前面子表达式0次或多次</td></tr><tr><td style="text-align:center">+</td><td style="text-align:center">匹配前面子表达式1次或多次</td></tr><tr><td style="text-align:center">？</td><td style="text-align:center">匹配前面子表达式0次或1次</td></tr></tbody></table></div><p>假设待匹配文本为，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">helloooo</span><br></pre></td></tr></table></figure><p>正则表达式及匹配结果为，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">lo+    # 正则表达式</span><br><span class="line">loooo  # 匹配结果</span><br><span class="line"></span><br><span class="line">lo*    # 正则表达式</span><br><span class="line">l      # 匹配结果</span><br><span class="line">loooo  </span><br><span class="line"></span><br><span class="line">lo?    # 正则表达式</span><br><span class="line">l      # 匹配结果</span><br><span class="line">lo</span><br></pre></td></tr></table></figure><h1 id="限定字符"><a href="#限定字符" class="headerlink" title="限定字符"></a>限定字符</h1><p>前面讲到的可以用一些元字符来匹配“次数”相关的字符，但是这些都是模糊的匹配，零次或多次、零次或1次、1次或多次，不够精确。除了这些元字符外还可以通过限定符来匹配准确数量的字符，限定符是以大括号进行标识，</p><div class="table-container"><table><thead><tr><th style="text-align:center">字符</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">{n}</td><td style="text-align:center">匹配前面子表达式n次</td></tr><tr><td style="text-align:center">{n,}</td><td style="text-align:center">匹配前面子表达式至少n次</td></tr><tr><td style="text-align:center">{n,m}</td><td style="text-align:center">匹配前面子表达式至少n次，最多m次</td></tr></tbody></table></div><p>假设待匹配为，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1919190380384083</span><br></pre></td></tr></table></figure><p>正则表达式及匹配结果为，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[0-9]&#123;4&#125;    # 正则表达式</span><br><span class="line">1919        # 匹配结果</span><br><span class="line">1903</span><br><span class="line">8038</span><br><span class="line">4083</span><br></pre></td></tr></table></figure><h1 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h1><p>有一些特殊字符在不同的场景下含义不尽相同，例如？紧跟一个字表达式，含义是匹配0次或者1次，如果跟随其他次数限定相关的字符，它就变成了非贪婪的，也就是说它就会使得匹配次数限定为“较少”的一方，例如<em>的含义是匹配0次或者多次，那么\</em>？就是匹配0次，而不能匹配多次，这就是非贪婪的含义。此外，^和正常字符在一起使用时表示匹配字符的开头，但是在中括号内使用时就成为反向范围的含义，例如[abc]匹配包括a或者b或者c，而[\^abc]的含义是匹配除a\b\c以外的任意字符，下面对特殊字符进行详细说明一下，</p><div class="table-container"><table><thead><tr><th style="text-align:center">字符</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">a\</td><td style="text-align:center">b</td><td>匹配a或b</td></tr><tr><td style="text-align:center">[abc]</td><td style="text-align:center">字符集合，匹配a或b或c</td></tr><tr><td style="text-align:center"><sup><a href="#fn_abc" id="reffn_abc">abc</a></sup></td><td style="text-align:center">反向范围，匹配a、b、c以外任意字符</td></tr><tr><td style="text-align:center">[a-z]</td><td style="text-align:center">匹配a-z26个字母</td></tr><tr><td style="text-align:center"><sup><a href="#fn_a-z" id="reffn_a-z">a-z</a></sup></td><td style="text-align:center">匹配不在a-z之间的任意字符</td></tr><tr><td style="text-align:center">\b</td><td style="text-align:center">匹配单词边界，和^、$类似</td></tr><tr><td style="text-align:center">\B</td><td style="text-align:center">\b的反义，匹配非单词边界</td></tr><tr><td style="text-align:center">\d</td><td style="text-align:center">匹配数字</td></tr><tr><td style="text-align:center">\D</td><td style="text-align:center">匹配非数字</td></tr><tr><td style="text-align:center">\s</td><td style="text-align:center">匹配任何空白字符，包括空格、制表符、换页符</td></tr><tr><td style="text-align:center">\S</td><td style="text-align:center">匹配任何非空白字符</td></tr><tr><td style="text-align:center">\w</td><td style="text-align:center">匹配字母、数字、下划线</td></tr><tr><td style="text-align:center">\W</td><td style="text-align:center">匹配非字母、数字、下划线</td></tr><tr><td style="text-align:center">\f</td><td style="text-align:center">匹配换页符</td></tr><tr><td style="text-align:center">\n</td><td style="text-align:center">匹配换行符</td></tr><tr><td style="text-align:center">\r</td><td style="text-align:center">匹配回车符</td></tr><tr><td style="text-align:center">\t</td><td style="text-align:center">匹配制表符</td></tr></tbody></table></div><p>上述就是我们常用的正则表达式符号，可以根据我们的需求，对上述这些字符进行任意的组合，来完成我们的匹配、查询、替换等工作。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;正则表达式(Regular Expression)是一种既简单，又使用非常广泛的一种技术，我在题目中称其为”必会技术”，这并不夸张，无论是从事开发工作还是做一些文案类工作，甚至日常使用电脑搜索一个文件，都会接触到正则表达式。当然，在很多场景下不使用正则表达式也可以完成同样的工作，但是相对要麻烦很多。&lt;/p&gt;
    
    </summary>
    
      <category term="IT技术" scheme="https://jackpopc.github.io/categories/IT%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="编程" scheme="https://jackpopc.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="正则表达式" scheme="https://jackpopc.github.io/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
      <category term="开发" scheme="https://jackpopc.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>开发工具 | 你真的会用jupyter吗？</title>
    <link href="https://jackpopc.github.io/2019/09/14/jupyter/"/>
    <id>https://jackpopc.github.io/2019/09/14/jupyter/</id>
    <published>2019-09-14T10:58:21.000Z</published>
    <updated>2019-10-08T14:25:03.836Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><img src="https://s2.ax1x.com/2019/09/16/nfW7c9.jpg" alt="nfW7c9.jpg"></p><p>提起jupyter notebook，应该很多学习过Python的同学都不模型。虽然用jupyter notebook的同学相对较少，但是提及这款开发工具，很多人都会赞不绝口，“jupyter很强大，交互式、富文本”，很多人都知道jupyter notebook的这几个优点，<a id="more"></a>但是，试问一下，你真的会用jupyter吗？</p><p>以Python开发为例，我们只需要在windows命令行或者linux/Mac终端输入“jupyter notebook”或者“ipython notebook”即可使用默认浏览器打开一个在线IDE，</p><p><img src="https://s2.ax1x.com/2019/10/08/uh2NDO.png" alt="uh2NDO.png"></p><p>首先说一下交互式，</p><p>jupyter notebook中一个非常重要的概念就是cell，每个cell能够单独进行运算，这样适合于代码调试。我们开发一个完整的脚本时变量会随着代码执行的结束而从内存中释放，如果我们想看中间的变量或者结构，我们只能通过断点或者输出日志信息的方式进行调试，这样无疑是非常繁琐的，如果一个程序运行很多这种方式还可行，如果运行时间长达几个小时，这样我们调试一圈耗费的时间就太长了。</p><p>而在jupyter notebook中我们可以把代码分隔到不同的cell里逐个进行调试，这样它会持续化变量的值，我们可以交互式的在不同cell里获取到我们想要测试的变量值和类型。</p><p><img src="https://s2.ax1x.com/2019/10/08/uh2UbD.png" alt="uh2UbD.png"></p><p>然后说一下富文本，</p><p>开发代码不仅是给机器去“阅读”，也需要让其他的同事、同学能够很容易的阅读，因此，注释就在开发过程中变的非常重要，一个完善的注释能够让周围人更加容易理解，协作效率也更高，避免重复性劳动。在大多数IDE中都可以进行注释，但是几乎都是相同的，只支持一些简单的文本格式注释，这显然是不够的，jupyter notebook支持Markdown编辑，它的cell不仅可以用于编码，还可以用于书写文本，Markdown可以轻松完成标题、数学公式等格式的编辑，更加有助于解释代码，适用于教学等场景。</p><p>最后在说一下轻量、触手可及，</p><p>开发过程中我经常需要测试一个小的代码块或者函数，这时候有两个选择：在IDE中新建一个测试脚本；打开命令行下的Python。我觉的这两个都不是好的选择，如果在项目下新建一个脚本后续还需要记住把它清理掉，如果写一个完善的测试脚本用于Alpha、beta测试这显然是低效不现实的。而选择在命令行下，界面不友好，操作不灵活，体验更差。</p><p>这时候就显现出jupyter notebook的优势，只需要输入jupyter notebook就会在流量器中打开一个网页，能轻量、快捷的进行开发验证，效率很好。此外，我们还可以通过搭建jupyter notebook服务使得它一直在服务器下运行来避免每次需要时都要在命令行下重复打开，我们只需要在浏览器打开对应的网页即可，这一点下文会详细介绍。</p><p>其实，除了这些我们耳熟能详的优点之外，jupyter还有很多令人惊叹的亮点：</p><ul><li>丰富的插件</li><li>主题修改</li><li>多语言支持</li></ul><p>下面就针对这3点分别介绍一下，介绍下面3个功能的前提条件是已经通过下方命令成功安装jupyter notebook，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> pip install jupyter notebook</span><br></pre></td></tr></table></figure><h1 id="丰富的插件"><a href="#丰富的插件" class="headerlink" title="丰富的插件"></a>丰富的插件</h1><p><b>安装插件管理器</b></p><p>如果没有安装插件管理器，打开jupyter notebook后菜单栏只有如下3项，</p><ul><li>Files</li><li>Running</li><li>Clusters</li></ul><p>我们需要安装插件管理器来管理我们需要的插件，</p><p>第一步：用pip安装插件管理包，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> pip install jupyter_contrib_nbextensions</span><br><span class="line"><span class="meta">$</span> pip install jupyter_nbextensions_configurator</span><br></pre></td></tr></table></figure><p>第二步：安装一些插件并启用插件管理器，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> jupyter nbextensions_configurator enable --user</span><br><span class="line"><span class="meta">$</span> jupyter nbextensions_configurator enable --user</span><br></pre></td></tr></table></figure><p>然后再次打开jupyter notebook会发现菜单栏多了一个选项<b>Nbextensions</b>,</p><p><img src="https://s2.ax1x.com/2019/09/16/nffsUK.png" alt="nffsUK.png"></p><p>记得勾选disable configuration for nbextensions without explicit compatibility (they may break your notebook environment, but can be useful to show for nbextension development)，否则下方插件是不可选状态。</p><p>我们可以通过命令来管理开启或关闭某个插件，但是我觉得还是通过直接勾选我们需要的插件效率更高。</p><p><b>选择插件</b></p><p>我们从上面可以看出，jupyter notebook有很多插件，我们该用哪一个呢？我推荐5款个人认为不错的插件。</p><ul><li><b>Table of Contents</b></li><li><b>Execute Time</b></li><li><b>Nofity</b></li><li><b>Codefolding</b></li><li><b>Hinterland</b></li></ul><p>下面分别介绍一下它们的功能，</p><p><img src="https://s2.ax1x.com/2019/09/16/nffhDI.png" alt="nffhDI.png"></p><p><b>Table of Contents</b>是一款自动生成目录的工具，它能够通过我们我们富文本中定义的标题自动生成目录，这样我们能够通过点击左侧目录快速定位到我们想要的到达的代码片段。</p><p><img src="https://s2.ax1x.com/2019/09/16/nffXKs.png" alt="nffXKs.png"></p><p><b>Execute Time</b>顾名思义，执行时间，我觉得这是一款非常实用的插件，在企业项目开发中，效率是永远无法越过的一个门槛，和学术上理论效果足够优秀即可不同，在企业项目中对效率要求也很高，因此，我们需要统计代码的运行时间，其中最初级的用法就是在每个函数开始和结尾处写一个计时语句，这样比较繁琐。然后再高阶一些的用法就是通过装饰器写一些计时器，在每个函数上调用这个装饰器。其实，如果用jupyter notebook完全没必要这么麻烦。我们只需要打开<b>Execute Time</b>，它就能统计每个cell的运行耗费时间，结束时间等，非常详细，一目了然。</p><p><img src="https://s2.ax1x.com/2019/09/16/nfhGqI.png" alt="nfhGqI.png"></p><p><b>Nofity</b>同样是一款非常实用的插件，当我们运行一个耗时较长的代码时，我们不可能一直盯着屏幕等待，但是我们又希望及时知道它运行结束了，Notify这款插件就可以实现这个功能，它能够在代码运行结束时发出通知，及时告知你代码运行结束了。</p><p><img src="https://s2.ax1x.com/2019/09/16/nfhNIf.png" alt="nfhNIf.png"></p><p><b>Codefolding</b>是一款代码折叠工具，有时候我们写的一个函数非常长，但是我们又不关注 ，这样在阅读过程中会使得效率很低，代码折叠就是一个不错的选择，折叠我们不关注的代码块，<b>Codefolding</b>能够像其他IDE那样让你轻松自如的折叠代码块。</p><p><img src="https://s2.ax1x.com/2019/09/16/nfhHdx.gif" alt="nfhHdx.gif"></p><p><b>Hinterland</b>是一款自动补全插件，称一个IDE“优秀”，如果没有自动补全显然是说不过去的。jupyter notebook自带补全功能，但是每次都需要点击<b>tab</b>键来补全，这样效率比较低，我们可以通过勾选<b>Hinterland</b>让jupyter notebook具备自动补全功能，当我们输入几个包含字母后它能够快速补全我们想要的函数，补全速度堪比pycharm。</p><h1 id="主题修改"><a href="#主题修改" class="headerlink" title="主题修改"></a>主题修改</h1><p>很多同学使用jupyter notebook都会觉得，这款开发工具界面太单调了，只有纯白色的主题，其实并不是这样，jupyter notebook也支持主题修改，而且非常方便。</p><p>首先在命令行下输入下面命令安装主题，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> pip install jupyterthemes</span><br></pre></td></tr></table></figure><p>jupyter notebook的主题管理工具叫做<b>jt</b>，我们可以通过下面命令查看可用主题，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> jt -l</span><br><span class="line">Available Themes:</span><br><span class="line">   chesterish</span><br><span class="line">   grade3</span><br><span class="line">   gruvboxd</span><br><span class="line">   gruvboxl</span><br><span class="line">   monokai</span><br><span class="line">   oceans16</span><br><span class="line">   onedork</span><br><span class="line">   solarizedd</span><br><span class="line">   solarizedl</span><br></pre></td></tr></table></figure><p>然后通过下面命令设置主题，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> jt -t &lt;theme_name&gt;</span><br></pre></td></tr></table></figure><p>其中theme_name为主题名称。</p><p><img src="https://s2.ax1x.com/2019/09/16/nf4FFf.png" alt="nf4FFf.png"></p><p>如果觉得不满意，想退回默认主题，可以通过下方命令实现，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> jt -r</span><br></pre></td></tr></table></figure><h1 id="多语言支持"><a href="#多语言支持" class="headerlink" title="多语言支持"></a>多语言支持</h1><p>很多同学是因为Python而解除到jupyter notebook的，因此会认为这就是一款Python专属的开发工具，如果这样的话，那么也不足以我专门用一篇文章来介绍这款开发工具。</p><p>它更像是eclipse、IDEA、vscode，是一款综合的开发工具，它不仅支持Python，还支持C++、julia、R、ruby、Go、Scala、C#、Perl、PHP、Octave、Matlab、Lua、Tcl、等多种编程语言，功能十分强大，支持语言详情，请查看下方链接，</p><p><a href="https://github.com/jupyter/jupyter/wiki/Jupyter-kernels" target="_blank" rel="noopener">https://github.com/jupyter/jupyter/wiki/Jupyter-kernels</a></p><p>不同语言的配置方式各不相同，这里不再一一介绍，可以根据自己需要的语言自行在网上搜索相关配置资料进行配置。</p><h1 id="jupyter-notebook服务"><a href="#jupyter-notebook服务" class="headerlink" title="jupyter notebook服务"></a>jupyter notebook服务</h1><p>如果非要找出使用jupyter notebook的缺点，我认为就是每次启动的时候相对繁琐，我们启动本地安装的IDE，一个命令或者点击一下图标即可，但是如果启动jupyter notebook就需要进入命令行或终端，输入“jupyter notebook”进行打开，如果使用的是虚拟环境，首先还要激活虚拟环境，这无疑是非常繁琐的，而且启动后它会占用一个终端或命令行窗口，如果意外关闭则会终止jupyter notebook服务。其实，这也是有解决方法的，我们搭建一个持续化的jupyter notebook服务，让它一直在服务器后台运行，这样既不占用窗口，也不需要繁琐的打开步骤，我们只需要把对应的URL收藏，每次需要时能够秒级速度打开，下面就来介绍一下jupyter notebook的搭建步骤。</p><p><b>第一步：获取sha1密码</b></p><p>在命令行下输入ipython，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [1]: from IPython.lib import passwd</span><br><span class="line">In [2]: passwd()</span><br><span class="line">Enter password:</span><br><span class="line">Verify password:</span><br><span class="line">Out[2]: 'sha1:746cf729d33f:0af9cda409de9791f237a6c46c3c76a3237962fc'</span><br></pre></td></tr></table></figure><p>导入passwd函数，调用后会让你输入密码，你可以设置一个明文密码，例如123，然后它会生成一个sha1密码串，这个很重要，后面会用到。</p><p>修改jupyter配置文件，linux系统配置文件路径为<b>~/.jupyter/jupyter_notebook_config.py</b>，windows系统配置文件路径为<b>C:\\Users\\User\.jupyter\\jupyter_notebook_config.py</b>，如果没有这个文件，可以使用下面命令生成，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> jupyter notebook --generate-config</span><br></pre></td></tr></table></figure><p>这个配置文件很长，以linux为例，主要关注的是如下几项，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">c.NotebookApp.ip = <span class="string">'*'</span>  </span><br><span class="line">c.NotebookApp.password = u<span class="string">'sha1:xxx:xxx'</span> </span><br><span class="line">c.NotebookApp.open_browser = False </span><br><span class="line">c.NotebookApp.port = 8888</span><br><span class="line">c.NotebookApp.enable_mathjax = True</span><br></pre></td></tr></table></figure><p><b>c.NotebookApp.ip</b>、<b>c.NotebookApp.port</b>，ip要和服务器保持一致，端口可以自行设定，不和其他端口冲突即可，后续访问时在浏览器输入<b>ip:port</b>即可。</p><p><b>c.NotebookApp.password</b>就是前面生成的sha1密码串，复制过来即可。</p><p><b>c.NotebookApp.open_browser = False </b>的含义为是每次启动命令时是否打开浏览器，由于我们用的时候直接输入URL即可，所以这里不需要打开浏览器。</p><p><b>c.NotebookApp.enable_mathjax</b>的含义为是否用mathjax，它是一种用于数学公式显示的工具，这里选True。</p><p>配置好这几项之后保存退出，输入下面命令即可启动，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> nohup jupyter notebook &gt; /dev/null 2&gt;&amp;1 &amp;</span></span><br></pre></td></tr></table></figure><p>nohup的含义是后台运行，这样就不用占用一个窗口来了。</p><p>配置好之后只要服务器不关机，jupyter notebook的服务会一直处于运行状态，我们随时可以使用，只需要打开<b>ip:port</b>即可。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/09/16/nfW7c9.jpg&quot; alt=&quot;nfW7c9.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;提起jupyter notebook，应该很多学习过Python的同学都不模型。虽然用jupyter notebook的同学相对较少，但是提及这款开发工具，很多人都会赞不绝口，“jupyter很强大，交互式、富文本”，很多人都知道jupyter notebook的这几个优点，
    
    </summary>
    
      <category term="开发工具" scheme="https://jackpopc.github.io/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="工具" scheme="https://jackpopc.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="实用" scheme="https://jackpopc.github.io/tags/%E5%AE%9E%E7%94%A8/"/>
    
      <category term="插件" scheme="https://jackpopc.github.io/tags/%E6%8F%92%E4%BB%B6/"/>
    
      <category term="开发工具" scheme="https://jackpopc.github.io/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>【动手学计算机视觉】第十五讲：卷积神经网络之LeNet</title>
    <link href="https://jackpopc.github.io/2019/09/13/lenet/"/>
    <id>https://jackpopc.github.io/2019/09/13/lenet/</id>
    <published>2019-09-13T05:48:55.000Z</published>
    <updated>2019-09-14T10:55:19.743Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><img src="https://s2.ax1x.com/2019/09/14/n6JaHe.png" alt="n6JaHe.png"></p><p>提起卷积神经网络，也许可以避开VGG、GoogleNet，甚至可以忽略AleNet，但是很难不提及LeNet。</p><p>LeNet是由2019年图灵奖获得者、深度学习三位顶级大牛之二的Yann LeCun、Yoshua Bengio于1998年提出(Gradient-based learning applied to document recognition)，<a id="more"></a>它也被认为被认为是最早的卷积神经网络模型。但是，由于算力和数据集的限制，卷积神经网络提出之后一直都被传统目标识别算法(特征提取+分类器)所压制。终于在沉寂了14年之后的2012年，AlexNet在ImageNet挑战赛上一骑绝尘，使得卷积神经网络又一次成为了研究的热点。</p><p>近几年入门计算机视觉的同学大多数都是从AlexNet甚至更新的网络模型入手，了解比较多的就是R-CNN系列和YOLO系列，在很多知名的课程中对LeNet的介绍也是非常浅显或者没有介绍。虽然近几年卷积神经网络模型在LeNet的基础上加入了很多新的单元，在效果方面要明显优于LeNet，但是作为卷积神经网络的基础和源头，它的很多思想对后来的卷积神经网络模型具有很深的影响，因此，我认为了解一下LeNet还是非常有必要的。</p><p>本文首先介绍一下LeNet的网络模型，然后使用tensorflow来一步一步实现LeNet。</p><h1 id="LeNet"><a href="#LeNet" class="headerlink" title="LeNet"></a>LeNet</h1><p><img src="https://s2.ax1x.com/2019/09/14/n6JwAH.png" alt="n6JwAH.png"></p><p>上图就是LeNet的网络结构，LeNet又被称为LeNet-5，其之所以称为这个名称是由于原始的LeNet是一个5层的卷积神经网络，它主要包括两部分：</p><ul><li>卷积层</li><li>全连接层</li></ul><p>其中卷积层数为2，全连接层数为3。</p><p><b>这里需要注意一下</b>，之前在介绍卷积、池化时特意提到，在网络层计数中池化和卷积往往是被算作一层的，虽然池化层也被称为”层”，但是它不是一个独立的运算，往往都是紧跟着卷积层使用，因此它不单独计数。在LeNet中也是这样，卷积层块其实是包括两个单元：卷积层与池化层。</p><p>在网络模型的搭建过程中，我们关注的除了网络层的结构，还需要关注一些超参数的设定，例如，卷积层中使用卷积核的大小、池化层的步幅等，下面就来介绍一下LeNet详细的网络结构和参数。</p><p><b>第一层：卷积层</b></p><p>卷积核大小为5*5，输入通道数根据图像而定，例如灰度图像为单通道，那么通道数为1，彩色图像为三通道，那么通道数为3。虽然输入通道数是一个变量，但是输出通道数是固定的为6。</p><p>池化层中窗口大小为2*2，步幅为2。</p><p><b>第二层：卷积层</b></p><p>卷积核大小为5*5，输入通道数即为上一层的输出通道数6，输出通道数为16。</p><p>池化层和第一层相同，窗口大小为2*2，步幅为2。</p><p><b>第三层：全连接层</b></p><p>全连接层顾名思义，就是把卷积层的输出进行展开，变为一个二维的矩阵(第一维是批量样本数，第二位是前一层输出的特征展开后的向量)，输入大小为上一层的输出16，输出大小为120。</p><p><b>第四层：全连接层</b></p><p>输入大小为120，输出大小为84。</p><p><b>第五层：全连接层</b></p><p>输入大小为84，输出大小为类别个数，这个根据不同任务而定，假如是二分类问题，那么输出就是2，对于手写字识别是一个10分类问题，那么输出就是10。</p><p><b>激活函数</b></p><p>前面文章中详细的介绍了激活函数的作用和使用方法，本文就不再赘述。激活函数有很多，例如Sigmoid、relu、双曲正切等，在LeNet中选取的激活函数为Sigmoid。</p><h1 id="模型构建"><a href="#模型构建" class="headerlink" title="模型构建"></a>模型构建</h1><p><img src="https://s2.ax1x.com/2019/09/14/n6J6jf.png" alt="n6J6jf.png"></p><p>如果已经了解一个卷积神经网络模型的结构，知道它有哪些层、每一层长什么样，那样借助目前成熟的机器学习平台是非常容易的，例如tensorflow、pytorch、mxnet、caffe这些都是高度集成的深度学习框架，虽然在强化学习、图神经网络中表现一般，但是在卷积神经网络方面还是很不错的。</p><p>我绘制了模型构建的过程，详细的可以看一下上图，很多刚入门的同学会把tensorflow使用、网络搭建看成已经非常困难的事情，其实理清楚之后发现并没有那么复杂，它主要包括如下几个部分：</p><ul><li>数据输入</li><li>网络模型</li><li>训练预测</li></ul><p>其中，重点之处就在于网络模型的搭建，需要逐层的去搭建一个卷积神经网络，复杂程度因不同的模型而异。训练测试过程相对简单一些，可以通过交叉熵、均方差等构建损失函数，然后使用深度学习框架自带的优化函数进行优化即可，代码量非常少。</p><p>LeNet、AlexNet、VGG、ResNet等，各种卷积神经网络模型主要的区别之处就在于网络模型，但是网络搭建的过程是相同的，均是通过上述流程进行搭建，因此，本文单独用一块内容介绍模型搭建的过程，后续内容不再介绍网络模型的搭建，会直接使用tensorflow进行编程实践。</p><h1 id="编程实践"><a href="#编程实践" class="headerlink" title="编程实践"></a>编程实践</h1><p><b>完整代码</b>请查看github项目： <a href="https://github.com/Jackpopc/aiLearnNotes/blob/master/computer_vision/LeNet.py" target="_blank" rel="noopener">aiLearnNotes</a></p><p>首先需要说明一下，后续的内容中涉及网络模型搭建的均会选择tensorflow进行编写。虽然近几年pytorch的势头非常迅猛，关于tensorflow的批评之声不绝于耳，但是我一向认为，灵活性和易用性总是成反比的，tensorflow虽然相对复杂，但是它的灵活性非常强，而且支持强大的可视化tensorboard，虽然pytorch也可以借助tensorboard实现可视化，但是这样让我觉得有一些”不伦不类”的感觉，我更加倾向于一体化的框架。此外，有很多同学认为Gluon、keras非常好用，的确，这些在tensorflow、mxnet之上进一步封装的高级深度学习框架非常易用，很多参数甚至不需要开发者去定义，但是正是因为这样，它们已经强行的预先定义在框架里了，可想而知，它的灵活性是非常差的。因此，综合灵活性、一体化、丰富性等方面的考虑，本系列会采用tensorflow进行编程实践。</p><p>其次，需要说明的是本系列重点关注的是网络模型，因此，关于数据方面会采用MNIST进行实践。MNIST是一个成熟的手写字数据集，它提供了易用的接口，方便读取和处理。</p><p>在使用tensorflow接口读取MNIST时，如果本地有数据，它会从本地加载，否则它会从官网下载数据，如果由于代理或者网速限制的原因自动下载数据失败，可以手动从官网下载数据放在MNIST目录下，数据包括4个文件，分别是：</p><ul><li>train-images-idx3-ubyte.gz</li><li>train-labels-idx1-ubyte.gz</li><li>t10k-images-idx3-ubyte.gz</li><li>t10k-labels-idx1-ubyte.gz</li></ul><p>它们分别是训练数据集和标签，测试数据集和标签。</p><p>可能会有人有疑问，手写体识别不是图像吗？为什么是gz的压缩包？因为作者对手写体进行了序列化处理，方便读取，数据原本是衣服单通道28*28的灰度图像，处理后是784的向量，我们可以通过一段代码对它可视化一下，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> tensorflow.examples.tutorials.mnist <span class="keyword">import</span> input_data</span><br><span class="line"></span><br><span class="line">mnist = input_data.read_data_sets(<span class="string">"MNIST"</span>, one_hot=<span class="literal">True</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">12</span>):</span><br><span class="line">    plt.subplot(<span class="number">3</span>, <span class="number">4</span>, i+<span class="number">1</span>)</span><br><span class="line">    img = mnist.train.images[i + <span class="number">1</span>]</span><br><span class="line">    img = img.reshape(<span class="number">28</span>, <span class="number">28</span>)</span><br><span class="line">    plt.imshow(img)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>通过读取训练集中的12副图像，然后把它修改成28*28的图像，显示之后会发现和我们常见的图像一样，</p><p><img src="https://s2.ax1x.com/2019/09/14/n6JB4A.png" alt="n6JB4A.png"></p><p>下面开始一步一步进行搭建网络LeNet，由前面介绍的模型构建过程可以知道，其中最为核心的就是搭建模型的网络架构，所以，首先先搭建网络模型，</p><script type="math/tex; mode=display">y=wx+b</script><p>卷积的运算是符合上述公式的，因此，首先构造第一层网络，输入为批量784维的向量，需要首先把它转化为28*28的图像，然后初始化卷积核，进行卷积、激活、池化运算，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">X = tf.reshape(X, [<span class="number">-1</span>, <span class="number">28</span>, <span class="number">28</span>, <span class="number">1</span>])</span><br><span class="line">w_1 = tf.get_variable(<span class="string">"weights"</span>, shape=[<span class="number">5</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">6</span>])</span><br><span class="line">b_1 = tf.get_variable(<span class="string">"bias"</span>, shape=[<span class="number">6</span>])</span><br><span class="line">conv_1 = tf.nn.conv2d(X, w_1, strides=[<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>], padding=<span class="string">"SAME"</span>)</span><br><span class="line">act_1 = tf.sigmoid(tf.nn.bias_add(conv_1, b_1))</span><br><span class="line">max_pool_1 = tf.nn.max_pool(act_1, ksize=[<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>], strides=[<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>], padding=<span class="string">"SAME"</span>)</span><br></pre></td></tr></table></figure><p>然后构建第二层网络，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">w_2 = tf.get_variable(<span class="string">"weights"</span>, shape=[<span class="number">5</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">16</span>])</span><br><span class="line">b_2 = tf.get_variable(<span class="string">"bias"</span>, shape=[<span class="number">16</span>])</span><br><span class="line">conv_2 = tf.nn.conv2d(max_pool_1, w_2, strides=[<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>], padding=<span class="string">"SAME"</span>)</span><br><span class="line">act_2 = tf.nn.sigmoid(tf.nn.bias_add(conv_2, b_2))</span><br><span class="line">max_pool_2 = tf.nn.max_pool(act_2, ksize=[<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>], strides=[<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>], padding=<span class="string">"SAME"</span>)</span><br></pre></td></tr></table></figure><p>到这里，卷积层就搭建完了，下面就开始搭建全连接层。</p><p>首先需要把卷积层的输出进行展开成向量，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flatten = tf.reshape(max_pool_2, shape=[<span class="number">-1</span>, <span class="number">2</span> * <span class="number">2</span> * <span class="number">16</span>])</span><br></pre></td></tr></table></figure><p>然后紧接着是3个全连接层，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 全连接层1</span></span><br><span class="line"><span class="keyword">with</span> tf.variable_scope(<span class="string">"fc_1"</span>) <span class="keyword">as</span> scope:</span><br><span class="line">    w_fc_1 = tf.get_variable(<span class="string">"weight"</span>, shape=[<span class="number">2</span> * <span class="number">2</span> * <span class="number">16</span>, <span class="number">120</span>])</span><br><span class="line">    b_fc_1 = tf.get_variable(<span class="string">"bias"</span>, shape=[<span class="number">120</span>], trainable=<span class="literal">True</span>)</span><br><span class="line">fc_1 = tf.nn.xw_plus_b(flatten, w_fc_1, b_fc_1)</span><br><span class="line">act_fc_1 = tf.nn.sigmoid(fc_1)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 全连接层2</span></span><br><span class="line"><span class="keyword">with</span> tf.variable_scope(<span class="string">"fc_2"</span>) <span class="keyword">as</span> scope:</span><br><span class="line">    w_fc_2 = tf.get_variable(<span class="string">"weight"</span>, shape=[<span class="number">120</span>, <span class="number">84</span>])</span><br><span class="line">    b_fc_2 = tf.get_variable(<span class="string">"bias"</span>, shape=[<span class="number">84</span>], trainable=<span class="literal">True</span>)</span><br><span class="line">fc_2 = tf.nn.xw_plus_b(act_fc_1, w_fc_2, b_fc_2)</span><br><span class="line">act_fc_2 = tf.nn.sigmoid(fc_2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 全连接层3</span></span><br><span class="line"><span class="keyword">with</span> tf.variable_scope(<span class="string">"fc_3"</span>) <span class="keyword">as</span> scope:</span><br><span class="line">    w_fc_3 = tf.get_variable(<span class="string">"weight"</span>, shape=[<span class="number">84</span>, <span class="number">10</span>])</span><br><span class="line">    b_fc_3 = tf.get_variable(<span class="string">"bias"</span>, shape=[<span class="number">10</span>], trainable=<span class="literal">True</span>)</span><br><span class="line">fc_3 = tf.nn.xw_plus_b(act_fc_2, w_fc_3, b_fc_3)</span><br></pre></td></tr></table></figure><p>这样就把整个网络模型搭完成了，输入是批量图像X，输出是预测的图像，输出是一个10维向量，每一维的含义是当前数字的概率，选择概率最大的位置，就是图像对应的数字。</p><p>完成了网络模型的搭建，它能够将输入图像转化成预测标签进行输出，接下来要做的就是训练和测试部分。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 1. 输入数据的占位符</span></span><br><span class="line">    x = tf.placeholder(tf.float32, [<span class="literal">None</span>, <span class="number">784</span>])</span><br><span class="line">    y = tf.placeholder(tf.float32, [BATCH_SIZE, <span class="number">10</span>])</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 2. 初始化LeNet模型，构造输出标签y_</span></span><br><span class="line">    le = LeNet()</span><br><span class="line">    y_ = le.create(x)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 3. 损失函数，使用交叉熵作为损失函数</span></span><br><span class="line">    loss = tf.reduce_mean(tf.nn.softmax_cross_entropy_with_logits(logits=y_, labels=y))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 4. 优化函数，首先声明I个优化函数，然后调用minimize去最小化损失函数</span></span><br><span class="line">    optimizer = tf.train.AdamOptimizer()</span><br><span class="line">    train_op = optimizer.minimize(loss)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 5. summary用于数据保存，用于tensorboard可视化</span></span><br><span class="line">    tf.summary.scalar(<span class="string">"loss"</span>, loss)</span><br><span class="line">    merged = tf.summary.merge_all()</span><br><span class="line">    writer = tf.summary.FileWriter(<span class="string">"logs"</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 6. 构造验证函数，如果对应位置相同则返回true，否则返回false</span></span><br><span class="line">    correct_pred = tf.equal(tf.argmax(y_, <span class="number">1</span>), tf.argmax(y, <span class="number">1</span>))</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 7. 通过tf.cast把true、false布尔型的值转化为数值型，分别转化为1和0，然后相加就是判断正确的数量</span></span><br><span class="line">    accuracy = tf.reduce_mean(tf.cast(correct_pred, tf.float32))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 8. 初始化一个saver，用于后面保存训练好的模型</span></span><br><span class="line">    saver = tf.train.Saver()</span><br><span class="line">    <span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">        <span class="comment"># 9. 初始化变量</span></span><br><span class="line">        sess.run((tf.global_variables_initializer()))</span><br><span class="line">        writer.add_graph(sess.graph)</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> epoch <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">            <span class="keyword">for</span> step <span class="keyword">in</span> range(<span class="number">1000</span>):</span><br><span class="line">                <span class="comment"># 10. feed_dict把数据传递给前面定义的占位符x、y</span></span><br><span class="line">                batch_xs, batch_ys = mnist.train.next_batch(BATCH_SIZE)</span><br><span class="line">                summary, loss_value, _ = sess.run(([merged, loss, train_op]),</span><br><span class="line">                                                  feed_dict=&#123;x: batch_xs,</span><br><span class="line">                                                             y: batch_ys&#125;)</span><br><span class="line">                print(<span class="string">"epoch : &#123;&#125;----loss : &#123;&#125;"</span>.format(epoch, loss_value))</span><br><span class="line">                <span class="comment"># 11. 记录数据点</span></span><br><span class="line">                writer.add_summary(summary, i)</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">                </span><br><span class="line">        <span class="comment"># 验证准确率</span></span><br><span class="line">        test_acc = <span class="number">0</span></span><br><span class="line">        test_count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">            batch_xs, batch_ys = mnist.test.next_batch(BATCH_SIZE)</span><br><span class="line">            acc = sess.run(accuracy, feed_dict=&#123;x: batch_xs, y: batch_ys&#125;)</span><br><span class="line">            test_acc += acc</span><br><span class="line">            test_count += <span class="number">1</span></span><br><span class="line">        print(<span class="string">"accuracy : &#123;&#125;"</span>.format(test_acc / test_count))</span><br><span class="line">        saver.save(sess, os.path.join(<span class="string">"temp"</span>, <span class="string">"mode.ckpt"</span>))</span><br></pre></td></tr></table></figure><p>上述就是训练部分的完整代码，在代码中已经详细的注释了每个部分的功能，分别包含数据记录、损失函数、优化函数、验证函数、训练过程等，然后运行代码可以看到效果，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">epoch : 4----loss : 0.07602085173130035</span><br><span class="line">epoch : 4----loss : 0.05565792694687843</span><br><span class="line">epoch : 4----loss : 0.08458487689495087</span><br><span class="line">epoch : 4----loss : 0.012194767594337463</span><br><span class="line">epoch : 4----loss : 0.026294417679309845</span><br><span class="line">epoch : 4----loss : 0.04952147603034973</span><br><span class="line">accuracy : 0.9953125</span><br></pre></td></tr></table></figure><p>准确率为99.5%，可以看得出，在效果方面，LeNet在某些任务方面并不比深度卷积神经网络差。</p><p>打开tensorboard可以直观的看到网络的结构、训练的过程以及训练中数据的变换，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> tensorboard --logdir=logs</span></span><br></pre></td></tr></table></figure><p><img src="https://s2.ax1x.com/2019/09/14/n6YwrT.gif" alt="n6YwrT.gif"></p><p>通过损失函数的变化过程可以看出，训练过程在2000步左右基本达到了最优解，</p><p><img src="https://s2.ax1x.com/2019/09/14/n6J0Nd.png" alt="n6J0Nd.png"></p><hr><blockquote><p>更多精彩内容请关注公众号【平凡而诗意】，或者加入我的知识星球【平凡而诗意】~</p></blockquote><p><img src="https://s2.ax1x.com/2019/09/14/n6YcGR.png" alt="n6YcGR.png"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/09/14/n6JaHe.png&quot; alt=&quot;n6JaHe.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;提起卷积神经网络，也许可以避开VGG、GoogleNet，甚至可以忽略AleNet，但是很难不提及LeNet。&lt;/p&gt;
&lt;p&gt;LeNet是由2019年图灵奖获得者、深度学习三位顶级大牛之二的Yann LeCun、Yoshua Bengio于1998年提出(Gradient-based learning applied to document recognition)，
    
    </summary>
    
      <category term="计算机视觉" scheme="https://jackpopc.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
    
      <category term="CV" scheme="https://jackpopc.github.io/tags/CV/"/>
    
      <category term="AI" scheme="https://jackpopc.github.io/tags/AI/"/>
    
      <category term="图像处理" scheme="https://jackpopc.github.io/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>效率工具 | 神器AutoHotkey的使用教程</title>
    <link href="https://jackpopc.github.io/2019/09/06/autohotkey/"/>
    <id>https://jackpopc.github.io/2019/09/06/autohotkey/</id>
    <published>2019-09-06T13:12:49.000Z</published>
    <updated>2019-09-14T10:55:46.586Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简单示例"><a href="#简单示例" class="headerlink" title="简单示例"></a>简单示例</h1><p>AutoHotkey是一款强大、开源的热键脚本工具。在以往的文章里，我介绍了很多强大的效率提升工具，其中包括Wox、Listary、QuickLook等。如果说这些软件在某些领域独树一帜，那么AutoHotkey则是在则是“无所不能”的强大工具。</p><a id="more"></a>易用性和功能的灵活性往往是成反比的，举一个极端的例子，开发语言这类工具在使用方面非常不友好，但是经过开发语言的各种组合可以实现各种手机、PC端软件数不胜数的功能。当然，由于它的使用偏于专业，所以更多人选择定制化较强、界面友好的工具，但是却要牺牲一些灵活性。Autohotkey是一款介于纯编程语言和分发软件之间的一款工具，你可以使用它写一些简单的脚本语言，用内置的一些函数或者自定义的函数去单独或组合使用，以达到我们期望的功能，下面先来看一个示例。先看一个简单的AutoHotkey脚本，<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">^j::</span><br><span class="line">Send, This is a Hotkey!</span><br><span class="line">return</span><br><span class="line"></span><br><span class="line">::hs::This is a HotString!</span><br><span class="line"></span><br><span class="line">^#s::</span><br><span class="line">Run, D:\Sublime Text 3\sublime_text.exe</span><br></pre></td></tr></table></figure><p>然后<b>鼠标右键</b>点击编译，或者双击脚本运行，然后点击对应的快捷键，</p><p><a href="https://imgchr.com/i/nra6KK" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/09/13/nra6KK.gif" alt="nra6KK.gif"></a></p><p>这个演示包括三个动作：</p><ol><li>快捷键启动sublime</li><li>快捷键输入“This is a Hotkey!”</li><li>快捷字符输入“This is a HotString!”</li></ol><p>回到前面给出的AutoHotkey脚本，来一步一步的解释怎么实现的。</p><p><b>第一个动作：快捷键启动sublime</b></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">^#s::</span><br><span class="line">Run, D:\Sublime Text 3\sublime_text.exe</span><br></pre></td></tr></table></figure><p>这句命令实现的是<b>快捷键启动sublime</b>。</p><p>第一行中<b>^</b>和<b>#</b>是两个代表按键的符号，分别代表<b>ctrl</b>和<b>windows</b>，<b>s</b>就是键盘上的s键，<b>::</b>可以认为是命令的结束符号。</p><p>第二行中<b>Run</b>是一个内置函数，用于运行一个工具或者打开一个网页，后面跟的是要打开的网页或者软件路径(如果已经加入到环境变量，就不需要完整的安装路径)。</p><p>因此，上述两行脚本的功能就是<b>ctrl+win+s</b>就可以打开sublime这款软件。</p><p><b>第二个动作：快捷键输入“This is a Hotkey!”</b></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">^j::</span><br><span class="line">Send, This is a Hotkey!</span><br><span class="line">return</span><br></pre></td></tr></table></figure><p>看完第一个动作的介绍，应该很容易理解这个动作，</p><p>第一行的含义是<b>ctrl+j</b>快捷键。</p><p>第二行的含义是<b>发送一段字符串</b>。</p><p><b>第三个动作：快捷字符输入“This is a HotString!”</b></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">::hs::This is a HotString!</span><br></pre></td></tr></table></figure><p>这个和前两个动作不同，介绍这个动作之前需要先简单的了解一下AutoHotkey，它主要包括两个概念：</p><ul><li><p><b>hotkey</b></p></li><li><p><b>hotstring</b></p></li></ul><p>其中hotkey并不陌生，就是热键、快捷键，前两个动作实现的就是快捷键。</p><p>这里需要说一下hotstring，顾名思义，就是<b>通过一段字符串实现一个快捷功能</b>，第三个动作实现的就是一个hotstring功能。</p><p>现在回过头来解释一下第三个动作的脚本的含义，</p><p>两个<b>::</b>之间定义的是快键字符串，后面跟随的是要输入的完整字符串，这样的话在文本框输入<b>hs</b>然后点击<b>Tab</b>键即可在编辑器中输入This is a HotString!这个完整的字符串。</p><p>很多人用惯了快捷键会疑问，hostring有什么价值？我认为它对于开发者或者文本编辑相关的工作者是非常有意义的。我们可以在脚本中预先用一些hostring定义好我们常用的代码块或者文字内容，这样，当输入对应的hostring时就可以快速补全我们想要的内容，速度和资源消耗要远远小于常用的代码补全工具。</p><h1 id="热键符号"><a href="#热键符号" class="headerlink" title="热键符号"></a>热键符号</h1><p>通过前面的简单示例，想必应该对AutoHotkey有了简单的了解，它就是通过一些内置的<b>符号</b>、<b>函数</b>、<b>自定义函数</b>来任意组合，定制化的实现我们想要的功能。</p><p>通过示例中第一个动作<b>^#s</b>代表快捷键<b>ctrl+win+s</b>可以看出，热键符号具有至关重要的作用，我们怎么就知道<b>^</b>代表<b>ctrl</b>、<b>#</b>代表<b>win</b>呢？因为官网给出了不同符号的对应关系，下面是各个符号对应的热键，</p><div class="table-container"><table><thead><tr><th style="text-align:center">符号</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">#</td><td style="text-align:center">win</td></tr><tr><td style="text-align:center">！</td><td style="text-align:center">Alt</td></tr><tr><td style="text-align:center">^</td><td style="text-align:center">Ctrl</td></tr><tr><td style="text-align:center">+</td><td style="text-align:center">Shift</td></tr><tr><td style="text-align:center">&amp;</td><td style="text-align:center">可以在两个组合键之间使用</td></tr><tr><td style="text-align:center">&lt;</td><td style="text-align:center">指定快捷键的位置在左边</td></tr><tr><td style="text-align:center">&gt;</td><td style="text-align:center">指定快捷键的位置在右边</td></tr></tbody></table></div><p><b>注：</b>我们都知道，alt、ctrl、shift这些键都有两个，左右两边均有，&lt;和&gt;两个符号就指定使用左边的符号还是右边的符号，例如<b>&lt;!</b>指定使用左边的Alt键。</p><h1 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h1><p>在示例中，我们也看到使用了<b>Run</b>、<b>Send</b>，这两个称为AutoHotkey的标签，虽然我是以大写字母开头，但是标签名称其实是部分不区分大小写的，可以由空格、制表符、逗号、转义符以外的任何字符组成，但是由于样式的约定，通常最好使用字母、数字、下划线，AutoHotkey常用的内置标签有如下几个，</p><div class="table-container"><table><thead><tr><th style="text-align:center">标签</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">Send</td><td style="text-align:center">向编辑器发送一段字符</td></tr><tr><td style="text-align:center">SendInput</td><td style="text-align:center">同上</td></tr><tr><td style="text-align:center">MsgBox</td><td style="text-align:center">弹出对话框</td></tr><tr><td style="text-align:center">Run</td><td style="text-align:center">运行一个工具或打开网页</td></tr><tr><td style="text-align:center">WinActivate</td><td style="text-align:center">窗口激活</td></tr><tr><td style="text-align:center">WinWaitActive</td><td style="text-align:center">窗口等待激活</td></tr></tbody></table></div><p>下面看一个例子，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">^j::</span><br><span class="line">Run, https://www.baidu.com</span><br><span class="line">MsgBox, 已经打开网页！</span><br><span class="line">return</span><br></pre></td></tr></table></figure><p>有了前面的基础，应该很容易理解这个脚本，它是一个组合功能，分别是打开网页和弹出对话框，下面看看效果，</p><p><a href="https://imgchr.com/i/nraD81" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/09/13/nraD81.gif" alt="nraD81.gif"></a></p><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>想要更加灵活，仅仅使用上述这些符号、标签显然是不够的。和大多数编程语言一样，AutoHotkey也支持自定义函数，这才是它的强大之处。</p><p>AutoHotkey内置了一些常用的函数，如下，</p><div class="table-container"><table><thead><tr><th style="text-align:center">函数</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">FileExist</td><td style="text-align:center">检查文件或文件夹是否存在，并返回其属性</td></tr><tr><td style="text-align:center">GetKeyState</td><td style="text-align:center">获取按键状态，向下返回true，向上返回false</td></tr><tr><td style="text-align:center">InStr</td><td style="text-align:center">从左或右搜索字符串的给定出现项</td></tr><tr><td style="text-align:center">RegExMatch</td><td style="text-align:center">确定字符串是否包含正则表达式匹配模式</td></tr><tr><td style="text-align:center">RegExReplace</td><td style="text-align:center">替换字符串中出现的模式(正则表达式)</td></tr><tr><td style="text-align:center">StrLen</td><td style="text-align:center">获取字符串长度</td></tr><tr><td style="text-align:center">StrReplace</td><td style="text-align:center">替换字符串</td></tr><tr><td style="text-align:center">StrSplit</td><td style="text-align:center">用指定的分隔符分割字符串</td></tr><tr><td style="text-align:center">SubStr</td><td style="text-align:center">按指定位置返回子字符串</td></tr></tbody></table></div><p>当然，AutoHotkey内置的函数远不止这些，它还包括以下类型的函数：</p><ul><li>文件读取</li><li>数学计算</li><li>条件判断</li><li>异常处理</li><li>状态获取</li><li>鼠标键盘</li><li>屏幕状态</li><li>声音</li><li>进程管理</li><li>窗口状态</li><li>……</li></ul><p>没错，AutoHotkey在功能和丰富性方面丝毫不亚于一些老的脚本语言，但是它的优点是<b>更加实用</b>。我们可以即写即用，能够辅助我们日常生活中多种场景的工作。</p><h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><p><b>快捷启动</b></p><p>这方面它可以替代Wox、Listary这些快速启动工具，我们可以把常用的网站、软件用脚本的方式定义不同的hotkey或者hotstring，当我们需要打开一个网页或者软件时就不需要再繁琐、多步骤的去寻找、打开。</p><p>例如用下面这个脚本，能够快速打开优酷、B站、直播吧，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">^y::</span><br><span class="line">Run, https://www.youku.com/</span><br><span class="line">return</span><br><span class="line"></span><br><span class="line">^b::</span><br><span class="line">Run, https://www.bilibili.com/</span><br><span class="line">return</span><br><span class="line"></span><br><span class="line">^z::</span><br><span class="line">Run, https://www.zhibo8.cc/</span><br><span class="line">return</span><br></pre></td></tr></table></figure><p><a href="https://imgchr.com/i/nrargx" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/09/13/nrargx.gif" alt="nrargx.gif"></a></p><p><b>自动补全</b></p><p>我们在日常开发或者文本编辑时，会有大量重复的工作，以编程为例，我们会有很多重复的代码块，因此，才有各种各样的补全工具，但是目前大多数补全工具可以说是差强人意，速度方面甚至不及自己手动敲代码的速度，但是通过AutoHotkey把我们常用的代码块、文本用hotkey、hotstring代替，这样能够快速的补全我们想要的内容，</p><p>例如，用下面几行脚本补全我们常用的代码片段，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">::np::import numpy as np</span><br><span class="line">::plt::from matplotlib import pyplt as plt</span><br><span class="line">::tf::import tensorflow as tf</span><br></pre></td></tr></table></figure><p><a href="https://imgchr.com/i/nraBCR" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/09/13/nraBCR.gif" alt="nraBCR.gif"></a></p><p><b>效率提升</b></p><p>关于效率提升，这就因人而异，不同的人工作内容不同，因此常用的操作和功能也截然不同，这方面就需要发散思维，总结一下平时自己常用的操作，例如管理进程、取色、文件读取、编程、数学运算等，可以根据自己的需求，使用内置的或者自定义的函数来组合成自己想要的功能，当然，AutoHotkey内置了很多标签、函数，这足以满足日常大多数场景的需求。</p><p><b>软件分发</b></p><p>我们经常在能够在开源平台寻找到很多别人写的软件，其实自己也可以利用AutoHotkey实现一些比较有趣、高效的工具，它不像C++、Java那么难以入门，而且在代码规范方面要求没那么严格，因此门槛相对较低。此外，AutoHotkey脚本的编译非常迅速，资源消耗低，能够一键编译成我们常见的<b>exe</b>软件，这样的话可以把它分享给周围的同学、同事，或者更多的人，这样在提高周围人效率的同时能够锻炼自己的产品思维和开发规范。</p><h1 id="安装与基本操作"><a href="#安装与基本操作" class="headerlink" title="安装与基本操作"></a>安装与基本操作</h1><p><b>下载安装包</b></p><p>AutoHotkey是一款开源免费的工具，能够直接从官网下载AutoHotkey的安装包，</p><p><a href="https://www.autohotkey.com/" target="_blank" rel="noopener">https://www.autohotkey.com/</a></p><p>如果觉得麻烦，也可以在公众号后台回复关键字<font color="red"><b>hot</b></font>获取安装包。</p><p><b>安装</b></p><p><img src="https://s2.ax1x.com/2019/09/13/nra58I.png" alt="nra58I.png"></p><p>双击下载的安装包，会弹出安装界面，直接一步步往下点击即可，如果需要更改安装路径，可以在<b>location</b>页面进行更改。</p><p><b>新建脚本</b></p><p><img src="https://s2.ax1x.com/2019/09/13/nraI2t.png" alt="nraI2t.png"></p><p>成功安装后，在桌面或者其他空白处点击<b>鼠标右键-新建-AutoHotkey Script</b>，来创建一个AutoHotkey脚本。</p><p><b>编辑脚本</b></p><p><img src="https://s2.ax1x.com/2019/09/13/nra7Kf.png" alt="nra7Kf.png"></p><p>创建脚本后，鼠标右键点击脚本，可以看到有三个选项：<b>Run Script</b>、<b>Compile Script</b>、<b>Edit Script</b>。</p><p>可以先点击<b>Edit Script</b>，它会用记事本打开，当然也可以用sublime、UE、notepad++等文本编辑器打开，然后进行编辑。</p><p>编辑之后可以双击脚本直接运行，也可以点击<b>Run Script</b>运行脚本，这样就可以使用我们脚本中定义的快捷键或者快捷字符串，此外，还可以点击<b>Compile Script</b>把脚本编译成<b>exe</b>文件，这样的话脚本会被加密，可以用于分发，其他使用者就无法看到工具源码。</p><p><img src="https://s2.ax1x.com/2019/09/13/nraHr8.png" alt="nraHr8.png"></p><hr><blockquote><p>更多精彩内容请关注公众号【平凡而诗意】，或者加入我的知识星球【平凡而诗意】~</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;简单示例&quot;&gt;&lt;a href=&quot;#简单示例&quot; class=&quot;headerlink&quot; title=&quot;简单示例&quot;&gt;&lt;/a&gt;简单示例&lt;/h1&gt;&lt;p&gt;AutoHotkey是一款强大、开源的热键脚本工具。在以往的文章里，我介绍了很多强大的效率提升工具，其中包括Wox、Listary、QuickLook等。如果说这些软件在某些领域独树一帜，那么AutoHotkey则是在则是“无所不能”的强大工具。&lt;/p&gt;
    
    </summary>
    
      <category term="实用工具" scheme="https://jackpopc.github.io/categories/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="文件查找" scheme="https://jackpopc.github.io/tags/%E6%96%87%E4%BB%B6%E6%9F%A5%E6%89%BE/"/>
    
      <category term="工具" scheme="https://jackpopc.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="实用" scheme="https://jackpopc.github.io/tags/%E5%AE%9E%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>【动手学计算机视觉】第十四讲：正则化之Dropout</title>
    <link href="https://jackpopc.github.io/2019/09/01/cnn-dropout/"/>
    <id>https://jackpopc.github.io/2019/09/01/cnn-dropout/</id>
    <published>2019-09-01T05:10:08.000Z</published>
    <updated>2019-09-01T10:05:47.006Z</updated>
    
    <content type="html"><![CDATA[<p>本文完整代码请查看：<a href="https://github.com/Jackpopc/aiLearnNotes/blob/master/computer_vision/dropout.py" target="_blank" rel="noopener">aiLearnNotes</a></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在前几讲里已经介绍了卷积神经网络中常用的一些单元，例如，</p><ul><li>卷积层</li><li>池化层</li><li>填充</li><li>激活函数</li><li>批量归一化</li></ul><a id="more"></a>本文会介绍最后一个卷积神经网络中常用的单元Dropout，可以称之为“丢弃法”，或者“随机失活”。它在2012年由Alex Krizhevsky、Geoffrey Hinton提出的那个大名鼎鼎的卷积神经网络模型AlexNet中首次提出并使用，Dropout的使用也是AlexNet与20世纪90年代提出的LeNet的最大不同之处。随后，Krizhevsky和Hinton在文章《Dropout: A Simple Way to Prevent Neural Networks from Overtting》又详细的介绍了介绍了Dropout的原理。发展至今，Dropout已经成为深度学习领域一个举足轻重的技术，它的价值主要体现在解决模型的<b>过拟合</b>问题，虽然它不是唯一的解决过拟合的手段，但它却是兼备轻量化和高效两点做的最好的一个手段。“丢弃法”，从字面意思很好理解，就是丢弃网络中的一些东西。丢弃的是什么？神经元，<b>有放回的随机丢弃一些神经元</b>。很多刚接触或者使用过Dropout的同学都会觉得“这有什么好讲的？这是一个非常简单的东西啊。”，如果仅仅从<b>使用</b>角度来讲，这的确非常简单。以目前主流的机器学习平台而言，tensorflow、mxnet、pytorch，均是传入一个<b>概率值</b>即可，一行代码即可完成。但是，我认为学习深度学习如果仅仅是为了<b>会使用</b>，那么真的没什么可以学习的，抽空把tensorflow教程看一下既可以称得上<b>入门深度学习</b>。如果剖开表象看一下Dropout的原理，会发现，它的理论基础是非常深的，从作者先后用《Improving neural networks by preventing co-adaptation of feature detectors》《Dropout: A Simple Way to Prevent Neural Networks from Overtting》等多篇文章来阐述这个算法就可以看出它的不可小觑的价值。和往常<b>先讲理论再讲用法</b>不同，本文先介绍一下它在tensorflow中的用法，然后做一个了解后带着问题去介绍它的理论知识，本文主要包括如下几块内容，- tensorflow中Dropout的使用- 优化与机器学习的区别- 过拟合- Dropout理论知识# tensorflow中Dropout的使用在tensorflow中Dropout的函数为，<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tf.nn.dropout(x, keep_prob, noise_shape=<span class="literal">None</span>, seed=<span class="literal">None</span>, name=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure><p>函数中的参数分别是：</p><p><b>x：</b>Dropout的输入，即为上一层网络的输出</p><p><b>keep_prob：</b>和x尺寸相同的张量(多维向量)，它用于定义每个神经元的被保留的概率，假如keep_prob=0.8，那么它被保留的概率为0.8，换个角度说，它有20%的概率被丢弃。</p><p><b>noise_shape：</b>表示随机生成的保存/删除标志的形状，默认值为None。</p><p><b>seed：</b>一个用于创建随机种子的整数，默认值为None。</p><p><b>name：</b>运算或操作的名称，可自行定义，默认值为None。</p><p>上述5个参数中x和keep_prob为必须参数，其他很少用到，所以不多介绍。x不难理解，就是上一层网络的输出。这里主要提示一下keep_prob，它是Dropout使用中最为重要的参数。</p><p><b>注意：</b>keep_prob是网络中每个神经元被保留的概率，并非是神经网络中神经元被保留个数的概率。举个例子，加入有个3层神经网络，共100个神经元，定义keep_prob=0.6，那么并不是说要保留60个神经元而丢弃40个。而是每个神经元将会有60%的概率被保留，40%的概率被丢弃，所以最终剩余的神经元并不是确切的60个，可能多于60也可能少于60。</p><p><b>策略：</b>深度学习是一门经验主义非常重的方向，Dropout的使用同样需要很多经验。一般情况下建议靠近输入层的把keep_prob设置大一些，就是靠近输入层经历多保留神经元。</p><h1 id="优化与机器学习的区别"><a href="#优化与机器学习的区别" class="headerlink" title="优化与机器学习的区别"></a>优化与机器学习的区别</h1><p>讲完Dropout的使用，话说回来，为什么要用Dropout？</p><p>提到这个问题，就不得不先做一下铺垫，先谈一下优化与机器学习的区别。</p><p>机器学习主要包括如下几块内容：</p><ul><li>数据集</li><li>模型</li><li>损失函数</li><li>优化算法</li></ul><p>其中优化算法直接决定着最终模型效果的好坏，因此，很多人都肆意的扩大优化算法的价值，认为“机器学习就是优化算法”。</p><p>我认为这是不严谨的说法机器学习与优化算法有这本质的区别。优化算法主要用于已知或未知数学模型的优化问题，它主要关注的是在既定模型上的误差，而不关注它的泛化误差。而机器学习则不同，它是在训练集上训练书模型，训练过程中与优化算法类似，考虑在训练集上的误差，但是它对比于优化算法还要多一步，要考虑在测试集上的泛化误差。</p><h1 id="过拟合"><a href="#过拟合" class="headerlink" title="过拟合"></a>过拟合</h1><p><img src="https://s2.ax1x.com/2019/09/01/np6Aa9.png" alt="np6Aa9.png"></p><center><font size="2">(图片截取自吴恩达《深度学习工程师》)</font></center><p>在训练集和测试集这两个数据集上的精确度就引出几种情况：</p><ul><li>在训练集上效果不好，在测试集上效果也不好：欠拟合(上图中第一种情况)</li><li>在训练集上效果很好，在测试集上效果不好：过拟合(上图中第三种情况)</li></ul><p>在实际项目中，这两种情况是非常常见的，显然，这并不是我们想要的，我们追求的是第三种情况：</p><ul><li>在训练集和测试集上的效果都相对较好(上图中第二种情况)</li></ul><p>但是，事与愿违，欠拟合和过拟合是机器学习中非常常见的现象，尤其是<b>过拟合</b>。</p><p>过拟合的形成原因主要包括如下几点：</p><ul><li>训练数据集太少</li><li>参数过多</li><li>特征维度过高</li><li>模型过于复杂</li><li>噪声多</li></ul><p>很多研究者把目光和精力都聚焦在解决过拟合这个问题上，目前用于解决过拟合问题的算法有很多，例如，</p><ul><li>权重衰减</li><li>Early stopping</li><li>批量归一化(没错，就是前一讲讲的BN，它也带有一些正则化的功能)</li></ul><p>在解决过拟合问题的算法中最为知名的词汇莫过于<b>正则化</b>。</p><p>提到正则化，很多同学会想到L1、L2正则化，其实它是一类方法的统称，并非仅限于L1、L2正则化，目前用于结果过拟合的正则化方法主要包括如下几种：</p><ul><li>数据扩充</li><li>L1、L2正则化</li><li>Dropout</li></ul><p>没错，Dropout也是正则化方法中的一种！铺垫这么多，终于引出本文的主角了。</p><p>数据扩充解决过拟合，这一点不难理解，因为数据缺少是引起过拟合的主要原因之一，由于数据的却是导致模型学习过程中不能学到全局特征，只能通过少量数据学习到一个类别的部分特征，通过数据的扩充能够让模型学习到全局特征，减少过拟合现象。</p><p>L1、L2正则化主要为损失函数添加一个L1或L2的正则化惩罚项，防止学习过程中过于偏向于某一个方向引起过拟合。</p><p>最后就轮到Dropout，下面来详细讲一下Dropout的原理。</p><h1 id="Dropout"><a href="#Dropout" class="headerlink" title="Dropout"></a>Dropout</h1><p><b>如何使用Dropout？</b></p><p><img src="https://s2.ax1x.com/2019/09/01/npyTv8.png" alt="npyTv8.png"></p><center><font size="2">(图片来自于《Dropout: A Simple Way to Prevent Neural Networks from Overtting》)</font></center><p>上图中左图为一个标准的神经网络，右图是采用Dropout之后的神经网络，其中的区别一目了然，就是丢弃了一些神经元。</p><p>前面已经讲解了在tensorflow中如何使用Dropout，已经清楚，对于Dropout最为核心的就是保留概率或者丢弃概率，简述它的原理就是：遍历神经网络的每一层中每一个神经元，以一定概率丢弃或保留某个神经元。用数学语言描述如下，</p><p>假设某一个神经元的输入有4个，那么神经元的计算表达式为，</p><script type="math/tex; mode=display">h_{i}=\phi\left(x_{1} w_{1 i}+x_{2} w_{2 i}+x_{3} w_{3 i}+x_{4} w_{4 i}+b_{i}\right)</script><p>其中$x_i$是输入，$w$是权重，$b$是偏差。</p><p>假设保留概率为$p$，那么丢弃改为就为$1-p$，那么神经元$h_i$就有$1-p$的概率被丢弃，那么经过Dropout运算后的神经元为，</p><script type="math/tex; mode=display">h_{i}^{\prime}=\frac{\xi_{i}}{1-p} h_{i}</script><p>其中$\xi_{i}$为0或者1，它为0或者1的概率分别为$1-p$和$p$，如果为0,则这个神经元被清零，<b>临时</b>被丢弃，一定要注意，是临时的丢弃，Dropout是有放回的采样。在一轮训练中前向或反向传播都会用丢弃后的神经网络，下一轮训练又会随机丢弃，用一个新的网络去训练。</p><p>编程实现Dropout其实只需要几行代码，下面结合代码来解释，会更容易理解，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dropout</span><span class="params">(X, keep_prob)</span>:</span></span><br><span class="line">    <span class="keyword">assert</span> <span class="number">0</span> &lt; keep_prob &lt; <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> keep_prob == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> np.zeros(X.shape)</span><br><span class="line">    mask = np.random.uniform(<span class="number">0</span>, <span class="number">1</span>, X.shape) &lt; keep_prob</span><br><span class="line">    <span class="keyword">return</span> mask * X / keep_prob</span><br></pre></td></tr></table></figure><p>输入参数为上一层的激活值和保留概率，</p><p>第3行：如果保留概率为0，也就是不保留的话，则全部元素都丢弃。</p><p>第5行：生成一个随机的掩码，掩码和输入X形状相同，每个位置非0即1，然后用这个掩码与X相乘，如果对应位置乘以0，则这个神经元被丢弃，反之保留。</p><p><b>Dropout为什么起作用？</b></p><p><a href="https://imgchr.com/i/npybDg" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/09/01/npybDg.png" alt="npybDg.png"></a></p><center><font size="2">(图片来自《深度学习》)</font></center><p>这里不得不提一下Bagging集成集成学习方法，在Bagging集成学习方法中，预先会定义k的模型，然后采用k个训练集，然后分别训练k个模型，然后以各种方式去评价、选取最终学习的模型。</p><p>Dropout的训练过程中与Bagging集成学习方法类似，以上图为例，有一个三层神经网络(两个输入神经元、两个隐藏神经元、一个输出神经元)，从这个基础的网络中随机删除<b>非输出神经元</b>来构建一些子集。这样每一次训练就如同在这些子集中随机选择一个不同的网络模型进行训练，最后通过”投票”或者平均等策略而选择出一个最好的模型。</p><p>其实这个思想并不陌生，在传统机器学习中Adaboost、随机森林都是采用集成学习的思想，效果非常好。采用Dropout后的深度神经网络和这类思想也是类似的，这样能够结合不同网络模型的训练结果对最终学习的模型进行评价，能够综合多数，筛选掉少数，即便是某个网络模型出现了过拟合，最终经过综合也会过滤掉，效果自然会好很多。</p><p>需要说明一点的是，虽然采用Dropout和其他集成学习方法思想有异曲同工之处，但是也有一些细节的差异。在Bagging中所有模型都是独立的，但是在Dropout中所有模型是共享参数的，每个子模型会继承父网络的网络参数，这样可以有效的节省内存的占用。</p><h1 id="需要注意的点"><a href="#需要注意的点" class="headerlink" title="需要注意的点"></a>需要注意的点</h1><p>到这里，Dropout的内容就讲解完了，总结一些本文，需要有几点需要注意，</p><ul><li>keep_prob是每个<b>神经元</b>被保留的概率</li><li>Dropout和L1、L2、数据扩充都属于正则化方法</li><li>Dropout的丢弃是<b>有放回</b>的</li></ul><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ol><li>Dropout: A Simple Way to Prevent Neural Networks from Overtting</li><li>Dropout as data augmentation</li><li>Improving Neural Networks with Dropout</li><li>Improving neural networks by preventing co-adaptation of feature detectors</li><li>《深度学习》</li></ol><h1 id="资源获取"><a href="#资源获取" class="headerlink" title="资源获取"></a>资源获取</h1><p>我把参考文献中列出的4片文章和《深度学习》这本书籍的电子版进行整理共享了，感兴趣的可以关注公众号，回复关键字“<font color="red"><b>dl</b></font>”获取。</p><p><img src="https://s2.ax1x.com/2019/09/01/np6CKU.png" alt="np6CKU.png"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文完整代码请查看：&lt;a href=&quot;https://github.com/Jackpopc/aiLearnNotes/blob/master/computer_vision/dropout.py&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;aiLearnNotes&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;在前几讲里已经介绍了卷积神经网络中常用的一些单元，例如，&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;卷积层&lt;/li&gt;
&lt;li&gt;池化层&lt;/li&gt;
&lt;li&gt;填充&lt;/li&gt;
&lt;li&gt;激活函数&lt;/li&gt;
&lt;li&gt;批量归一化&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="计算机视觉" scheme="https://jackpopc.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
    
      <category term="CV" scheme="https://jackpopc.github.io/tags/CV/"/>
    
      <category term="AI" scheme="https://jackpopc.github.io/tags/AI/"/>
    
      <category term="图像处理" scheme="https://jackpopc.github.io/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>【进阶Python】第四讲：类的特殊方法(下篇)</title>
    <link href="https://jackpopc.github.io/2019/08/28/python-4/"/>
    <id>https://jackpopc.github.io/2019/08/28/python-4/</id>
    <published>2019-08-28T11:44:57.000Z</published>
    <updated>2019-08-28T14:13:54.343Z</updated>
    
    <content type="html"><![CDATA[<p><strong>完整代码</strong>请查看github项目: <a href="https://github.com/Jackpopc/advance-python/blob/master/2-magic-method_2.ipynb" target="_blank" rel="noopener">advance-python</a></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>特殊方法是为我们定义的类添加上某些特殊功能的方法，上一讲分组讲解了Python的几对特殊方法(或者成为魔术方法)，分别是，</p><ul><li>__new__与__init__</li><li>__enter__与__exit__</li><li>__str__与__repr__</li><li>__setattr__、__getattr__、__getattribute__与__delattr__</li></ul><a id="more"></a>这些都是相对较为常用的。Python中类的特殊方法远不止这些，其中还有一些不太常用，或者在某些特定场景下用到的特殊方法。本讲会按照功能对剩余的特殊方法进行分类，不再详细的把每个特殊方法的使用都展开阐述，会着重的从每种功能中挑选出具有代表性的特殊方法进行实现、详细讲解。# 函数调用假如我们定义一个用于算数运算的类，<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Operation</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x, y)</span>:</span></span><br><span class="line">        self.x = x</span><br><span class="line">        self.y = y</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"The result is &#123;&#125;"</span>.format(self.x + self.y))</span><br><span class="line">      </span><br><span class="line">opt = Operation(<span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">opt.add()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">The result <span class="keyword">is</span> <span class="number">4</span></span><br></pre></td></tr></table></figure><p>从这段代码可以看出 ，这是我们一贯使用类及类方法的方式，实例化—调用，其实Python提供有特殊方法__call__能够让类的调用像调用函数的方式一样。</p><p>这句话听着似乎很绕口，具体什么含义呢？用一段代码来说明，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Operation</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.x = <span class="literal">None</span></span><br><span class="line">        self.y = <span class="literal">None</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"The result is &#123;&#125;"</span>.format(self.x + self.y))</span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, x, y)</span>:</span></span><br><span class="line">        self.x = x</span><br><span class="line">        self.y = y</span><br><span class="line">        self.add()</span><br><span class="line">        </span><br><span class="line">opt = Operation()</span><br><span class="line">opt(<span class="number">3</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">The result <span class="keyword">is</span> <span class="number">6</span></span><br></pre></td></tr></table></figure><p>当我们给类添加特殊方法__call__后，我们可以直接使用实例名(opt)来调用类的方法，就不用在用instance.method的方法去调用。换句话说就是，当我们定义__call__后，我们使用实例名进行调用时，它会首先进入__call__方法，执行__call__中的程序。</p><h1 id="容器与序列"><a href="#容器与序列" class="headerlink" title="容器与序列"></a>容器与序列</h1><p>容器和序列分别涉及2个特殊方法：__contains__、__len__。</p><p>从__len__名称就可以看出它的功能，给类添加一个获取序列长度的功能，所以这里着重讲解一下容器，顺带讲解一下__len__。</p><p>我们在<b>条件语句</b>中经常会用到这样的语句<b>if … in</b>、<b>if … not in</b>，其中__contains__就可以给类添加这样一个功能，可以通过<b>if … in</b>、<b>if … not in</b>来调用类的实例，以一段代码来举例，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Contain</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, data)</span>:</span></span><br><span class="line">        self.data = data</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__contains__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> x <span class="keyword">in</span> self.data</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> len(self.data)</span><br><span class="line">    </span><br><span class="line">contain = Contain([<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="number">2</span> <span class="keyword">in</span> contain:</span><br><span class="line">    print(<span class="string">"222222"</span>)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> <span class="number">6</span> <span class="keyword">not</span> <span class="keyword">in</span> contain:</span><br><span class="line">    print(<span class="string">"666666"</span>)</span><br><span class="line">    </span><br><span class="line">len(contain)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line"><span class="number">222222</span></span><br><span class="line"><span class="number">666666</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure><p>从代码中可以看出，当我们调用<b>if 2 in contain</b>时会调用__contains__这个特殊方法，通过方法中的语句返回一个布尔型的值。</p><p>此外，可以看到代码中有这样一句调用<b>len(contain)</b>，它就是前面提到的特殊方法__len__的功能，它可以给类添加一个<b>获取序列长度</b>的功能，当使用len(instance)时会调用__len__方法中的程序。</p><h1 id="算数运算"><a href="#算数运算" class="headerlink" title="算数运算"></a>算数运算</h1><p>用于实现算数运算的有以下类的特殊方法的有以下几个，</p><div class="table-container"><table><thead><tr><th>运算</th><th>代码</th><th>特殊方法</th></tr></thead><tbody><tr><td>加法</td><td>a + b</td><td>__add__</td></tr><tr><td>减法</td><td>a - b</td><td>__sub__</td></tr><tr><td>乘法</td><td>a * b</td><td>__mul__</td></tr><tr><td>除法</td><td>a / b</td><td>__truediv__</td></tr><tr><td>向下取整除法</td><td>a // b</td><td>__floordiv__</td></tr><tr><td>取余</td><td>a % b</td><td>__mod__</td></tr></tbody></table></div><p>以一段代码举例说名加法与乘法的使用，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Operation</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        self.value = value</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__add__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> Operation(self.value + other.value)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__mul__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> Operation(self.value * other.value)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"the value if &#123;&#125;"</span>.format(self.value)</span><br><span class="line">    </span><br><span class="line">a = Operation(<span class="number">3</span>)</span><br><span class="line">b = Operation(<span class="number">5</span>)</span><br><span class="line">print(a + b)</span><br><span class="line">print(a * b)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">the value <span class="keyword">if</span> <span class="number">8</span></span><br><span class="line">the value <span class="keyword">if</span> <span class="number">15</span></span><br></pre></td></tr></table></figure><p>同理，其他几种算法运算的使用方法同加法、乘法相同。</p><h1 id="比较运算"><a href="#比较运算" class="headerlink" title="比较运算"></a>比较运算</h1><p>类的特殊方法不仅提供了算术运算，还提供了比较运算的特殊方法，它们分别是，<br>| 运算         | 代码   | 特殊方法         |<br>| —————— | ——— | ———————— |<br>| 等于         | a == b  | __eq__      |<br>| 不等         | a != b  | __ne__      |<br>| 大于         | a &gt; b  | __gt__      |<br>| 小于         | a &lt; b  | __lt__  |<br>| 大于等于 | a &gt;= b | __ge__ |<br>| 小于等于         | a &lt;= b  | __le__      |</p><p>以一段代码解释比较运算符的使用，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cmp</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        self.value = value</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__eq__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.value == other.value</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__gt__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.value &gt; other.value</span><br><span class="line">a = Cmp(<span class="number">3</span>)</span><br><span class="line">b = Cmp(<span class="number">3</span>)</span><br><span class="line">a == b</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><p>可以看出，比较运算和算术运算的使用非常相似。</p><h1 id="字典功能"><a href="#字典功能" class="headerlink" title="字典功能"></a>字典功能</h1><p>我们可以通过如下几个特殊方法为类添加如同字典一样的功能，<br>| 运算         | 代码   | 特殊方法         |<br>| —————— | ——— | ———————— |<br>| 取值         | x[key]  | __setitem__      |<br>| 设置值         | x[key]=value  | __getitem__      |<br>| 删除值         | del x[key]  | __delitem__      |</p><p>下面以一段代码举例说明，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dictionaries</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__setitem__</span><span class="params">(self, key, value)</span>:</span></span><br><span class="line">        self.__dict__[key] = value</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, key)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.__dict__[key]</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__delitem__</span><span class="params">(self, key)</span>:</span></span><br><span class="line">        <span class="keyword">del</span> self.__dict__[key]</span><br><span class="line"></span><br><span class="line">diction = Dictionaries()</span><br><span class="line">diction[<span class="string">"one"</span>] = <span class="number">1</span></span><br><span class="line">diction[<span class="string">"two"</span>] = <span class="number">2</span></span><br><span class="line">diction[<span class="string">"three"</span>] = <span class="number">3</span></span><br><span class="line">diction[<span class="string">'three'</span>]</span><br><span class="line"><span class="keyword">del</span> diction[<span class="string">'three'</span>]</span><br><span class="line">diction[<span class="string">'three'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">KeyError                                  Traceback (most recent call last)</span><br><span class="line">&lt;ipython-input<span class="number">-57</span>-dfe1a566046b&gt; <span class="keyword">in</span> &lt;module&gt;()</span><br><span class="line">----&gt; 1 diction['three']</span><br><span class="line"></span><br><span class="line">&lt;ipython-input<span class="number">-55</span><span class="number">-21</span>dcfd1e91cb&gt; <span class="keyword">in</span> __getitem__(self, key)</span><br><span class="line">      <span class="number">4</span> </span><br><span class="line">      <span class="number">5</span>     <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, key)</span>:</span></span><br><span class="line">----&gt; 6         return self.__dict__[key]</span><br><span class="line">      <span class="number">7</span> </span><br><span class="line">      <span class="number">8</span>     <span class="function"><span class="keyword">def</span> <span class="title">__delitem__</span><span class="params">(self, key)</span>:</span></span><br><span class="line"></span><br><span class="line">KeyError: <span class="string">'three'</span></span><br></pre></td></tr></table></figure><p>可以看出，当删除键值为three的值之后再次去获取会报错。</p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>除了上述提到的特殊方法之后，Python还有很多特殊方法，这里不一一举例说明，下面列举出这些特殊方法以及它们的功能和使用方法，如果感兴趣的可以对应的去查找文档学习。</p><div class="table-container"><table><thead><tr><th>运算</th><th>代码</th><th>特殊方法</th></tr></thead><tbody><tr><td>类析构函数</td><td>del instant</td><td>__del__</td></tr><tr><td>格式化字符串</td><td>format(x, format_spec)</td><td>__format__</td></tr><tr><td>遍历迭代器</td><td>iter(list)</td><td>__iter__</td></tr><tr><td>取迭代器下一个值</td><td>next(list)</td><td>__next__</td></tr><tr><td>列出类的所有属性和方法</td><td>dir(instance)</td><td>__dir__</td></tr><tr><td>自定义散列值</td><td>hash(instance)</td><td>__hash__</td></tr><tr><td>自定义拷贝</td><td>copy.copy(instance)</td><td>__copy__</td></tr><tr><td>自定义深层拷贝</td><td>copy.deepcopy(instance)</td><td>__deepcopy__</td></tr><tr><td>上下文环境布尔值</td><td>if instance:</td><td>__bool__</td></tr></tbody></table></div><p>当然，除了这些，Python还有其他的特殊方法，例如逻辑运算、按位运算等，感兴趣的可以参考官方文档仔细学习一下，本文仅列举一些相对常用的一些特殊方法。</p><h1 id="文档获取"><a href="#文档获取" class="headerlink" title="文档获取"></a>文档获取</h1><p>本讲的Markdown格式文档我进行共享了，需要的可以关注公众号【平凡而诗意】回复关键字”<font color="red"><b>python</b></font>“获取。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;完整代码&lt;/strong&gt;请查看github项目: &lt;a href=&quot;https://github.com/Jackpopc/advance-python/blob/master/2-magic-method_2.ipynb&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;advance-python&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;特殊方法是为我们定义的类添加上某些特殊功能的方法，上一讲分组讲解了Python的几对特殊方法(或者成为魔术方法)，分别是，&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;__new__与__init__&lt;/li&gt;
&lt;li&gt;__enter__与__exit__&lt;/li&gt;
&lt;li&gt;__str__与__repr__&lt;/li&gt;
&lt;li&gt;__setattr__、__getattr__、__getattribute__与__delattr__&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Python" scheme="https://jackpopc.github.io/categories/Python/"/>
    
    
      <category term="编程" scheme="https://jackpopc.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Python" scheme="https://jackpopc.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>【动手学计算机视觉】第十三讲：批量归一化</title>
    <link href="https://jackpopc.github.io/2019/08/24/cnn-bn/"/>
    <id>https://jackpopc.github.io/2019/08/24/cnn-bn/</id>
    <published>2019-08-24T12:37:58.000Z</published>
    <updated>2019-08-25T12:04:10.762Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>当我们用一些数据做一个预测系统时，我们首先需要对数据进行预处理，例如标准化、正则化、滑动窗口等，比如常用的Z-score、最大最小标准化，它能将数据转化为同一个量级，这样的话能够保证数据的稳定性、可比性。</p><a id="more"></a>这些标准化方法在浅层神经网络中已经足够使用，效果已经很不错。但是在深度学习中，网络越来越深，使用这些标准化方法就难以解决相应的问题。<b>为什么需要批量归一化？</b>在训练过程中，每层输入的分布不断的变化，这使得下一层需要不断的去适应新的数据分布，在深度神经网络中，这让训练变得非常复杂而且缓慢。对于这样，往往需要设置更小的学习率、更严格的参数初始化。通过使用批量归一化(Batch Normalization, BN)，在模型的训练过程中利用小批量的均值和方差调整神经网络中间的输出，从而使得各层之间的输出都符合均值、方差相同高斯分布，这样的话会使得数据更加稳定，无论隐藏层的参数如何变化，可以确定的是前一层网络输出数据的均值、方差是已知的、固定的，这样就解决了数据分布不断改变带来的训练缓慢、小学习率等问题。<b>在哪里使用批量归一化？</b>批量归一化是卷积神经网络中一个可选单元，如果使用BN能够保证训练速度更快，同时还可以具备一些正则化功能。在卷积神经网络中卷积层和全连接层都可以使用批量归一化。对于卷积层，它的位置是在卷积计算之后、激活函数之前。对于全连接层，它是在仿射变换之后，激活函数之前，如下所示：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">conv_1 = tf.nn.conv2d()</span><br><span class="line">norm_1 = tf.nn.batch_normalization(conv_1)</span><br><span class="line">relu_1 = tf.nn.relu(norm_1)</span><br><span class="line">pool_1 = tf.nn.max_pool(relu_1)</span><br></pre></td></tr></table></figure><p>以卷积层为例，网络架构的流程为：</p><ul><li>卷积运算</li><li>批量归一化</li><li>激活函数</li><li>池化</li></ul><h1 id="批量归一化"><a href="#批量归一化" class="headerlink" title="批量归一化"></a>批量归一化</h1><p><img src="https://s2.ax1x.com/2019/08/25/m2YzZR.png" alt="m2YzZR.png"></p><p>在讲批量归一化之前，首先讲一下数据标准化处理算法Z-score。</p><p>Z-score标准化也成为标准差标准化，它是将数据处理成均值为0，方差为1的标准正态分布，它的转化公式为，</p><script type="math/tex; mode=display">x^{*}=\frac{x-\overline{x}}{\sigma}</script><p>其中$x$是处理前的数据，$x^{*}$是处理后的数据，$\overline{x}$是原始数据的均值，$\sigma$是原始的标准差。这样的话就可以把数据进行标准化。</p><p>其实批量归一化在思想上和Z-score是有很多共通之处的。</p><p>在深度学习训练过程中会选取一个小批量，然后计算小批量数据的均值和方差，</p><script type="math/tex; mode=display">\boldsymbol{\mu}_{\mathcal{B}} \leftarrow \frac{1}{m} \sum_{i=1}^{m} \boldsymbol{x}^{(i)}</script><script type="math/tex; mode=display">\sigma_{\mathcal{B}}^{2} \leftarrow \frac{1}{m} \sum_{i=1}^{m}\left(\boldsymbol{x}^{(i)}-\boldsymbol{\mu}_{\mathcal{B}}\right)^{2}</script><p>然后对数据进行归一化处理，</p><script type="math/tex; mode=display">\hat{\boldsymbol{x}}^{(i)} \leftarrow \frac{\boldsymbol{x}^{(i)}-\boldsymbol{\mu}_{\mathcal{B}}}{\sqrt{\boldsymbol{\sigma}_{\mathcal{B}}^{2}+\epsilon}}</script><script type="math/tex; mode=display">\boldsymbol{y}^{(i)} \leftarrow \boldsymbol{\gamma} \odot \hat{\boldsymbol{x}}^{(i)}+\boldsymbol{\beta}</script><p>经过这样处理，就可以使得数据符合均值为$\boldsymbol{\mu}$、方差为$\sigma_{\mathcal{B}}^{2}$的高斯分布。</p><p>下面看一下原文中批量归一化的算法步骤：</p><p><img src="https://s2.ax1x.com/2019/08/25/m2tpIx.png" alt="m2tpIx.png"></p><ul><li>获取每次训练过程中的样本</li><li>就算小批量样本的均值、方差</li><li>归一化</li><li>拉伸和偏移</li></ul><p>这里要着重介绍一下最后一步尺度变换(scale and shift)，前面3步已经对数据进行了归一化，为什么还需要拉伸和偏移呢？</p><p>因为经过前三步的计算使得数据被严格的限制为均值为0、方差为1的正态分布之下，这样虽然一定程度上解决了训练困难的问题，但是这样的严格限制网络的表达能力，通过加入$\gamma$和$\beta$这两个参数可以使得数据分布的自由度更高，网络表达能力更强。另外，这两个参数和其他参数相同，通过不断的学习得出。</p><h1 id="tensorflow中BN的使用"><a href="#tensorflow中BN的使用" class="headerlink" title="tensorflow中BN的使用"></a>tensorflow中BN的使用</h1><p>在tensorflow中可以直接调用批量归一化对数据进行处理，它的函数为，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tf.nn.batch_normalization(x, mean, variance, offset, scale, variance_epsilon, name=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure><p>来解释一下函数中参数的含义：</p><ul><li>x：输入的数据，可以是卷积层的输出，也可以是全连接层的输出</li><li>mean：输出数据的均值</li><li>variance：输出数据的方差</li><li>offset：偏移，就是前面提到的beta</li><li>scale：缩放，前面提到的gamma</li><li>variance_epsilon：一个极小的值，避免分母为0</li></ul><hr><p>更多内容，请关注公众号【平凡而诗意】~</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;当我们用一些数据做一个预测系统时，我们首先需要对数据进行预处理，例如标准化、正则化、滑动窗口等，比如常用的Z-score、最大最小标准化，它能将数据转化为同一个量级，这样的话能够保证数据的稳定性、可比性。&lt;/p&gt;
    
    </summary>
    
      <category term="计算机视觉" scheme="https://jackpopc.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
    
      <category term="CV" scheme="https://jackpopc.github.io/tags/CV/"/>
    
      <category term="AI" scheme="https://jackpopc.github.io/tags/AI/"/>
    
      <category term="图像处理" scheme="https://jackpopc.github.io/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>实用资源 | 推荐6个高赞有趣的Github项目</title>
    <link href="https://jackpopc.github.io/2019/08/23/github-project/"/>
    <id>https://jackpopc.github.io/2019/08/23/github-project/</id>
    <published>2019-08-23T13:36:09.000Z</published>
    <updated>2019-08-25T12:05:45.760Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Github，应该很多同学都听过这个鼎鼎大名的开源项目托管平台。</p><p>刚开始接触github，我和大多数同学一样，仅仅把它当作一个开源项目搜索工具。比如当看到一篇文章，会去搜索一下看看作者有没有开源源代码，仅此而已，因此一直以来对github的依赖都不太强。</p><p><a id="more"></a>最近几个月以来，我每天会特意抽出一段时间去github看一下，看看近期有没有什么热门有趣的项目，慢慢的，在github上发现了很多不错的项目，久而久之就对其产生了依赖。现在每天都会去看一下，在这个过程总的确从这些优质的开源项目上学到了很多，收获了很多，下面我就推荐5个我个人觉得不错的开源项目。</p><h1 id="free-programming-books-zh-CN"><a href="#free-programming-books-zh-CN" class="headerlink" title="free-programming-books-zh_CN"></a>free-programming-books-zh_CN</h1><p>项目地址：<a href="https://github.com/justjavac/free-programming-books-zh_CN" target="_blank" rel="noopener">https://github.com/justjavac/free-programming-books-zh_CN</a></p><p><strong>star：54k+</strong></p><p><img src="https://s2.ax1x.com/2019/08/25/m2YGUx.jpg" alt="m2YGUx.jpg"></p><p>在从事IT、互联网相关的开发过程中，我们会用到各种各样的知识，linux、数据库、编程语言、虚拟化等。这样就需要我们不断的去学习，很多时间和金钱比较充足的可以选择一些课程或者买一些书籍，但是大多数人是不会把所用到知识相关的书籍都购买一遍。这样就面临一个问题：<strong>我们该去哪获取相应的学习资源？</strong></p><p>free-programming-books-zh_CN收集了计算机领域很多知名的书籍，它包括但不限于以下种类：</p><ul><li>各种编程语言</li><li>版本控制</li><li>数据库</li><li>大数据</li><li>操作系统</li><li>编译原理</li><li>web</li><li>…</li></ul><p>有了这个项目就再也不用担心学习资源的问题了，它手机了计算机各个分支相关的经典书籍和优质学习资源，避免了在茫茫的网络中去搜索的麻烦。</p><h1 id="sherlock"><a href="#sherlock" class="headerlink" title="sherlock"></a>sherlock</h1><p>项目地址：<a href="https://github.com/sherlock-project/sherlock" target="_blank" rel="noopener">https://github.com/sherlock-project/sherlock</a></p><p><strong>star：6.8k+</strong></p><p>在到处充斥着互联网、社交的时代，<strong>用户名</strong>是每个人都不陌生的词汇，当我们注册一个社交网站，例如知乎、微博等，需要起一个名称。很多人都喜欢独一无二、与众不同，但是在这么多用户名字，一不小心就和别人重复了，sherlock这个项目就可以解决这个问题，它能够在不同的社交网站上搜索是否存在指定的用户名，这样的话你就可以看到自己起的用户名有没有重复？有哪些重复。</p><p><img src="https://s2.ax1x.com/2019/08/25/m2YtPK.gif" alt="m2YtPK.gif"></p><h1 id="weekly"><a href="#weekly" class="headerlink" title="weekly"></a>weekly</h1><p>项目地址：<a href="http://link.zhihu.com/?target=https%3A//github.com/ruanyf/weekly" target="_blank" rel="noopener">http://link.zhihu.com/?target=https%3A//github.com/ruanyf/weekly</a><br><strong>star：8.1k+</strong></p><p>这是一个科技爱好者周刊。</p><p>现在是一个信息爆炸的社会，各种新媒体、自媒体，每天各个APP有看不完、层出不穷的新闻，但是，我个人认为大多数自媒体的水平有待商榷，在他们看来，一个吸引人的标题比实际的内容还要重要。所以我很苦恼，每天喜欢看看新闻，但是花费几十分钟后发现都是一些乱七八糟没有价值的新闻。</p><p>直到几个月前我在github看到weekly这个项目，它每周五定期更新一次，慢慢的，周五在我心里有了一些期待，期待着这个项目更新周刊。</p><p>为什么它如此吸引我？</p><p><img src="https://s2.ax1x.com/2019/08/25/m2Y0rd.png" alt="m2Y0rd.png"></p><p>它与众不同，而且都是经过筛选的一些新奇有趣的新闻，我觉得称其为新闻，但它不仅限于新闻，它包含如下内容：</p><ul><li>新奇的资讯</li><li>优质中文、英文文章</li><li>高效工具</li><li>资源</li><li>精选图片</li><li>文摘</li><li>言论</li></ul><h2 id="UnblockNeteaseMusic"><a href="#UnblockNeteaseMusic" class="headerlink" title="UnblockNeteaseMusic"></a>UnblockNeteaseMusic</h2><p>项目地址：<a href="http://link.zhihu.com/?target=https%3A//github.com/nondanee/UnblockNeteaseMusic" target="_blank" rel="noopener">http://link.zhihu.com/?target=https%3A//github.com/nondanee/UnblockNeteaseMusic</a></p><p><strong>star：4.4k+</strong></p><p><img src="https://s2.ax1x.com/2019/08/25/m2Ysat.png" alt="m2Ysat.png"></p><p>从这个项目的名称即可看出它的功能，<strong>unblock netease music</strong>。</p><p>网易云音乐是很多人喜欢的一款音乐播放器，我也不例外，但是发现它上面的音乐越来越少，当你想听一首歌时发现，它竟然是灰色的，也就是不能听。</p><p>有了这个项目，它可以从QQ / 虾米 / 百度 / 酷狗 / 酷我 / 咕咪 / JOOX等音乐源寻找资源进行替换，也就是说，有了UnblockNeteaseMusic+网易云音乐，你可以听来自不同音乐源的歌曲。</p><h1 id="ChineseBQB"><a href="#ChineseBQB" class="headerlink" title="ChineseBQB"></a>ChineseBQB</h1><p>项目地址：<a href="https://github.com/zhaoolee/ChineseBQB" target="_blank" rel="noopener">https://github.com/zhaoolee/ChineseBQB</a></p><p><strong>star：5k+</strong></p><p>这个一个表情包博物馆，目前共收录了3319个表情包，包含各种各样热门、搞笑的表情包，有了这个github项目，再也不用为”斗图”担心了。</p><p>先来几个看一下，</p><p><img src="https://s2.ax1x.com/2019/08/25/m2Yoaq.gif" alt="m2Yoaq.gif"><br><img src="https://s2.ax1x.com/2019/08/25/m2Y4qs.gif" alt="m2Y4qs.gif"><br><img src="https://s2.ax1x.com/2019/08/25/m2YIZn.gif" alt="m2YIZn.gif"></p><h1 id="LeetCodeAnimation"><a href="#LeetCodeAnimation" class="headerlink" title="LeetCodeAnimation"></a>LeetCodeAnimation</h1><p>项目地址：<a href="https://github.com/MisterBooo/LeetCodeAnimation" target="_blank" rel="noopener">https://github.com/MisterBooo/LeetCodeAnimation</a></p><p><strong>star：38k+</strong></p><p>娱乐之后不得不说一些沉重的话题，已经是8月底了，大批量的校招马上就要开始了 ~</p><p>不知道关注我的同学里有多少位要参加今年的校园招聘，如果有，首先预祝各位找到理想的工作！</p><p>其次，就是推荐一份不错的学习资源。</p><p>LeetCode，这个大名鼎鼎的平台应该很多参加过校招或者即将参加校招的同学应该都有所耳闻，是很多参加互联网、IT方向校招同学的必经之路，甚至周围有同事说”没有刷过LeetCode的校招，是不完整的！”。</p><p>github上有关leetcode的项目有很多，但是99%都是如出一辙，把leetcode上的题目做一下或者寻找一些答案，然后上传到github，只有静态的代码和简短的文字描述，这对于很多初学者是很难以理解的。</p><p>LeetCodeAnimation这个项目却与众不同，它通过动画的形式来阐述不同算法的解题思路，更加生动形象，下面就看一个例子—无重复字符的最长子串，</p><p><img src="https://s2.ax1x.com/2019/08/25/m2YvL9.gif" alt="m2YvL9.gif"></p><hr><p>更多内容，请关注公众号【平凡而诗意】~</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;Github，应该很多同学都听过这个鼎鼎大名的开源项目托管平台。&lt;/p&gt;
&lt;p&gt;刚开始接触github，我和大多数同学一样，仅仅把它当作一个开源项目搜索工具。比如当看到一篇文章，会去搜索一下看看作者有没有开源源代码，仅此而已，因此一直以来对github的依赖都不太强。&lt;/p&gt;
&lt;p&gt;
    
    </summary>
    
      <category term="学习资源" scheme="https://jackpopc.github.io/categories/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90/"/>
    
    
      <category term="机器学习" scheme="https://jackpopc.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="Github" scheme="https://jackpopc.github.io/tags/Github/"/>
    
      <category term="资源" scheme="https://jackpopc.github.io/tags/%E8%B5%84%E6%BA%90/"/>
    
  </entry>
  
  <entry>
    <title>【动手学计算机视觉】第十二讲：激活函数</title>
    <link href="https://jackpopc.github.io/2019/08/21/activation/"/>
    <id>https://jackpopc.github.io/2019/08/21/activation/</id>
    <published>2019-08-21T12:04:17.000Z</published>
    <updated>2019-08-21T14:08:43.554Z</updated>
    
    <content type="html"><![CDATA[<p><strong>完整代码</strong>链接：<a href="https://github.com/Jackpopc/aiLearnNotes/blob/master/computer_vision/activation.py" target="_blank" rel="noopener">aiLearnNotes</a></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>激活函数不仅对于卷积神经网络非常重要，在传统机器学习中也具备着举足轻重的地位，是卷积神经网络模型中必不可少的一个单元，要理解激活函数，需要从2个方面进行讨论：</p><ul><li>什么是激活函数？</li><li>为什么需要激活函数？<a id="more"></a></li></ul><p><strong>什么是激活函数？</strong></p><p>对于神经网络，一层的输入通过加权求和之后输入到一个函数，被这个函数作用之后它的非线性性增强，这个作用的函数即是激活函数。</p><p><strong>为什么需要激活函数？</strong></p><p>试想一下，对于神经网络而言，如果没有激活函数，每一层对输入进行加权求和后输入到下一层，直到从第一层输入到最后一层一直采用的就是线性组合的方式，根据线性代数的知识可以得知，第一层的输入和最后一层的输出也是呈线性关系的，换句话说，这样的话无论中加了多少层都没有任何价值，这是第一点。</p><p>第二点是由于如果没有激活函数，输入和输出是呈线性关系的，但是现实中很多模型都是非线性的，通过引入激活函数可以增加模型的非线性，使得它更好的拟合非线性空间。</p><p>目前激活函数有很多，例如阶跃函数、逻辑函数、双曲正切函数、ReLU函数、Leaky ReLU函数、高斯函数、softmax函数等，虽然函数有很多，但是比较常用的主要就是逻辑函数和ReLU函数，在大多数卷积神经网络模型中都是采用这两种，当然也有部分会采用Leaky ReLU函数和双曲正切函数，本文就介绍一下这4个激活函数长什么样？有什么优缺点？在tensorflow中怎么使用？</p><h2 id="Sigmoid"><a href="#Sigmoid" class="headerlink" title="Sigmoid"></a>Sigmoid</h2><p>Sigmoid函数的方程式为：</p><script type="math/tex; mode=display">f(x)=\sigma(x)=\frac{1}{1+e^{-x}}</script><p><img src="https://s2.ax1x.com/2019/08/21/maP6SO.png" alt="maP6SO.png"></p><p>绘图程序：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sigmoid</span><span class="params">()</span>:</span></span><br><span class="line">    x = np.arange(<span class="number">-10</span>, <span class="number">10</span>, <span class="number">0.1</span>)</span><br><span class="line">    y = <span class="number">1</span> / (<span class="number">1</span>+np.exp(-x))</span><br><span class="line">    plt.plot(x, y)</span><br><span class="line">    plt.grid()</span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure><p>Sigmoid函数就是前面所讲的逻辑函数，它的主要优点如下：</p><ul><li>能够将函数压缩至区间[0, 1]之间，保证数据稳定，波动幅度小</li><li>容易求导</li></ul><p>缺点：</p><ul><li>函数在两端的饱和区梯度趋近于0，当反向传播时容易出现梯度消失或梯度爆炸</li><li>输出不是0均值(zero-centered)，这样会导致，如果输入为正，那么导数总为正，反向传播总往正方向更新，如果输入为负，那么导数总为负，反向传播总往负方向更新，收敛速度缓慢</li><li>对于幂运算和规模较大的网络运算量较大</li></ul><h1 id="双曲正切函数"><a href="#双曲正切函数" class="headerlink" title="双曲正切函数"></a>双曲正切函数</h1><p>双曲正切函数方程式：</p><script type="math/tex; mode=display">f(x)=\tanh (x)=\frac{\left(e^{x}-e^{-x}\right)}{\left(e^{x}+e^{-x}\right)}</script><p><img src="https://s2.ax1x.com/2019/08/21/maPrY6.png" alt="maPrY6.png"></p><p>绘图程序：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tanh</span><span class="params">()</span>:</span></span><br><span class="line">    x = np.arange(<span class="number">-10</span>, <span class="number">10</span>, <span class="number">0.1</span>)</span><br><span class="line">    y = (np.exp(x) - np.exp(-x)) / (np.exp(x) + np.exp(-x))</span><br><span class="line">    plt.plot(x, y)</span><br><span class="line">    plt.grid()</span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure><p>可以看出，从图形上看双曲正切和Sigmoid函数非常类似，但是从纵坐标可以看出，Sigmoid被压缩在[0, 1]之间，而双曲正切函数在[-1, 1]之间，两者的不同之处在于，Sigmoid是非0均值(zero-centered)，而双曲是0均值的，它的相对于Sigmoid的优点就很明显了：</p><ul><li>提高了训练效率</li></ul><p>虽然双曲正切函数解决了Sigmoid函数非0均值的问题，但是它依然没有解决Sigmoid的两位两个问题，这也是tanh的缺点：</p><ul><li>梯度消失和梯度爆炸</li><li>对于幂运算和规模较大的网络运算量较大</li></ul><h1 id="ReLU"><a href="#ReLU" class="headerlink" title="ReLU"></a>ReLU</h1><p>ReLU函数方程式：</p><script type="math/tex; mode=display">f(x)=\left\{\begin{array}{ll}{0} & {\text { for } x<0} \\ {x} & {\text { for } x \geq 0}\end{array}\right.</script><p><img src="https://s2.ax1x.com/2019/08/21/maPDFx.png" alt="maPDFx.png"></p><p>绘图程序：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">relu</span><span class="params">()</span>:</span></span><br><span class="line">    x = np.arange(<span class="number">-10</span>, <span class="number">10</span>, <span class="number">0.1</span>)</span><br><span class="line">    y = np.where(x&lt;<span class="number">0</span>, <span class="number">0</span>, x)</span><br><span class="line">    plt.plot(x, y)</span><br><span class="line">    plt.grid()</span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure><p>线性整流函数(Rectified Linear Unit，ReLU)，对比于Sigmoid函数和双曲正切函数的优点如下：</p><ul><li>梯度不饱和，收敛速度快</li><li>减轻反向传播时梯度弥散的问题</li><li>由于不需要进行指数运算，因此运算速度快、复杂度低</li></ul><p>虽然解决了Sigmoid和双曲正切函数的缺点，但是它也有明显的不足：</p><ul><li>输出不是0均值(zero-centered)</li><li>对参数初始化和学习率非常敏感，设置不当容易造成神经元坏死现象，也就是有些神经元永远不会被激活(由于负部梯度永远为0造成)</li></ul><h1 id="Leaky-ReLU"><a href="#Leaky-ReLU" class="headerlink" title="Leaky ReLU"></a>Leaky ReLU</h1><p>Leaky ReLU函数方程式：</p><script type="math/tex; mode=display">f(x)=\left\{\begin{array}{ll}{0.01 x} & {\text { for } x<0} \\ {x} & {\text { for } x \geq 0}\end{array}\right.</script><p><img src="https://s2.ax1x.com/2019/08/21/maPsfK.png" alt="maPsfK.png"></p><p>绘图程序：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leaky_relu</span><span class="params">()</span>:</span></span><br><span class="line">    x = np.arange(<span class="number">-2</span>, <span class="number">2</span>, <span class="number">0.1</span>)</span><br><span class="line">    y = np.where(x&lt;<span class="number">0</span>, <span class="number">0.01</span>*x, x)</span><br><span class="line">    plt.plot(x, y)</span><br><span class="line">    plt.grid()</span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure><p>为了解决ReLU函数神经元坏死现象，Leaky ReLU函数在输入为负是引入了一个(0, 1)之间的常数，使得输入为负时梯度不为0。虽然Leaky ReLU解决了ReLU的这个严重问题，但是它并不总是比ReLU函数效果好，在很多情况下ReLU函数的效果还是更胜一筹。</p><h1 id="tensorflow激活函数使用"><a href="#tensorflow激活函数使用" class="headerlink" title="tensorflow激活函数使用"></a>tensorflow激活函数使用</h1><p>tensorflow中激活函数在tf.nn模块下，例如，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tf.nn.relu</span><br><span class="line">tf.nn.sigmoid</span><br><span class="line">tf.nn.tanh</span><br><span class="line">tf.nn.leaky_relu</span><br></pre></td></tr></table></figure><p>其中relu、sigmoid、tanh函数的参数完全相同，leaky_relu多一个输入参数，就是斜率，默认值为0.2，以relu函数为例介绍一下tensorflow中激活函数的使用，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">features = tf.nn.max_poo()</span><br><span class="line">tf.nn.relu(features, name=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure><p>tensorflow中激活函数输入有两个参数：</p><ul><li>features：输入的特征张量，也就是前一层池化层或者卷积层输出的结果，数据类型限制在float32, float64, int32, uint8, int16, int8, int64, float16, uint16, uint32, uint64</li><li>name：运算的名称，这个可以自行命名</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;完整代码&lt;/strong&gt;链接：&lt;a href=&quot;https://github.com/Jackpopc/aiLearnNotes/blob/master/computer_vision/activation.py&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;aiLearnNotes&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;激活函数不仅对于卷积神经网络非常重要，在传统机器学习中也具备着举足轻重的地位，是卷积神经网络模型中必不可少的一个单元，要理解激活函数，需要从2个方面进行讨论：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;什么是激活函数？&lt;/li&gt;
&lt;li&gt;为什么需要激活函数？
    
    </summary>
    
      <category term="计算机视觉" scheme="https://jackpopc.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
    
      <category term="CV" scheme="https://jackpopc.github.io/tags/CV/"/>
    
      <category term="AI" scheme="https://jackpopc.github.io/tags/AI/"/>
    
      <category term="图像处理" scheme="https://jackpopc.github.io/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>【进阶Python】第三讲：类的特殊方法(上篇)</title>
    <link href="https://jackpopc.github.io/2019/08/18/python-3/"/>
    <id>https://jackpopc.github.io/2019/08/18/python-3/</id>
    <published>2019-08-18T03:19:45.000Z</published>
    <updated>2019-08-28T14:11:37.144Z</updated>
    
    <content type="html"><![CDATA[<p><strong>完整代码</strong>请查看github项目: <a href="https://github.com/Jackpopc/advance-python/blob/master/2-magic-method_1.ipynb" target="_blank" rel="noopener">advance-python</a></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Python是一种面向对象的语言，而特殊方法又是Python类中一个重点，因此学习Python类的特殊方法能够有助于设计出更加简洁、规范的代码架构。</p><a id="more"></a>Python类的特殊方法又称为<b>魔术方法</b>，它是以<b>双下划线包裹</b>一个词的形式出现，例如__init__。特殊方法不仅可以可以实现构造和初始化，而且可以实现比较、算数运算，此外，它还可以让类像一个字典、迭代器一样使用，可以设计出一些高级的代码，例如<b>单例模式</b>。<br><b>面向对象</b>这个词大家应该都不陌生，在C++、Java等面向对象的语言中也经常出现，要想理解面向对象，首先要理解4个概念之间的关系：类、对象、实例、方法。<br><b>类</b>：类是一种由不同属性、不同数据组成的一个集合。用直白的话来描述，它是由多种对象组成的一个组合，例如人是一个类，那么它包含男人、女人、儿童等对象。例如三角形是一个类，那么它包含等腰三角形、直角三角形、等边三角形等对象。<br><b>对象</b>：前面介绍类中已经提到了对象这个词汇，一句话总结：对象具有<b>具体</b>状态和行为。例如直角三角形，它具有特定的状态和属性。<br><b>实例</b>：对象就是类的一个实例。也许这有点绕，的确对象与实例之间的概念非常模糊。你可以理解为对象是一个概念性的存在，而实例是采取行为、动作的载体，以一段代码举例，<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">animal = Animal()</span><br></pre></td></tr></table></figure><p>其中<strong>Animal</strong>是一个类，而<strong>animal</strong>是一个实例，它可以访问类内的方法，实施“动作”和“行为”。</p><p><strong>方法</strong>：定义在类外部的函数叫做函数，定义在类内部的函数称为方法。</p><p>这些概念在Python面向对象编程中非常概念，只有理解这些概念才能在后续学习中更加容易理解，对上述这些概念有一个简单的了解，在后续的讲解中会更加轻松。</p><h1 id="new-与-init"><a href="#new-与-init" class="headerlink" title="__new__与__init__"></a>__new__与__init__</h1><p>之所以把这个放在第一个，因为这个不仅非常常用，而且很容易被误解，甚至很多知名的书籍中都把这个特殊方法弄错。</p><p>很多博客和个别书籍中都把__init__当作类似于C++的<strong>构造方法</strong>，其实这个理解是错误的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, *args, **kargs)</span>:</span></span><br><span class="line">        instance = object.__new__(cls, *args, **kargs)</span><br><span class="line">        print(<span class="string">"&#123;&#125; in new method."</span>.format(instance))</span><br><span class="line"><span class="comment">#         return instance             # 不返回实例</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"&#123;&#125; in init method."</span>.format(self))</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">animal = Animal()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">&lt;__main__.Animal object at <span class="number">0x000002BB03001CF8</span>&gt; <span class="keyword">in</span> new method.</span><br></pre></td></tr></table></figure><p>以上面为例，我们对基类中的__new__进行重构，不让它返回实例，可以从输出结果可以看出，程序没有进入__init__方法。这是因为__new__是用来构造实例的，而__init__只是用来对返回的实例进行一些属性的初始化，我们在写一个类的时候首先都会写一个__init__方法去初始化变量，却很少使用__new__，因此就容易忽略__new__，其实在我们继承基类object(例如，class Animal(object))时同时就从基类中继承了__new__方法，所以就不需要重新在子类中实现，如果把上述注释取消掉，再看一下，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, *args, **kargs)</span>:</span></span><br><span class="line">        instance = object.__new__(cls, *args, **kargs)</span><br><span class="line">        print(<span class="string">"&#123;&#125; in new method."</span>.format(instance))</span><br><span class="line">        <span class="keyword">return</span> instance</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"&#123;&#125; in init method."</span>.format(self))</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">animal = Animal()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">&lt;__main__.Animal object at <span class="number">0x000002BB03001B00</span>&gt; <span class="keyword">in</span> new method.</span><br><span class="line">&lt;__main__.Animal object at <span class="number">0x000002BB03001B00</span>&gt; <span class="keyword">in</span> init method.</span><br></pre></td></tr></table></figure><p>可以看出，程序先运行到new中，然后进入init方法。</p><p>对于__init__应该都很熟悉，为什么很少使用__new__呢？因为大多数情况下我们是用不到它的。但是存在的即是合理的，它自然有自己的价值。</p><p><strong>__new__在哪些场景能够用到呢？</strong></p><p>当实现一些高级的软件设计模式可能会用到__new__方法，它主要有以下几点用处，</p><ul><li>重构一些不可变方法，例如，int, str, tuple</li><li>实现单例模式(Singleton Pattern)</li></ul><p>这里着重介绍一下单例模式。</p><p><strong>单例模式</strong>是一种常用的软件设计模式，有时候我们需要严格的限制一个类只有一个实例存在，一个系统只有一个全局对象，这样有利于协调系统的整体行为。</p><p>先看一下我们常用的写法，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NewInt</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">new1 = NewInt()</span><br><span class="line">new2 = NewInt()</span><br><span class="line">print(new1)</span><br><span class="line">print(new2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">&lt;__main__.NewInt object at <span class="number">0x000002BB03001390</span>&gt;</span><br><span class="line">&lt;__main__.NewInt object at <span class="number">0x000002BB02FF4080</span>&gt;</span><br></pre></td></tr></table></figure><p>从输出可以看出，上述两个实例new1、new2地址不同，是两个实例。</p><p>然后通过__new__实现单例模式，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NewInt</span><span class="params">(object)</span>:</span></span><br><span class="line">    _singleton = <span class="literal">None</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, *args, **kwargs)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> cls._singleton:</span><br><span class="line">            cls._singleton = object.__new__(cls, *args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> cls._singleton</span><br><span class="line"></span><br><span class="line">new1 = NewInt()</span><br><span class="line">new2 = NewInt()</span><br><span class="line">print(new1)</span><br><span class="line">print(new2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line"></span><br><span class="line">&lt;__main__.NewInt object at <span class="number">0x000002BB02FF6080</span>&gt;</span><br><span class="line">&lt;__main__.NewInt object at <span class="number">0x000002BB02FF6080</span>&gt;</span><br></pre></td></tr></table></figure><p>地址相同，指向同一个对象，所以每次实例化产生的实例都是完全相同的。</p><h1 id="enter-与-exit"><a href="#enter-与-exit" class="headerlink" title="__enter__与__exit__"></a>__enter__与__exit__</h1><p>在介绍这两个特殊方法之前我们首先讲一下<strong>with</strong>语句。</p><p>with语句主要用于对资源进行访问的场景，例如读取文件。以读取文件为例，我们可以使用open、close的方法，但是使用with语句有着无法比拟的优势。</p><p>首先就是简洁，你不需要再写file.close的语句去关闭文件。</p><p>其次，也是最重要的，它能够很好的做到异常处理，当处理过程中发生异常，它能够自动关闭、自动释放资源。</p><p>以读取文件来对比一下两个功能，</p><p>如果使用open、close方式需要打开、读取、关闭3个过程，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># file.txt</span></span><br><span class="line"></span><br><span class="line">fp = open(<span class="string">"file.txt"</span>, <span class="string">"rb"</span>)</span><br><span class="line">fp.readline()</span><br><span class="line">fp.close()</span><br></pre></td></tr></table></figure><p>而使用with语句只需要打开、读取两个过程，当执行完毕会自动关闭，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">"file.txt"</span>, <span class="string">"rb"</span>) <span class="keyword">as</span> fp:</span><br><span class="line">    fp.readline()</span><br></pre></td></tr></table></figure><p>说了这么多with语句的好处，这和__enter__与__exit__有什么关系？</p><p>__enter__与__exit__就是实现with的类特殊方法。</p><p>以一段代码来解释这两个特殊方法的使用，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileReader</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"in init method"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__enter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"int enter method"</span>)</span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__exit__</span><span class="params">(self, exc_type, exc_val, exc_tb)</span>:</span></span><br><span class="line">        print(<span class="string">"in exit method"</span>)</span><br><span class="line">        <span class="keyword">del</span> self</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">read</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"in read"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># with语句调用</span></span><br><span class="line"><span class="keyword">with</span> FileReader() <span class="keyword">as</span> fr:</span><br><span class="line">    fr.read()</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line"><span class="keyword">in</span> init method</span><br><span class="line">int enter method</span><br><span class="line"><span class="keyword">in</span> read</span><br><span class="line"><span class="keyword">in</span> exit method</span><br></pre></td></tr></table></figure><p>从上面输出可以看出，程序先进去init方法进行初始化，然后进入enter特殊方法，然后通过fr.read调用read()方法，最后退出时调用exit方法。</p><p>这就是enter与exit的调用过程，</p><ul><li>__enter__：初始化后返回实例</li><li>__exit__：退出时做处理，例如清理内存，关闭文件，删除冗余等</li></ul><h1 id="str-与-repr"><a href="#str-与-repr" class="headerlink" title="__str__与__repr__"></a>__str__与__repr__</h1><p>一句话描述这两个特殊方法的功能：<strong>把类的实例变为字符串</strong>。</p><p>我们都知道，我们可以用这种方法输出一个字符串，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">"Hello world!"</span>)</span><br></pre></td></tr></table></figure><p>那我们怎么能够像字符串一样把实例输出出来？</p><p>可以通过__str__与__repr__来实现，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"str: &#123;&#125; now year is &#123;&#125; years old."</span>.format(self.name, self.age)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"repr: &#123;&#125; now year is &#123;&#125; years old."</span>.format(self.name, self.age)</span><br><span class="line"></span><br><span class="line">person = Person(<span class="string">"Li"</span>, <span class="number">27</span>)</span><br><span class="line">print(person)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">str: Li now year <span class="keyword">is</span> <span class="number">27</span> years old.</span><br></pre></td></tr></table></figure><p>可以看出，当使用print语句打印实例person时，能够像输出字符串那样把实例信息输出出来。</p><p>但是可以看出，程序进入__str__方法，并没有进入__repr__，这就引出了这两个方法的不同之处，</p><ul><li>__str__：用于用户调用</li><li>__repr__：用于开发人员调用</li></ul><p>这似乎不太好理解，因为对于写程序的我们无法理解，何为用户？何为开发人员？</p><p>简单的来说，__str__是用些Python脚本(.py)时使用，用print语句输出字符串信息。__repr__是我们在交互式环境下测试使用，例如cmd下的Python、ipython，例如在交互式环境下调用，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>person = Person(<span class="string">"li"</span>, <span class="number">27</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>person</span><br><span class="line">repr: li now year <span class="keyword">is</span> <span class="number">27</span> years old.</span><br></pre></td></tr></table></figure><p>更为简单的理解就是：__str__需要用print语句打印，__repr__只需输入实例名称即可。</p><h1 id="setattr-、-getattr-、-getattribute-与-delattr"><a href="#setattr-、-getattr-、-getattribute-与-delattr" class="headerlink" title="__setattr__、__getattr__、__getattribute__与__delattr__"></a>__setattr__、__getattr__、__getattribute__与__delattr__</h1><p>了解上述这4个方法之前，我们先来解释一下<strong>什么是属性？</strong></p><p>也许很多同学已经清楚，但是我觉得还是有必要介绍一下，因为这是要讲的这3个特殊方法的关键。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age, home, work)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">        self.home = home</span><br><span class="line">        self.work = work</span><br><span class="line"></span><br><span class="line">person = Person(<span class="string">"Li"</span>, <span class="number">27</span>, <span class="string">"China"</span>, <span class="string">"Python"</span>)</span><br><span class="line">print(person.name)</span><br><span class="line">print(person.age)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">Li</span><br><span class="line"><span class="number">27</span></span><br></pre></td></tr></table></figure><p>例如上面我们定义一个Person类，name、age、home、work就是它的属性，当实例化之后我们可以通过<strong>点.</strong>来访问它的属性。</p><p>我可以可以通过传入参数，赋值给self来定义类的属性，但是这样未免太固定了，当实例化之后就不能更改它的属性了，如果我们想获取、添加、删除属性怎么办？这就用到这里要讲的4个特殊方法，__setattr__、__getattr__、__getattribute__与__delattr__，它们的功能分别是，</p><ul><li>__setattr__：设置属性</li><li>__getattr__：访问不存的属性时调用，可能会有同学有疑问，访问不存的属性要它干吗？可以用来做异常处理！</li><li>__getattribute__：访问存在的属性，如果访问属性不存在的时候随后会调用__getattr__</li><li>__delattr__：删除属性</li></ul><p>以一个例子来说明一下，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__setattr__</span><span class="params">(self, key, value)</span>:</span></span><br><span class="line">        object.__setattr__(self, key, value)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattribute__</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        print(<span class="string">"in getattribute"</span>)</span><br><span class="line">        <span class="keyword">return</span> object.__getattribute__(self, item)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            print(<span class="string">"in getattr"</span>)</span><br><span class="line">            <span class="keyword">return</span> object.__getattribute__(self, item)</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Not find attribute: &#123;&#125;"</span>.format(item)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__delattr__</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        object.__delattr__(item)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">person = Person(<span class="string">"Li"</span>)</span><br><span class="line">print(person.name)</span><br><span class="line">print(person.age)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line"><span class="keyword">in</span> getattribute</span><br><span class="line">Li</span><br><span class="line"><span class="keyword">in</span> getattribute</span><br><span class="line"><span class="keyword">in</span> getattr</span><br><span class="line">Not find attribute: age</span><br></pre></td></tr></table></figure><p>从上面输出来看一下就可以明白，当获取属性name时，由于已经有了，则进入__getattribute__中，获取对应的属性，当获取属性age时，由于没有这个属性，则先进入__getattribute__，然后进入__getattr__，没有找到属性返回异常信息。</p><p>然后再来看一下看一下设置属性和删除属性，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">person.age = <span class="number">27</span></span><br><span class="line">print(person.age)</span><br><span class="line">delattr(person, <span class="string">"age"</span>)</span><br><span class="line">print(person.age)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line"><span class="keyword">in</span> getattribute</span><br><span class="line"><span class="number">27</span></span><br><span class="line"><span class="keyword">in</span> delattr</span><br><span class="line"><span class="keyword">in</span> getattribute</span><br><span class="line"><span class="keyword">in</span> getattr</span><br><span class="line">Not find attribute: age</span><br></pre></td></tr></table></figure><p>从输出结果可以看出，通过<em>instance.attribute</em>的方式可以设置属性，通过delattr可以删除属性。</p><h1 id="文档获取"><a href="#文档获取" class="headerlink" title="文档获取"></a>文档获取</h1><p>本讲的Markdown格式文档我进行共享了，需要的可以关注公众号【平凡而诗意】回复关键字”<font color="red"><b>python</b></font>“获取。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;完整代码&lt;/strong&gt;请查看github项目: &lt;a href=&quot;https://github.com/Jackpopc/advance-python/blob/master/2-magic-method_1.ipynb&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;advance-python&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;Python是一种面向对象的语言，而特殊方法又是Python类中一个重点，因此学习Python类的特殊方法能够有助于设计出更加简洁、规范的代码架构。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="https://jackpopc.github.io/categories/Python/"/>
    
    
      <category term="编程" scheme="https://jackpopc.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Python" scheme="https://jackpopc.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>【动手学计算机视觉】第十一讲：卷积层、池化层与填充</title>
    <link href="https://jackpopc.github.io/2019/08/16/cv-cnn-pool/"/>
    <id>https://jackpopc.github.io/2019/08/16/cv-cnn-pool/</id>
    <published>2019-08-16T12:40:12.000Z</published>
    <updated>2019-08-17T11:03:37.063Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>从2012年AlexNet成名之后，CNN如同雨后春笋一样，出现了各种各样的Net，其中也有很多知名的，例如VGG、GoogleNet、Faster R-CNN等，每个算法都在前面研究工作的基础上做出了很大的改进，但是这些CNN模型中主要使用的组件却有很多重叠之处，这个组件主要有<a id="more"></a>：</p><ul><li>卷积层</li><li>池化层</li><li>激活函数</li><li>优化函数</li><li>全连接层</li><li>Dropout</li><li>批量正则化</li><li>填充padding</li><li>……</li></ul><p>其实一个CNN网络的模型搭建过程非常容易，现在有很多优秀的机器学习框架，例如tensorflow、pytorch、mxnet、caffe、keras等，借助这些机器学习框架搭建一个CNN网络模型只需要几十行代码即可完成，而且使用到的函数屈指可数，难度并不大。而上述提到的这些组件却是CNN中非常核心的概念，了解它们是什么？有什么价值？在哪里起作用？掌握这些之后再回头看这些CNN模型就会发现轻而易举，因此，这几节会先把上述这些技术介绍一下，然后逐个讲解如何一步一步搭建那些成熟优秀的CNN模型。</p><p>由于上述每个技术都涉及很多知识点，本文为了效率就用简单的语言介绍它是什么？有什么价值？具体详细的内容可以阅读文章或者外网资料详细了解，本文主要介绍3点：</p><ul><li>卷积层</li><li>池化层</li><li>填充padding</li></ul><h1 id="卷积层"><a href="#卷积层" class="headerlink" title="卷积层"></a>卷积层</h1><p><strong>介绍</strong></p><p>卷积神经网络(convolutional neural network)，从它的名称就可以看出，卷积是其中最为关键的部分。在前面讲解图像去噪和图像分割中提到了一些用于分割和去噪的算法，例如sobel算子、中值滤波，其实卷积的概念和这些有相同之处。</p><p>把输入图像看作是一个n维矩阵，然后拿一个m<em>m维(m&lt;n)的卷积核(或者称为滤波器)，从图像的左上角开始沿着<strong>从左至右</strong>、<em>*从上之下</em></em>进行”扫描”，每当移动到一个窗口后和对应的窗口做卷积运算(严格的说是互相关运算)，用直白的话来说就是对应元素相乘之后加和。</p><p>移动过程中涉及一个重要的概念—<strong>步长(stride)</strong>，它的意思就是”扫描”过程中每次移动几个像素，如果步长<strong>stride=1</strong>，那么<strong>从左至右</strong>、<strong>从上之下</strong>逐个像素的移动。</p><p><img src="https://s2.ax1x.com/2019/08/17/muhjFx.png" alt="muhjFx.png"></p><p>以上图二维卷积运算为例，输入图像为一个5*5的矩阵，卷积核为3*3，以步长<strong>stride=1</strong>进行卷积运算，在左上角这个窗口每个对应元素<strong>先相乘再加和</strong>，即，</p><script type="math/tex; mode=display">0*0+1*1+2*2+1*5+2*6+0*7+2*0+1*1+0*2=23</script><p>以这种方式逐个窗口进行计算，就得到图中等号右边的输出结果。</p><p><strong>tensorflow使用</strong></p><p>在tensorflow中关于卷积层的函数为，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tensorflow.nn. conv2d(input, filter, strides, padding)</span><br></pre></td></tr></table></figure><p>其中参数分别为：</p><ul><li>input：输入数据或者上一层网络输出的结果</li><li>filter：卷积核，它的是一个1*4维的参数，例如<strong>filter=[5, 5, 3, 96]</strong>，这4个数字的概念分别是<strong>卷积核高度</strong>、<strong>卷积核宽度</strong>、<strong>输入数据通道数</strong>、<strong>输出数据通道数</strong></li><li>strides：这是前面所讲的步伐，同卷积核一样，它也是一个1*4维的参数，例如<strong>strides=[1, 2, 2, 1]</strong>，这4个数字分别是<strong>batch</strong>方向移动的步长、<strong>水平方向</strong>移动的步长、<strong>垂直方向</strong>移动的步长、<strong>通道方向</strong>移动的步长，由于在运算过程中是不跳过batch和通道的，所以通常情况下第1个和第4个数字都是1</li><li>padding：是填充方式，主要有两种方式，<strong>SAME</strong>, <strong>VALID</strong>，后面会讲什么是填充</li></ul><h1 id="池化层"><a href="#池化层" class="headerlink" title="池化层"></a>池化层</h1><p><strong>介绍</strong></p><p>池化层和卷积层一样，是CNN模型必不可少的一个部分，在很多卷积层后会紧跟一个池化层，而且在统计卷积神经网络时，池化层是不单独称为网络层的，它与卷积层、激活函数、正则化同时使用时共同称为1个卷积层。</p><p>池化层又成为<strong>下采样</strong>或者<strong>欠采样</strong>，它的主要功能是对于特征进行降维，压缩数据和参数量，避免过拟合，常用的池化方式有两种：</p><ul><li>最大池化</li><li>平均池化</li></ul><p>以最大池化为例介绍一下它是怎么实现的，</p><p><img src="https://s2.ax1x.com/2019/08/17/muhvY6.png" alt="muhvY6.png"></p><p>和卷积层类似，池化层也有<strong>窗口</strong>和<strong>步长</strong>的概念，其中<strong>步长</strong>在里面的作用也是完全相同的，就是窗口每次移动的像素个数，所以不再赘述。</p><p>池化层的窗口概念和卷积层中是截然不同的，在卷积层中每移动到一个窗口，对应的卷积核和输入图像做卷积运算。而在池化层中，窗口每移动到一个位置，就选择出这个窗口中的最大值输出，如果是平均池化就输出这个窗口内的平均值。</p><p><strong>tensorflow使用</strong></p><p>tensorflow中池化运算的函数为，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tensorflow.nn.max_pool(value, ksize, strides, padding)</span><br></pre></td></tr></table></figure><p>从函数的参数即可看出来，它和卷积层非常相似，它的参数概念分别是，</p><ul><li>value：输入数据或者上一层网络输出的结果</li><li>ksize：卷积核，它的是一个1*4维的参数，例如<strong>ksize=[1, 3, 3, 1]</strong>，这4个数字的概念分别是<strong>batch</strong>维度池化窗口、<strong>池化窗口高度</strong>、<strong>池化窗口宽度</strong>、<strong>通道</strong>维度窗口尺寸，由于在batch和通道维度不进行池化，所以通常情况下第1和第4个元素为1</li><li>strides：这和卷积层中相同</li><li>padding：这和卷积层中的也相同</li></ul><h1 id="填充"><a href="#填充" class="headerlink" title="填充"></a>填充</h1><p>在前面讲解卷积层和池化层时都提到了一个概念—填充，可见它是非常重要的。什么是填充？<strong>SAME</strong>, <strong>VALID</strong>这两种填充方式又有什么区别？下面来介绍一下。</p><p>从前面卷积层和池化层可以看出，卷积层和池化层的输出<strong>尺寸大小</strong>和选取的窗口大小有着密切关系，以卷积层为例，上述输入为5*5，但是输出为3*3，输出尺寸变小了，而且在输入图像的四周的元素只被卷积了一次，中间的元素却被<strong>利用</strong>多次，也就是说，如果是一副图像，图像四周的信息未被充分提取，这就体现了填充的价值，</p><ul><li>保持边界信息</li><li>使得输入输出图像尺寸一致</li></ul><p>那怎么样达到上述这2个目的？就是通过填充，一般情况下是在图像周围填充0，如下，</p><p><img src="https://s2.ax1x.com/2019/08/17/muhOT1.png" alt="muhOT1.png"></p><p>如上图所示，在输入图像周围填充0，然后通过卷积运算，输入和输出的尺寸都为5*5。当然，这是针对卷积核为3*3情况下，外层填充1层，具体填充几层，要根据卷积核大小而定。</p><p>然后回到前面所提到的，tensorflow中填充padding参数有两个选项：<strong>SAME</strong>, <strong>VALID</strong>，它们有什么区别呢 ？</p><p><strong>VALID</strong>：不进行填充</p><p><strong>SAME</strong>：填充0，使得输出和输入的尺寸相同，就如同上面这个例子。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;从2012年AlexNet成名之后，CNN如同雨后春笋一样，出现了各种各样的Net，其中也有很多知名的，例如VGG、GoogleNet、Faster R-CNN等，每个算法都在前面研究工作的基础上做出了很大的改进，但是这些CNN模型中主要使用的组件却有很多重叠之处，这个组件主要有
    
    </summary>
    
      <category term="计算机视觉" scheme="https://jackpopc.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
    
      <category term="CV" scheme="https://jackpopc.github.io/tags/CV/"/>
    
      <category term="AI" scheme="https://jackpopc.github.io/tags/AI/"/>
    
      <category term="图像处理" scheme="https://jackpopc.github.io/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>效率工具 | 推荐一款提高Python编程效率的神器</title>
    <link href="https://jackpopc.github.io/2019/08/13/kite/"/>
    <id>https://jackpopc.github.io/2019/08/13/kite/</id>
    <published>2019-08-13T13:25:30.000Z</published>
    <updated>2019-09-01T10:04:09.782Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>“AI自动补全工具”，这个其实很久之前就有所耳闻，但是我却始终没有去尝试，因为，在我看来这两年人工智能泡沫太严重，各行各业都在蹭AI的热度，我想，也许”AI自动补全工具”也只不过是一个噱头吧。</p><p>在工作中，对于Python开发我一直都是以pycharm为主力<a id="more"></a>。它也是Python开发中非常知名的一款IDE，支持DEBUG、格式提示、快速补全等等，有着非常吸引人的优点。尽管它非常臃肿、启动速度非常缓慢，但是对于追求补全速度的我来说，我还是选择忍受它的种种不足。</p><p>直到前不久在开发过程中发生的几次问题让我忍无可忍，我决心换掉这款工具，主要有如下几个原因：</p><ul><li>内存占用大：16G的内存，pycharm占据了1G以上，使得电脑卡顿</li><li>license服务器崩溃：购买的license总是莫名其妙的出问题</li><li>臃肿：pycharm很强大，但是它的强大是建立在开启了很多辅助工具的基础上，这使得它非常臃肿卡顿</li></ul><p>于是，我开始尝试不同的工具，VIM、vscode、sublime等。其中VIM在补全速度方面还可以，但是在windows下无法使用，而我有时在服务器下开发、有时会在windows下开发。至于vscode和sublime，界面和启动速度等都没的说，但是补全功能太弱，虽然配置了几款所谓的强大插件，但是依然跟不上编码的速度，于是，我又回到了pycharm，直到我遇到这款神奇的工具—<strong>kite</strong>，让我有一种<strong>柳暗花明</strong>的感觉，实在太强大了。</p><p>甚至Python之父Guido van Rossum都说<em>I really love the line-of-code completions in the new kite.com</em>，可见这款工具多么强大。</p><p>有了这一款工具，再也不用繁琐的配置sublime、vscode中各种插件和设置项了。</p><h1 id="kite"><a href="#kite" class="headerlink" title="kite"></a>kite</h1><p><strong>安装</strong></p><p>kite是一款<strong>安装包</strong>+<strong>插件</strong>的工具，首先需要到官网下载kite的安装包，安装作为引擎，安装之后打开相应的编辑器或IDE安装kite的插件，然后就可以使用了，不用像sublime、vscode那样需要安装一堆插件还要到设置中配置Python路径之类的。</p><p>安装包下载可以直接到官网进行下载：</p><p><a href="https://www.kite.com/download/" target="_blank" rel="noopener">https://www.kite.com/download/</a></p><p>我把安装包进行共享了，如果访问官网速度比较慢，无法下载的话，可以在公众号后台回复<font color="red">kite</font>获取。</p><p><strong><em>双击安装</em></strong></p><p><img src="https://s2.ax1x.com/2019/08/17/mu4n1S.png" alt="mu4n1S.png"></p><p><strong>为什么推荐这款工具？</strong></p><p>一款好的编程工具能够让编码效率事半功倍，它不仅避免我们逐个敲击代码，还避免我们去记忆一些函数的名称。目前有很多有名气的IDE\编辑器，pycharm、eclipse、spyder、Atom、sublime、vscode等，每个人都有自己的习惯和偏好，所以每个人心中都有自己最认可的工具。但是不可否认，pycharm在Python开发方面是使用最为广泛的一款，它最吸引我的一点就是补全速度。虽然sublime、vscode等也可以通过配置插件来实现Python自动补全，但是速度和效果等方面始终和pycharm有着巨大差距。</p><p>所以长久以来，尽管我也体会到它的种种缺点，我还是在坚持使用pycharm，直到最近我遇到这款kite之后。它是一款基于人工智能的代码补全和文档查询工具。我觉得完全可以脱离臃肿的pycharm，利用sublime、vscode这些轻量的编辑器与kite结合使用，即可以避免缓慢的开启速度，还可以实现不亚于pycharm的补全速度。</p><p>当然，kite的功能不仅限于补全，它主要包括：</p><ul><li>代码自动补全</li><li>文档查询</li></ul><p><strong>代码自动补全</strong></p><p><img src="https://s2.ax1x.com/2019/08/17/mu4Qmj.gif" alt="mu4Qmj.gif"></p><p>直接来看一下它的补全速度，非常快。</p><p>目前的代码自动补全工具大多数都是通过上下文匹配、扫描第三方库的方式实现补全，这样都是通过你输入一个单词，它去扫描，可想而知，速度自然会很慢。但是kite则不同，它是通过人工智能的方式进行补全，当你属于一个单词，它能够像谷歌搜索那样，预测你接下来会输入什么，并按相关性进行排序。</p><p>它不仅支持Python内置函数补全，还支持第三方工具包的补全。此外，它还支持一些模块的补全，例如<strong><em>if…main…</em></strong>，能够极大的节省编码的时间，提升编码效率，经过统计，Kite的人工智能可以帮助减少47%的击键次数。</p><p><strong>文档查询</strong></p><p>当我们使用一个第三方库时，例如numpy、tensorflow、scipy等，我们对其中很多函数怎么使用？需要传入哪些参数并不清楚。当然你可以上网搜索一下，但是我认为现在网上的学习资料鱼龙混杂，最好的方法还是看文档，这样比较权威、严谨。</p><p>但是问题是去哪看文档？而且，找文档也很耗时间啊。</p><p>kite不仅可以自动补全的问题，它还可以解决文档查询的问题。</p><p><img src="https://s2.ax1x.com/2019/08/17/mu48kq.png" alt="mu48kq.png"></p><p>打开kite，输入你想搜索的模块，即可找到你想要看的文档。而且它非常简洁，</p><ul><li>怎么使用</li><li>传入参数</li><li>返回值</li></ul><p>以最简单明了的几句话概括这个模块的使用方法。</p><p><strong>支持平台</strong></p><p>kite是一块完全免费的工具，它目前支持以下两个平台：</p><ul><li>windows</li><li>linux</li></ul><p><strong>支持工具</strong></p><p>kite支持以下几种IDE\编辑器：</p><ul><li>pycharm</li><li>Atom</li><li>vscode</li><li>sublime</li><li>vim</li></ul><p>因此，你有多种可选项，可以根据自己的喜好进行配置。即便你对目前所使用的编辑工具补全速度已经很满意了，我认为也不妨使用一下kite，用它作为一款文档查询工具，能够使得阅读文档效率大大提升。</p><p><strong>支持语言</strong></p><p>官方把它定义为一款Python自动补全工具，但是我在使用vscode开发javascript时发现kite同样能够实现补全，而且效果也不错，至于C++、Java等其他语言，我没有尝试，暂不清楚，感兴趣的可以试一下。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;“AI自动补全工具”，这个其实很久之前就有所耳闻，但是我却始终没有去尝试，因为，在我看来这两年人工智能泡沫太严重，各行各业都在蹭AI的热度，我想，也许”AI自动补全工具”也只不过是一个噱头吧。&lt;/p&gt;
&lt;p&gt;在工作中，对于Python开发我一直都是以pycharm为主力
    
    </summary>
    
      <category term="开发工具" scheme="https://jackpopc.github.io/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="工具" scheme="https://jackpopc.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="实用" scheme="https://jackpopc.github.io/tags/%E5%AE%9E%E7%94%A8/"/>
    
      <category term="插件" scheme="https://jackpopc.github.io/tags/%E6%8F%92%E4%BB%B6/"/>
    
      <category term="开发工具" scheme="https://jackpopc.github.io/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>【进阶Python】第二讲：装饰器</title>
    <link href="https://jackpopc.github.io/2019/08/10/1-decorators/"/>
    <id>https://jackpopc.github.io/2019/08/10/1-decorators/</id>
    <published>2019-08-10T03:21:45.000Z</published>
    <updated>2019-10-08T13:59:24.785Z</updated>
    
    <content type="html"><![CDATA[<p><strong>完整代码</strong>请查看github项目: <a href="https://github.com/Jackpopc/advance-python/blob/master/code/1-decorators.ipynb" target="_blank" rel="noopener">advance-python</a></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前段时间我发了一篇讲解Python调试工具PySnooper的文章，在那篇文章开始一部分我简单的介绍了一下装饰器，文章发出之后有几位同学说”终于了解装饰器的用法了”，可见有不少同学对装饰器感兴趣。但是那篇文章主要的目的是在介绍PySnooper，所以没有太深入的展开讲解装饰器，于是在这里就详细的介绍一些装饰器的使用。</p><a id="more"></a>装饰器是Python中非常重要的一个概念，如果你会Python的基本语法，你可以写出能够跑通的代码，但是如果你想写出高效、简洁的代码，我认为离不开这些高级用法，当然也包括本文要讲解的装饰器，就如同前面提到的代码调试神器PySnooper一样，它就是主要通过装饰器调用的方式对Python代码进行调试。<br><font color="blue"><b>什么是Python装饰器？</b></font><br>顾名思义，从字面意思就可以理解，它是用来"装饰"Python的工具，使得代码更具有Python<font color="red">简洁</font>的风格。换句话说，它是一种<font color="red">函数的函数</font>，因为装饰器传入的参数就是一个函数，然后通过实现各种功能来对这个函数的功能进行<font color="red">增强</font>。<br><font color="blue"><b>为什么用装饰器？</b></font><br>前面提到了，装饰器是通过某种方式来增强函数的功能。当然，我们可以通过很多方式来增强函数的功能，只是装饰器有一个无法替代的优势--简洁。你只需要在每个函数上方加一个<font color="red">@</font>就可以对这个函数进行增强。<br><font color="blue"><b>在哪里用装饰器？</b></font><br>装饰器最大的优势是用于<font color="red">解决重复性的操作</font>，其主要使用的场景有如下几个：- 计算函数运行时间- 给函数打日志- 类型检查当然，如果遇到其他重复操作的场景也可以类比使用装饰器。<h1>简单示例</h1>前面都是文字描述，不管说的怎么天花烂坠，可能都无法体会到它的价值，下面就以一个简单的例子来看一下它的作用。如果你要对多个函数进行<font color="red">统计运行时间</font>，不使用装饰器会是这样的，<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> time, sleep</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun_one</span><span class="params">()</span>:</span></span><br><span class="line">    start = time()</span><br><span class="line">    sleep(<span class="number">1</span>)</span><br><span class="line">    end = time()</span><br><span class="line">    cost_time = end - start</span><br><span class="line">    print(<span class="string">"func one run time &#123;&#125;"</span>.format(cost_time))</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun_two</span><span class="params">()</span>:</span></span><br><span class="line">    start = time()</span><br><span class="line">    sleep(<span class="number">1</span>)</span><br><span class="line">    end = time()</span><br><span class="line">    cost_time = end - start</span><br><span class="line">    print(<span class="string">"func two run time &#123;&#125;"</span>.format(cost_time))</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun_three</span><span class="params">()</span>:</span></span><br><span class="line">    start = time()</span><br><span class="line">    sleep(<span class="number">1</span>)</span><br><span class="line">    end = time()</span><br><span class="line">    cost_time = end - start</span><br><span class="line">    print(<span class="string">"func three run time &#123;&#125;"</span>.format(cost_time))</span><br></pre></td></tr></table></figure><p>在每个函数里都需要获取开始时间<strong>start</strong>、结束时间<strong>end</strong>、计算耗费时间<strong>cost_time</strong>、加上一个输出语句。</p><p>使用装饰器的方法是这样的，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_time</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">()</span>:</span></span><br><span class="line">        start = time()</span><br><span class="line">        func()                  <span class="comment"># 函数在这里运行</span></span><br><span class="line">        end = time()</span><br><span class="line">        cost_time = end - start</span><br><span class="line">        print(<span class="string">"func three run time &#123;&#125;"</span>.format(cost_time))</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@run_time</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun_one</span><span class="params">()</span>:</span></span><br><span class="line">    sleep(<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line"><span class="meta">@run_time</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun_two</span><span class="params">()</span>:</span></span><br><span class="line">    sleep(<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line"><span class="meta">@run_time</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun_three</span><span class="params">()</span>:</span></span><br><span class="line">    sleep(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>通过编写一个统计时间的装饰器<strong>run_time</strong>，函数的作为装饰器的参数，然后返回一个统计时间的函数wrapper，这就是装饰器的写法，用专业属于来说这叫<strong>闭包</strong>，简单来说就是函数内嵌套函数。然后再每个函数上面加上<strong>@run_time</strong>来调用这个装饰器对不同的函数进行统计时间。</p><p>可见，统计时间这4行代码是重复的，一个函数需要4行，如果100个函数就需要400行，而使用装饰器，只需要几行代码实现一个装饰器，然后每个函数前面加一句命令即可，如果是100个函数，能少300行左右的代码量。</p><h2 id="带参数的装饰器"><a href="#带参数的装饰器" class="headerlink" title="带参数的装饰器"></a>带参数的装饰器</h2><p>通过前面简单的例子应该已经明白装饰器的价值和它的简单用法：<strong>通过闭包来实现装饰器，函数作为外层函数的传入参数，然后在内层函数中运行、附加功能，随后把内层函数作为结果返回。</strong></p><p>除了上述简单的用法还有一些更高级的用法，比如用装饰器进行<strong>类型检查</strong>、添加<strong>带参数</strong>的的装饰器等。它们的用法大同小异，关于高级用法，这里以<strong>带参数的装饰器</strong>为例进行介绍。</p><p>不要把问题想的太复杂，带参数的装饰器其实就是在上述基本的装饰器的基础上在外面套一层接收参数的函数，下面通过一个例子说明一下。</p><p>以上述例子为基础，前面的<strong>简单示例</strong>输出的信息是，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func three run time 1.0003271102905273</span><br><span class="line">func three run time 1.0006263256072998</span><br><span class="line">func three run time 1.000312328338623</span><br></pre></td></tr></table></figure><p>现在我认为这样的信息太<strong>单薄</strong>，需要它携带更多的信息，例如函数名称、日志等级等，这时候可以把函数名称和日志等级作为装饰器的参数，下面来时实现以下。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">logger</span><span class="params">(msg=None)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run_time</span><span class="params">(func)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">            start = time()</span><br><span class="line">            func()                  <span class="comment"># 函数在这里运行</span></span><br><span class="line">            end = time()</span><br><span class="line">            cost_time = end - start</span><br><span class="line">            print(<span class="string">"[&#123;&#125;] func three run time &#123;&#125;"</span>.format(msg, cost_time))</span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line">    <span class="keyword">return</span> run_time</span><br><span class="line"></span><br><span class="line"><span class="meta">@logger(msg="One")</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun_one</span><span class="params">()</span>:</span></span><br><span class="line">    sleep(<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line"><span class="meta">@logger(msg="Two")</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun_two</span><span class="params">()</span>:</span></span><br><span class="line">    sleep(<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line"><span class="meta">@logger(msg="Three")</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun_three</span><span class="params">()</span>:</span></span><br><span class="line">    sleep(<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">fun_one()</span><br><span class="line">fun_two()</span><br><span class="line">fun_three()</span><br></pre></td></tr></table></figure><p>可以看出，我在<strong>示例</strong>基本用法里编写的装饰器外层又嵌套了一层函数用来接收参数<strong>msg</strong>，这样的话在每个函数(func_one、func_two、func_three)前面调用时可以给装饰器传入参数，这样的输出结果是，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[One] func three run time <span class="number">1.0013229846954346</span></span><br><span class="line">[Two] func three run time <span class="number">1.000720500946045</span></span><br><span class="line">[Three] func three run time <span class="number">1.0001459121704102</span></span><br></pre></td></tr></table></figure><h1 id="自定义属性的装饰器"><a href="#自定义属性的装饰器" class="headerlink" title="自定义属性的装饰器"></a>自定义属性的装饰器</h1><p>上述介绍的几种用法中其实有一个问题，就是装饰器<strong>不够灵活</strong>，我们预先定义了装饰器<strong>run_time</strong>，它就会按照我们定义的流程去工作，只具备这固定的一种功能，当然，我们前面介绍的通过<strong>带参数的装饰器</strong>让它具备了一定的灵活性，但是依然不够灵活。其实，我们还可以对装饰器添加一些属性，就如同给一个类定义实现不同功能的方法那样。</p><p>以输出<strong>日志</strong>为例，初学Python的同学都习惯用<strong>print</strong>打印输出信息，其实这不是一个好习惯，当开发商业工程时，你很用意把一些信息暴露给用户。在开发过程中，我更加鼓励使用日志进行输出，通过定义<strong>WARNING</strong>、<strong>DEBUG</strong>、<strong>INFO</strong>等不同等级来控制信息的输出，比如<strong>INFO</strong>是可以给用户看到的，让用户直到当前程序跑到哪一个阶段了。<strong>DEBUG</strong>是用于开发人员调试和定位问题时使用。<strong>WARING</strong>是用于告警和提示。</p><p>那么问题来了，如果我们预先定义一个打印日志的装饰器，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">logger_info</span><span class="params">(func)</span>:</span></span><br><span class="line">    logmsg = func.__name__</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">()</span>:</span></span><br><span class="line">        func() </span><br><span class="line">        log.log(logging.INFO, <span class="string">"&#123;&#125; if over."</span>.format(logmsg))</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br></pre></td></tr></table></figure><p><strong>logging.INFO</strong>是打印日志的等级，如果我们仅仅写一个基本的日志装饰器<strong>logger_info</strong>，那么它的灵活度太差了，因为如果我们要输出<strong>DEBUG</strong>、<strong>WARING</strong>等级的日志，还需要重新写一个装饰器。</p><p>解决这个问题，有两个解决方法：</p><ul><li>利用前面所讲的带参数装饰器，把<strong>日志等级</strong>传入装饰器</li><li>利用自定义属性来修改<strong>日志等级</strong></li></ul><p>由于第一种已经以统计函数运行时间的方式进行讲解，这里主要讲解第二种方法。</p><p>先看一下代码，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> partial</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wrapper_property</span><span class="params">(obj, func=None)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> func <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> partial(wrapper_property, obj)</span><br><span class="line">    setattr(obj, func.__name__, func)</span><br><span class="line">    <span class="keyword">return</span> func</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">logger_info</span><span class="params">(level, name=None, message=None)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decorate</span><span class="params">(func)</span>:</span></span><br><span class="line">        </span><br><span class="line">        logmsg = message <span class="keyword">if</span> message <span class="keyword">else</span> func.__name__</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">            log.log(level, logmsg)</span><br><span class="line">            <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line"></span><br><span class="line"><span class="meta">        @wrapper_property(wrapper)</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">set_level</span><span class="params">(newlevel)</span>:</span></span><br><span class="line">            <span class="keyword">nonlocal</span> level</span><br><span class="line">            level = newlevel</span><br><span class="line"></span><br><span class="line"><span class="meta">        @wrapper_property(wrapper)</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">set_message</span><span class="params">(newmsg)</span>:</span></span><br><span class="line">            <span class="keyword">nonlocal</span> logmsg</span><br><span class="line">            logmsg = newmsg</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> decorate</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@logger_info(logging.WARNING)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x + y</span><br></pre></td></tr></table></figure><p>这里面最重要的是<strong>wrapper_property</strong>这个函数，它的功能是把一个函数<strong>func</strong>编程一个对象<strong>obj</strong>的属性，然后通过调用<strong>wrapper_property</strong>，给装饰器添加了两个属性<strong>set_message</strong>和<strong>set_level</strong>，分别用于改变输出日志的内容和改变输出日志的等级。</p><p>看一下输出结果，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">main(<span class="number">3</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line"><span class="comment"># WARNING:Test:main</span></span><br><span class="line"><span class="comment"># 6</span></span><br></pre></td></tr></table></figure><p>来改改变一下输出日志等级，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">main.set_level(logging.ERROR)</span><br><span class="line">main(<span class="number">5</span>, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line"><span class="comment"># ERROR:Test:main</span></span><br><span class="line"><span class="comment"># 10</span></span><br></pre></td></tr></table></figure><p>输出日志等级改成了<strong>ERROR</strong>。</p><h1 id="保留元信息的装饰器"><a href="#保留元信息的装饰器" class="headerlink" title="保留元信息的装饰器"></a>保留元信息的装饰器</h1><p>很多教程中都会介绍装饰器，但是大多数都是千篇一律的围绕基本用法在展开，少部分会讲一下带参数的装饰器，但是有一个细节很少有教程提及，那就是<strong>保留元信息的装饰器</strong>。</p><p><strong>什么是函数的元信息？</strong></p><p>就是函数携带的一些基本信息，例如函数名、函数文档等，我们可以通过<strong>func.__name__</strong>获取函数名、可以通过<strong>func.__doc__</strong>获取函数的文档信息，用户也可以通过<strong>注解</strong>等方式为函数添加元信息。</p><p>例如下面代码，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_time</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        start = time()</span><br><span class="line">        func()                  <span class="comment"># 函数在这里运行</span></span><br><span class="line">        end = time()</span><br><span class="line">        cost_time = end - start</span><br><span class="line">        print(<span class="string">"func three run time &#123;&#125;"</span>.format(cost_time))</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@run_time</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun_one</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    func one doc.</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    sleep(<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">fun_one()</span><br><span class="line"></span><br><span class="line">print(fun_one.__name__)</span><br><span class="line">print(fun_one.__doc__)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line"><span class="comment"># wrapper</span></span><br><span class="line"><span class="comment"># None</span></span><br></pre></td></tr></table></figure><p>可以看出，通过使用装饰器，函数<strong>fun_one</strong>的元信息都丢失了，那怎么样才能保留装饰器的元信息呢？</p><p>可以通过使用Python自带模块<strong>functools</strong>中的<strong>wraps</strong>来保留函数的元信息，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_time</span><span class="params">(func)</span>:</span></span><br><span class="line"><span class="meta">    @wraps(func)                                # &lt;- 这里加 wraps(func) 即可</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        start = time()</span><br><span class="line">        func()                  <span class="comment"># 函数在这里运行</span></span><br><span class="line">        end = time()</span><br><span class="line">        cost_time = end - start</span><br><span class="line">        print(<span class="string">"func three run time &#123;&#125;"</span>.format(cost_time))</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@run_time</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun_one</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    func one doc.</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    sleep(<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">fun_one()</span><br><span class="line"></span><br><span class="line">print(fun_one.__name__)</span><br><span class="line">print(fun_one.__doc__)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line"><span class="comment"># fun_one   </span></span><br><span class="line"><span class="comment"># func one doc.</span></span><br></pre></td></tr></table></figure><p>只需要在代码中加入<strong>箭头</strong>所指的一行即可保留函数的元信息。</p><h1 id="文档获取"><a href="#文档获取" class="headerlink" title="文档获取"></a>文档获取</h1><p>本讲的Markdown格式文档我进行共享了，需要的可以关注公众号回复回复关键字”<font color="red">python</font>“获取。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;完整代码&lt;/strong&gt;请查看github项目: &lt;a href=&quot;https://github.com/Jackpopc/advance-python/blob/master/code/1-decorators.ipynb&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;advance-python&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;前段时间我发了一篇讲解Python调试工具PySnooper的文章，在那篇文章开始一部分我简单的介绍了一下装饰器，文章发出之后有几位同学说”终于了解装饰器的用法了”，可见有不少同学对装饰器感兴趣。但是那篇文章主要的目的是在介绍PySnooper，所以没有太深入的展开讲解装饰器，于是在这里就详细的介绍一些装饰器的使用。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="https://jackpopc.github.io/categories/Python/"/>
    
    
      <category term="编程" scheme="https://jackpopc.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Python" scheme="https://jackpopc.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>【进阶Python】第一讲：开篇</title>
    <link href="https://jackpopc.github.io/2019/08/04/python-one/"/>
    <id>https://jackpopc.github.io/2019/08/04/python-one/</id>
    <published>2019-08-04T10:02:56.000Z</published>
    <updated>2019-08-04T11:28:00.497Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><img src="https://s2.ax1x.com/2019/08/04/e66UQs.jpg" alt="e66UQs.jpg"></p><p>2015年，本科毕业的那个暑假我开始疯狂的投递简历，希望找一份数据分析与数据挖掘相关的实习工作。直到有一家公司的面试官问到我：“你会Python吗？”，<a id="more"></a>我当时一脸疑惑，因为，大学期间只系统的学习过C语言，后期开发系统中用到过少量的C#。于是我问面试官：“你能给我拼写一下这么语言的名字吗”？多年之后回想起来还会觉得很尴尬，真的是孤陋寡闻。</p><p>从那以后，“Python”这么语言经常出现在我耳边。读研之后我开始之后我主要研究的方向是传统目标识别和图像处理，主要使用的语言就是C++和Matlab，所以Python在我读研第一年并不是主力工具。研二开始后我开始进入深度学习这个领域，开始用到很多第三方的工具包，例如caffe、tensorflow已经CNN，那以后开始以Python语言为主。</p><p>因为之前有一些编程基础，在加上当初面试实习时时间紧迫，所以我就抽了一天的时间把Python基础教程看了一遍，了解了基本用法之后就成功的面试上了一份实习工作。那时候我认为Python是简单的，因为它不像C++、Java那样有严格的语法规范、有变量类型的概念，你只需要记住缩进正确即可。而且在做自然语言和计算机视觉过程中很多部分的代码都是依托第三方工具包完成，真正自己开发的只是一些数据预处理、文本处理以及用一些条件循环语句对逻辑进行串联。</p><p>直到后来从事工作以后，做了更多有严格交付要求的项目之后才发现，Python并没有想象的那么简单，“<strong>会用Python容易，用好Python不易</strong>”，这是我使用几年Python之后的感触。</p><p>当你做一个项目要考虑到代码的复用性、易读性、运行效率、后期维护成本以及面对一些复杂的数据结构时，你会发现Python绝对不是简简单单利用那些基本知识能够实现的。</p><p>这也是我开始这个系列分享的原因，第一：把自己开发过程中的一些心得和经验总结下来。第二：如果能够帮助更多的Python学习者，那就更加荣幸了。</p><h1 id="为什么要用Python？"><a href="#为什么要用Python？" class="headerlink" title="为什么要用Python？"></a>为什么要用Python？</h1><p>近几年唱衰Python的声音不拘于耳，有些人是的确发现并感受到了Python的缺点，但是更多的人是跟风式的唱衰Python。“Python效率低”，很多人都这样说，这显然有一些以偏概全的感觉，如果做游戏、软件，Python的确不占优势，但是如果作为算法工程师，进行算法验证，我想没有几个人会选择C/C++。口说无凭，先看几组数据对比。</p><p><strong>PYPL</strong></p><blockquote><p>通过分析在谷歌上搜索语言教程的频率，创建了编程语言索引的PYPL流行度。</p></blockquote><p>首先看一下PYPL最新编程语言流行程度，</p><p><img src="https://s2.ax1x.com/2019/08/04/e6yXIU.png" alt="e6yXIU.png"></p><p>Python居于第一，力压Java、JS、PHP这些名气非常大的编程语言，而且前10名中2~9名都出现了负增长，而Python却4.5%的正向增长率。</p><p>如果觉得一个平台不够具有说服力，可以再看看另外一个知名的编程社区的排名。</p><p><strong>TIOBE编程社区</strong></p><blockquote><p>TIOBE编程社区指数是编程语言受欢迎程度的一个指标。该指数每月更新一次。这些排名是基于全球熟练工程师、课程和第三方供应商的数量。流行的搜索引擎，如谷歌，必应，雅虎!美国、维基百科(Wikipedia)、亚马逊(Amazon)、YouTube和百度被用来计算收视率。值得注意的是，TIOBE索引不是关于最好的编程语言，也不是编写大多数代码行的语言。</p></blockquote><p>来看一下TIOBE社区7月的编程语言排名，</p><p><img src="https://s2.ax1x.com/2019/08/04/e6yxG4.png" alt="e6yxG4.png"></p><p>Python仅次于Java和C，排在第三名，而且对比去年同期，前10名中Python增长速度最快，达到2.9%。</p><p>从这里可以看出，Python一直被唱衰、一直很坚挺，尽管几年量关于Go、julia、Rust的呼声很高，但是依然无法撼动Python的地位，而且这些编程语言到底好不好用？有没有炒作的成分在里面？现在还是一个问号。</p><p><img src="https://s2.ax1x.com/2019/08/04/e6yviF.png" alt="e6yviF.png"></p><p>话说回来<strong>为什么Python如此受欢迎？</strong></p><p>我认为存在的即是合理的，如果它真的一无是处、漏洞百出，是经不住众人的考验的。它之所以如此受欢迎，自然有很多吸引人的方面：</p><ul><li>简单易用、节省时间</li><li>丰富的第三方工具包</li><li>强大的社区</li><li>应用场景丰富</li></ul><p>其他三个方面暂且不说，就说一些第一点，<strong>简单易用、节省时间</strong>，我觉得有这一个理由就足以吸引很多人。尤其是对于算法、测试等岗位，真正的耗费心思的并不在编程、开发这一块，编程语言是用来验证算法的可靠性的，但是没有这个编程语言，自然无法验证，这就体现出有一个简单易用的语言有多么重要了。</p><p>吴恩达在《机器学习》这么课程里提到“硅谷的工程师大多数都会选择一个简单的编程语言对自己的算法进行验证，当确认有效之后会用c/c++等语言重新实现一遍”，这足以体现Python语言<strong>简单易用</strong>的优点。</p><p>Python距离第一个版本发布以及有28年，唱衰的言论从未间断，但是依旧坚挺。</p><p>尤其是机器学习的大规模应用、国家把人工智能智能技术上升到战略层次，使得Python称为独树一帜的编程语言，虽然这两年Go、Julia号称性能更好、更加易用，但是一直无法撼动Python在机器学习领域的地位，很难望其项背，为什么？我认为最主要的原因就是拥有强大的用户基础。现在在大多数企业，从事算法相关岗位的清一色的使用Python，更别说计算机视觉、自然语言这些强依赖Python第三方库的方向。</p><h1 id="Python该怎么学习？"><a href="#Python该怎么学习？" class="headerlink" title="Python该怎么学习？"></a>Python该怎么学习？</h1><p>我认为大多数编程语言的学习都可以简化为3个过程：</p><ul><li>入门</li><li>进阶</li><li>强化</li></ul><p><strong>入门阶段</strong>网上的教程已经很多了，关于入门我个人是不推荐参加培训班的，因为就如同前面所说的那样，Python基础语法非常简单，尤其是有一些C、Matlab、C++等编程基础的同学来说，Python中的很多概念虽然和恰语言不是完全相同，但是相似度还是非常高的，可以达到触类旁通。我个人更倾向于使用在线教程，这里推荐两个不错的入门教程，</p><p><strong>菜鸟教程</strong></p><p><a href="https://www.runoob.com/python/python-tutorial.html" target="_blank" rel="noopener">https://www.runoob.com/python/python-tutorial.html</a></p><p><strong>廖雪峰Python</strong></p><p><a href="https://www.liaoxuefeng.com/wiki/1016959663602400" target="_blank" rel="noopener">https://www.liaoxuefeng.com/wiki/1016959663602400</a></p><p><strong>强化阶段</strong>我认为需要在实际的项目和工作中去得到提升，就如同计算机视觉、自然语言处理一样，你从文章和练手项目中所能获取的只有那么多，如果像进一步得到升华就需要在项目中去面对困难、解决困难，这时候就会想尽方法去解决各种难题，不知不觉中会得到很大的提升。</p><p>本系列的主要目的是介绍<strong>进阶阶段</strong>，讲解一些Python的高级用法，对于入门和强化阶段自己可以私下完成。</p><h1 id="书籍推荐"><a href="#书籍推荐" class="headerlink" title="书籍推荐"></a>书籍推荐</h1><p>如果时间比较冲突，我觉得可以系统的看一些Python书籍，因为书籍的严谨性和条理性更加有保障，在这我推荐3本我个人认为不错的书籍，</p><p><strong>1.《Python编程 从入门到实践》</strong></p><p><img src="https://s2.ax1x.com/2019/08/04/e6yzRJ.png" alt="e6yzRJ.png"></p><p>如果时间有限，我认为入门阶段可以通过菜鸟教程、廖雪峰Python进行学习。如果时间充足，我认为可以看一下入门书籍，因为更加严谨一些。</p><p>《Python编程 从入门到实践》是一本比较适合入门的书籍，环境配置、变量、列表、if语句、函数等基础的概念都会详细的展开介绍，这对于没有编成基础的同学非常有帮助。</p><p><strong>2.《流畅的Python》</strong></p><p><img src="https://s2.ax1x.com/2019/08/04/e66kdK.jpg" alt="e66kdK.jpg"></p><p>这是一本经得起考验的Python书籍。</p><p>它和大多数书籍和在线教程<strong>蜻蜓点水</strong>式的讲解不同，它更加深入，<strong>深入而不冗余</strong>，在你看这本书的时候你会发现，它的每一段话都是有意义的，没有什么废话。</p><p>它分别从数据结构、字典集合、文本和字节序列、函数、设计、装饰器、闭包等讲起，然后对每一块知识进行展开，<strong>详细介绍里面最根本的原理</strong>，然后告诉你，该怎么用好它，高效的使用它。</p><p>举一个最简单的例子，在绝大多数教程都会讲到<strong>循环和条件语句</strong>，千篇一律的告诉你”if..else..”, “for…while”，这个有一点编程语言的同学都知道，但是在Python里面循环和条件语句有什么特殊的地方吗？该怎么用好它？</p><p><img src="https://s2.ax1x.com/2019/08/04/e66ViD.jpg" alt="e66ViD.jpg"></p><p>《流畅的Python》这本书就教你怎么去使用它，告诉你<strong>列表推导</strong>该怎么用还有它的意义所在。</p><p>这就是这本书的优点：<strong>不仅告诉你怎么用Python，而是告诉你怎么用好Python</strong>。</p><p><strong>3. 《Python CookBook》</strong></p><p><img src="https://s2.ax1x.com/2019/08/04/e66leP.jpg" alt="e66leP.jpg"></p><p>学而不精的同学都会认为Python是一门很简单的编程语言，不错，Python相对于Java、C++要简单很多，没有严格的语法结构、没有变量类型，而且如果有一些编程基础去学Python的话可以一个周甚至一天即可学完。</p><p>但是我认为，Python入门简单，但是用好并不简单，当你接触到标准的商业项目时你就会意识到Python高级用法的重要性以及它的价值所在。</p><p>《Python CookBook》这本书就是这样的一本进阶教材，它不同于大多数教程，反复的介绍基本语法，它直接跳过基本语法开始讲解数据结构、算法、迭代器、生成器、类、对象、元编程等，我认为这些才是工作中真正有价值、拉开差距的地方，而那些基本语法是默认应该会的。</p><p><img src="https://s2.ax1x.com/2019/08/04/e66JJg.jpg" alt="e66JJg.jpg"></p><p>《Python CookBook》会在每个知识点开始提出一个应用场景，然后告诉你怎么去解决这种应用，同时会编程实现，这样对于提升Python是最为实际的，而且让你更加容易理解它这样用的价值所在。</p><p>这本书不仅有出版的书籍，也有免费的在线教程，需要可以看一下。</p><p><a href="https://python3-cookbook.readthedocs.io/zh_CN/latest/preface.html" target="_blank" rel="noopener">https://python3-cookbook.readthedocs.io/zh_CN/latest/preface.html</a></p><hr><blockquote><p>更多精彩内容，请关注公众号【平凡而诗意】~</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/08/04/e66UQs.jpg&quot; alt=&quot;e66UQs.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;2015年，本科毕业的那个暑假我开始疯狂的投递简历，希望找一份数据分析与数据挖掘相关的实习工作。直到有一家公司的面试官问到我：“你会Python吗？”，
    
    </summary>
    
      <category term="Python" scheme="https://jackpopc.github.io/categories/Python/"/>
    
    
      <category term="Python" scheme="https://jackpopc.github.io/tags/Python/"/>
    
      <category term="教程" scheme="https://jackpopc.github.io/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>【动手学计算机视觉】第十讲：传统目标检测之卷积神经网络概述</title>
    <link href="https://jackpopc.github.io/2019/08/03/cnn/"/>
    <id>https://jackpopc.github.io/2019/08/03/cnn/</id>
    <published>2019-08-03T12:07:53.000Z</published>
    <updated>2019-08-03T13:54:01.272Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><img src="https://s2.ax1x.com/2019/08/03/esS9C4.png" alt="esS9C4.png"></p><p>提起卷积神经网络(CNN)，应该很多人都有所耳闻。自从2012年AlexNet在ImageNet挑战赛一举夺魁，它再一次的回到的人们的视野。</p><p>为什么称之为”再一次”，因为CNN并不是近几年的产物，<a id="more"></a>早在20世纪90年代Yann LeCun就提出了最基础的卷积神经网络模型(LeNet)，但是由于算力和数据的限制，它一直处于一种被冷遇的地位，传统目标识别方法，例如之前所讲到的SIFT、HOG、DPM占据着不可撼动的统治地位。</p><p>但是随着算力的提升和数据集的积累，这一切都变了，在AlexNet成功之后，CNN如同雨后春笋一样，每年各种各样的Net数不胜数，近其中知名的就有AlexNet、VGG、GoogleNet、UNet、R-CNN、FCN、SSD、YOLO等。</p><p>入门计算机视觉领域的绝大多数同学应该都学过或听说过斯坦福大学的公开课(CS231n: Convolutional Neural Networks for Visual Recognition)，主要就围绕CNN进行展开，甚至很多近几年入门计算机视觉的同学就斩钉截铁的认为，<strong>计算机视觉就是卷积神经网络</strong>，我认为这有一些”一叶障目，不见泰山的”感觉。</p><p>CNN只是计算机视觉的一个子集，而且是一个很小的子集，更确切的说，计算机视觉是一种应用性技术，CNN是一种工具。</p><p>但是，不可否认，CNN是目前阶段我们能力所达到的、在大多数CV方向应用最为成功的一项技术，尤其是R-CNN系列和YOLO系列，在商业中，例如交通监测、车站安检、人脸识别应用非常多，效果对比于传统目标识别算法也要好很多，所以，它是学习计算机视觉中非常重要的一环，本文就概述一下近年来比较成功的CNN模型。本文只是用简略的语言进行概述，后续会挑选一些比较经典的模型进行详解和编程实现。</p><h1 id="卷积神经网络概述"><a href="#卷积神经网络概述" class="headerlink" title="卷积神经网络概述"></a>卷积神经网络概述</h1><p><img src="https://s2.ax1x.com/2019/08/03/erzxET.png" alt="erzxET.png"></p><p>按功能对卷积神经网络进行分类主要可以分为两类，</p><ul><li>检测(detection)</li><li>分割(segmentation)</li></ul><p>检测的目的是要判断一副图像中是否有特定的目标，以及它所在的位置，通过一些手段识别出它所在的包围合区域。</p><p>分割的目的要更加严格一些，它不仅要识别出目标的所在区域，还要分割出目标的边缘，尤其在CNN图像分割领域，和传统的图像分割不同，它不能简单的依靠梯度变化幅度把目标分割出来，还需要进行语义上的分割，识别到像素级的类别。</p><p>目前比较知名的用于识别的CNN模型有，</p><ul><li>AlexNet</li><li>VGG</li><li>R-CNN系列</li><li>Resnet</li><li>MobileNet</li><li>YOLO系列</li></ul><p>在分割方面比较知名的CNN模型有，</p><ul><li>Mask R-CNN</li><li>FCN</li><li>U-Net</li><li>SegNet</li></ul><h1 id="CNN中主要用到的技术"><a href="#CNN中主要用到的技术" class="headerlink" title="CNN中主要用到的技术"></a>CNN中主要用到的技术</h1><p><img src="https://s2.ax1x.com/2019/08/03/espUw6.png" alt="espUw6.png"></p><p>系统学习以上上述所提到的知名CNN模型会发现，其中所使用到的技术手段大同小异，而那些知名度较小的CNN模型更是如此，创新点更是微乎其微，其中所使用到的技术主要有，</p><ul><li>卷积</li><li>池化</li><li>基础块</li><li>Dropout</li><li>跳跃连接</li><li>锚点</li><li>优化算法</li><li>激活函数</li><li>批量正则化</li><li>回归</li></ul><p><img src="https://s2.ax1x.com/2019/08/03/esprSH.png" alt="esprSH.png"></p><p><strong>卷积</strong>和<strong>池化</strong>是非常基础的，在特征提取过程中至关重要。</p><p><strong>基础块</strong>的思想最初出自于VGG，它在AlexNet的基础上进行了很大的改进，基础块思想的引入增加了网络的重用性，后续很多模型都死在这一举出上进行改进的，因此，在很多后续的网络模型都是以VGG为基础模型。</p><p><strong>Dropout</strong>这个几乎成了CNN模型中必不可少的一个组件，它在应对<strong>过拟合</strong>问题中具有非常重要的价值。</p><p><strong>跳跃连接</strong>最初出现在ResNet，在网络的不断改进中发现，其中的思想都是使网络越来越深，网络适当的加深的确能够带来识别精度的提到，但是真的越深越好吗？当然不是。随着网络的加深，很容易出现梯度消失和梯度爆炸现象，ResNet中提出的跳跃连接在后来的网络模型中扮演者非常重要的角色。</p><p><strong>锚点</strong>这一概念最初是在2008年的DPM模型中看到，后来Faster R-CNN中主要的使用了这项技术，使得它名声大噪，后来的经典模型几乎都用到了锚点这个思想。</p><p><strong>优化算法</strong>对于上述CNN模型的价值自然不言而喻，梯度下降、Adam、牛顿法等，可以说这是深度计算机视觉的核心所在，也是理论体系最完善、最能够用数学模型解释的一部分。</p><p><strong>激活函数</strong>和Dropout一样，也是CNN模型中必不可少的一个组件，它的主要价值在于解决模型的线性不可分问题，把非线性的特性引入到网络模型中。</p><p><strong>批量正则化</strong>也是CNN中常用的一个功能，它的主要作用是加速模型的收敛，避免深层神经网络的梯度消失和梯度爆炸。</p><p><strong>回归</strong>中用到的较多的自然是softmax，它将经过各种网络层处理得到的特性向量进行回归，得到每一个类别对应的概率，在多分类问题中是一个必不可少的功能。</p><h1 id="CNN模型架构"><a href="#CNN模型架构" class="headerlink" title="CNN模型架构"></a>CNN模型架构</h1><p><a href="https://imgchr.com/i/esp6OI" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/08/03/esp6OI.png" alt="esp6OI.png"></a></p><p>纵观上述所提及的经典CNN模型，它们的模型架构非常相似，主要包含如下几个部分：</p><ul><li>输入层</li><li>特征提取层</li><li>全连接层</li><li>回归</li><li>输出层</li></ul><p><strong>输入层</strong>主要是用于读取图像，用于后面的网络层使用。</p><p><strong>特征提取层</strong>主要通过卷积来获取图像局部的特征，得到图像的特征图。</p><p><strong>全连接层</strong>用于对特征层进行后处理，然后用于回归层处理。</p><p><strong>回归</strong>主要通过一些回归函数，例如softmax函数来对前面得到的特征向量进行处理，得到每个类别对应的概率。</p><p><strong>输出层</strong>用于输出检测和分类的结果。</p><p>当然，在这个过程中某些环节会用到上述提到的激活函数、批量正则化、优化算法以及非极大值抑制。</p><h1 id="搭建CNN目标识别系统"><a href="#搭建CNN目标识别系统" class="headerlink" title="搭建CNN目标识别系统"></a>搭建CNN目标识别系统</h1><p><img src="https://s2.ax1x.com/2019/08/03/esSP29.png" alt="esSP29.png">有了上述强大的模型，在实际项目中该怎么搭建一个有价值的CNN目标识别系统呢？我认为主要分为如下几个步骤，</p><ul><li>数据获取</li><li>数据预处理</li><li>模型搭建</li><li>数据后处理</li></ul><p>在CNN，乃至整个深度学习领域都可以说数据获取是至关重要的一部分，甚至可以说占据了超过50%的地位。深度学习的发展主要就是得益于这么多年来数据的积累，很多项目和工程也是由于数据的限制和却是只能中途作废。因此，数据获取部分是搭建目标识别系统中最重要的一个环节，它直接决定着是否能够继续走下去。</p><p>目前有一些公开的数据集可以获取，例如MNIST、Pascal VOC、ImageNet、Kaggle等。如果自己所做的方向恰好巧合，这些公开数据集里有相应的数据，那么的确是幸运的，可以从这些数据中直接获取。</p><p>数据预处理对于CNN同样非常重要，各种视频、摄像头在数据采集的过程中很难保证数据是有价值的，或者干净的，这里就需要对数据进行去噪、去模糊、增强分辨率，如果数据集不充足，还需要对数据进行扩充。</p><p>模型搭建我认为是这几个环节中相对较为容易的一部分，首先目前这些经典的框架都有开源的项目，有的甚至不止一个版本，我们可以借鉴甚至直接拿来用这些模型。即便不愿意选择开源的项目，也可以使用tensorflow、pytorch进行搭建，其中需要的代码量是非常有限的。</p><p>输出检测的结果需要进行非极大值抑制、绘出包围合等后续工作，以及和一些系统进行对接，这样它才是一个可用的完整系统。</p><hr><blockquote><p>更多精彩内容，请关注公众号【平凡而诗意】~</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/08/03/esS9C4.png&quot; alt=&quot;esS9C4.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;提起卷积神经网络(CNN)，应该很多人都有所耳闻。自从2012年AlexNet在ImageNet挑战赛一举夺魁，它再一次的回到的人们的视野。&lt;/p&gt;
&lt;p&gt;为什么称之为”再一次”，因为CNN并不是近几年的产物，
    
    </summary>
    
      <category term="计算机视觉" scheme="https://jackpopc.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
    
      <category term="CV" scheme="https://jackpopc.github.io/tags/CV/"/>
    
      <category term="AI" scheme="https://jackpopc.github.io/tags/AI/"/>
    
      <category term="图像处理" scheme="https://jackpopc.github.io/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>推荐5款值得安装的Windows工具</title>
    <link href="https://jackpopc.github.io/2019/08/01/five-windows-tools/"/>
    <id>https://jackpopc.github.io/2019/08/01/five-windows-tools/</id>
    <published>2019-08-01T13:52:55.000Z</published>
    <updated>2019-08-03T11:02:55.545Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>电脑，是我们日常学习和办公中主要依赖的工具之一。而windows作为最流行、使用最为广泛的桌面操作系统，与我们的生活有着密不可分的关系。尤其是近两年随着windows10的逐渐完善和丰富，使得windows操作系统更加受欢迎。<a id="more"></a>我个人使用win10已经超过两年，不得不说，这的确是一个不错的操作系统，在此之前会想方设法安装Ubuntu、centos、redhat等操作系统来替代win7和win8，但是随着windows发布和晚上，加入了linux内核，丰富实用的小工具，让我认识到微软在操作系统和软件生态方面的强大。</p><p>在使用windows的过程中，仅仅依靠系统自带的功能是无法满足各种各样的工作、学习需求的，因此需要借助一些第三方工具，虽然有很多知名的软件，例如office、Matlab、Photoshop、CAD等，但是这些工具太过于臃肿，不仅占用很大硬盘空间，而且需要付出高额的费用。windows上其实有很多使用、免费，但不失强大的工具，因为是免费开源，所以没有那么过广告和宣传，所以知名度相对较低，本文就介绍5款值得安装的windows工具。</p><h1 id="1-Click-amp-Clean"><a href="#1-Click-amp-Clean" class="headerlink" title="1. Click&amp;Clean"></a>1. Click&amp;Clean</h1><p><img src="https://s2.ax1x.com/2019/08/03/ercwPH.png" alt="ercwPH.png"></p><p>浏览器是我们使用最多的一款工具之一，甚至没有其中的之一。</p><p>每天我们花费大量的时间在浏览器上面，访问各种网址，也留下了很多访问的足迹，这就涉及一个问题，除了缓存垃圾之外就是<strong>隐私和信息安全</strong>。不知不觉中我们把自己的信息展露无疑。</p><p>我认为有着<a href="https://cleaner.en.softonic.com/" target="_blank" rel="noopener">Click&amp;Clean</a>这款超强的隐私保护工具就再也不用担心这个问题了。</p><p><img src="https://s2.ax1x.com/2019/08/03/erc0Gd.png" alt="erc0Gd.png"></p><p>当浏览器关闭时，这款应用程序删除你的浏览历史,防止他人跟踪你的网上活动，它支持以下诸多功能，</p><ul><li>清空缓存</li><li>删除 Cookie</li><li>清除已保存的密码</li><li>浏览器关闭时运行外部应用程序</li><li>关闭所有窗口/标签前清理</li><li>Delete Web Local Storages</li><li>Delete Extension Local Storages</li><li>Delete Web SQL Databases</li><li>Delete Extension SQL Databases</li><li>Google Gears 认证数据删除</li><li>……</li></ul><h1 id="2-石墨文档"><a href="#2-石墨文档" class="headerlink" title="2. 石墨文档"></a>2. 石墨文档</h1><p><img src="https://s2.ax1x.com/2019/08/03/ercBRA.jpg" alt="ercBRA.jpg"></p><p><strong>颠覆传统办公</strong></p><p>就如同它的定位那样“<strong>颠覆传统办公</strong>”，我觉得它做到了。和以往臃肿的office、昂贵的xmind不同，它首先免费，其次它支持多平台同步，windows、mac、手机均支持。此外，它将常用的办公工具融合为一体。</p><p><img src="https://s2.ax1x.com/2019/08/03/ercDxI.jpg" alt="ercDxI.jpg"></p><p>虽然拿它和office做对比，但是它<strong>不仅仅是传统意义上的office工具</strong>，它还包含如下功能，</p><ul><li>文档</li><li>表格</li><li>幻灯片</li><li>思维导图</li><li>协作空间</li></ul><p>可以说，上述每一项功能都是目前一个完整的商业产品，需要付出高额的服用，而且非常臃肿，但是石墨文档把这些问题都给解决了，不仅使用简单，而且轻量化、见面简洁大方。</p><h1 id="3-Squoosh"><a href="#3-Squoosh" class="headerlink" title="3. Squoosh"></a>3. Squoosh</h1><p><img src="https://s2.ax1x.com/2019/08/03/ercsMt.jpg" alt="ercsMt.jpg"></p><p>这是<strong>谷歌</strong>出品的一款强大的图片压缩工具，比之前较为知名的TinyPng还要强大一些。</p><p>我们都知道在我们传输图片，或者在一些平台上传图片时都会有图像大小的限制，例如微信公众号对上传图片就有限制，很多报名系统对上传图片也有限制。</p><p>但是我们又不想损失图片质量怎么办？可以尝试一下Squoosh，它采用谷歌强大的算法，<strong>在保障图像质量的前提下最大化压缩图片</strong>。</p><p>严格意义上说，它是一个<strong>网页工具</strong>，如果觉得用网页方便，可以直接保存网站<a href="https://squoosh.app/，到书签即可，如果不喜欢网页工具，没问题，它也支持安装，" target="_blank" rel="noopener">https://squoosh.app/，到书签即可，如果不喜欢网页工具，没问题，它也支持安装，</a></p><p><img src="https://s2.ax1x.com/2019/08/03/ercgZ8.png" alt="ercgZ8.png"></p><p>打开网站后点击右上角会发现，菜单栏出现”安装Squoosh”的资源，点击安装即可，占用内存非常小。</p><p>前面铺垫了很多，效果到底真的那么强大吗？下面来看一下对比图，</p><p><img src="https://s2.ax1x.com/2019/08/03/ercRIg.jpg" alt="ercRIg.jpg"></p><p>把一副1.51MB的原图压缩到104KB，压缩率高达<strong>93%</strong>，但是视觉上并不是很明显，看上去依然很清晰。</p><p>此外，它还支持一些简单的在线编辑。</p><h1 id="4-uTools"><a href="#4-uTools" class="headerlink" title="4. uTools"></a>4. uTools</h1><p><img src="https://s2.ax1x.com/2019/08/03/erchGj.jpg" alt="erchGj.jpg"></p><p>这可以称得上上“<strong>软件中的百宝箱</strong>”，内含丰富的插件，通过安装插件能够实现几十种功能，可以说，有了这款软件可以把很多软件卸载给你的系统节省一些空间了，此外，它还支持设置全局快捷键。</p><p>它的插件主要包括如下几类：</p><ul><li>通用：例如二维码、翻译、待办事项、剪切板、颜色助手、本地搜索等实用的小工具。</li><li>图片：包括压缩图片、图床、<strong>图片转文字</strong>等功能。</li><li>开发：包括JSON、正则表达式、http抓包等功能。</li></ul><p>这款工具可以适用于不同的人群，满足不同的需求，有了这款工具就不需要人群。</p><p><strong>安装插件</strong></p><p>插件安装非常简单，只需要<strong>点击对应软件-下载</strong>即可，</p><p><img src="https://s2.ax1x.com/2019/08/03/erc5zn.jpg" alt="erc5zn.jpg"></p><p><strong>使用</strong></p><p>安装之后打开对应的工具即可使用，</p><p><img src="https://s2.ax1x.com/2019/08/03/ercTs0.jpg" alt="ercTs0.jpg"></p><h1 id="5-WGestures"><a href="#5-WGestures" class="headerlink" title="5. WGestures"></a>5. WGestures</h1><p>我之前其实并不看好鼠标手势，因为尝试过很多手势工具，大多数都是功能花哨，但是使用体验很差，我一度甚至认为鼠标手势就是一个鸡肋，直到我遇到WGestures这款工具，可以说是让人心里感觉豁然开朗，原来鼠标手势可以这么好用，下面简单举几个例子。</p><p>基本手势包括复制、剪切、粘贴、前进、后退、添加书签、刷新、Home、End、”摩擦”边缘、触发角等。</p><p><strong>复制、粘贴</strong></p><p><img src="https://s2.ax1x.com/2019/08/03/erc7LV.gif" alt="erc7LV.gif"></p><p><strong>Web搜索</strong></p><p><img src="https://s2.ax1x.com/2019/08/03/ercbZT.gif" alt="ercbZT.gif"></p><p><strong>摩擦边缘</strong></p><p><img src="https://s2.ax1x.com/2019/08/03/ercLoF.jpg" alt="ercLoF.jpg"></p><p>摩擦右边缘弹出任务管理器、摩擦左边缘弹出控制面板</p><p><img src="https://s2.ax1x.com/2019/08/03/ercvW9.gif" alt="ercvW9.gif"></p><p><strong>自定义手势</strong></p><p>如果WGestures自带的手势无法满足自己的需求，还可以根据自己的偏好添加手势，添加手势类型包括打开文件、窗口控制、命令行、音量控制、执行快捷键等，例如，我自定义一个打开文件的手势，</p><p><img src="https://s2.ax1x.com/2019/08/03/ergpsx.gif" alt="ergpsx.gif"></p><hr><blockquote><p>更多精彩内容请关注公众号【平凡而诗意】~</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;电脑，是我们日常学习和办公中主要依赖的工具之一。而windows作为最流行、使用最为广泛的桌面操作系统，与我们的生活有着密不可分的关系。尤其是近两年随着windows10的逐渐完善和丰富，使得windows操作系统更加受欢迎。
    
    </summary>
    
      <category term="实用工具" scheme="https://jackpopc.github.io/categories/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="文件查找" scheme="https://jackpopc.github.io/tags/%E6%96%87%E4%BB%B6%E6%9F%A5%E6%89%BE/"/>
    
      <category term="工具" scheme="https://jackpopc.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="实用" scheme="https://jackpopc.github.io/tags/%E5%AE%9E%E7%94%A8/"/>
    
      <category term="插件" scheme="https://jackpopc.github.io/tags/%E6%8F%92%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>学习资源 | 推荐2份Github热门校招面试汇总资料</title>
    <link href="https://jackpopc.github.io/2019/07/28/interview/"/>
    <id>https://jackpopc.github.io/2019/07/28/interview/</id>
    <published>2019-07-28T10:51:09.000Z</published>
    <updated>2019-08-03T10:59:19.619Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><img src="https://s2.ax1x.com/2019/08/03/erNoKH.png" alt="erNoKH.png"></p><p>秋季招聘一般集中在每年的9月-10月份，有早一些的城市或者公司会在8月就开始进入校园，开启招聘，<a id="more"></a>也有比较晚的少数公司会在11月-12月进行招聘。</p><p>一年一度的秋季招聘马上就要开始了，秋季招聘是校园招聘中最为集中、岗位最多的一次集体招聘会，虽然也有春招，但是对于很多公司而言主要是“查漏补缺”，岗位数量相对于秋招有很大的差距。因此，很多即将毕业的学生会把秋季招聘看的非常重要，毕竟第一份工作对一个人来说是至关重要的，每个同学都希望找到称心如意的工作。</p><p>但是，“天下没有免费的午餐”，在秋季招聘中这个道理同样适用，好的工作岗位和面试的难度是成正比的，无论是银行、金融，还是互联网、IT。因此，要想找到一份称心如意的工作，必然需要做好充分的准备，毕竟，机会都是留给有准备的人。</p><p>面试是否有规可循？答案是肯定的，以阿里、百度、华为这些知名的互联网、IT公司为例，每年招聘的人数有限，但是应聘人数却是招聘人数的几十倍，甚至上千倍。招聘对于毕业生来说是一次煎熬的过程，对于企业同样是一个非常耗时耗力的事情，因此他们会通过一些“落入俗套”的方式进行人才的筛选，虽然这样会错失一部分真正的人才，但是能够筛选掉更多不符合要求的平庸人员，这样的损失是企业愿意接受的。有哪些“落入俗套”的方式呢？无非就是学历、学科、笔试、面试。其实经过一轮简历上学历、学科的筛选已经筛选下去一大批，而通过笔试又会筛选去一大批没有做好充分准备的同学，真正进入最后面试的已经是经过层层筛选留下来的。</p><p>学历、学科这些是人为无法改变的，但是笔试、面试却可以，因为成熟、经典的知识体系已经经过多年的洗礼逐渐完善了起来，笔试、面试的内容无非是变着花样的考书本上、教材上的知识，例如数据结构、算法设计等。因此，我认为通过准备，学习掌握目标公司历年来的出题类型和面试方式，会让应聘过程变的顺畅很多。</p><p>近期在github上发现两个不错的面试笔记，总结了各大知名互联网、IT公司，例如阿里、百度、腾讯、华为、美团等公司面试中常见的笔试、面试题型，并且给出了详细的解答。我认为每个人都有薄弱的地方，所以，如果心中有目标的公司，可以根据自身的不足之处学习一下对应公司近两年面试、笔试中常见的题型，好好准备，这样能够有效的帮助你在校招中找到称心如意的公司，废话不多说，下面介绍一下这两个开源学习项目。</p><h1 id="0voice-interview-internal-reference"><a href="#0voice-interview-internal-reference" class="headerlink" title="0voice / interview_internal_reference"></a>0voice / interview_internal_reference</h1><p><img src="https://s2.ax1x.com/2019/08/03/erN5xe.png" alt="erN5xe.png"></p><p><a href="https://github.com/0voice/interview_internal_reference" target="_blank" rel="noopener">https://github.com/0voice/interview_internal_reference</a></p><p>这是一个按公司和知识体系分类的的学习资源，目前已经13w+star。</p><p>如果心中有明确的目标公司，可以针对性的看一下对应公司的面试总结。它包含阿里、华为、百度、腾讯、美团、头条、滴滴、京东等。此外，还针对企业中比较常用的工程技术进行知识类型的总结，例如MySQL、Redis、MongoDB、Zookeeper、Nginx、算法、内存、磁盘、网络通信、安全、并发等，可以说是涵盖的非常全面。</p><p><img src="https://s2.ax1x.com/2019/08/03/erN42D.png" alt="erN42D.png"></p><p>和往常见到主要针对算法实现的笔试题目不同，这个项目更加偏向面试。我觉得对于有一些编程和数据结构知识的同学通过笔试都不是特别困难的事情，而真正能够在面试官心中留下深刻印象的往往在笔试中，而这些面试官往往是工作多年，深耕业务和产品的工作人员，因此，他们更多的关注的是现实中遇到的问题，所以，如果在这些问题上回答的不错更容易抓住面试官的心。</p><p><img src="https://s2.ax1x.com/2019/08/03/erNh8O.png" alt="erNh8O.png"></p><p>interview_internal_reference这个项目主要的针对这些问题，从系统稳定性到缓存机制，从并行计算内存优化，非常全面，知识体系也非常分散，我认为这远远要比反复的刷leetcode要有价值的多，尤其是对于腾讯、阿里这些偏工程的公司，在面试过程中会问很多非常分散的工程技术问题。</p><h1 id="imhuay-Algorithm-Interview-Notes-Chinese"><a href="#imhuay-Algorithm-Interview-Notes-Chinese" class="headerlink" title="imhuay/Algorithm_Interview_Notes-Chinese"></a>imhuay/<strong>Algorithm_Interview_Notes-Chinese</strong></h1><p><img src="https://s2.ax1x.com/2019/08/03/erNfPK.png" alt="erNfPK.png"></p><p><a href="https://github.com/imhuay/Algorithm_Interview_Notes-Chinese" target="_blank" rel="noopener">https://github.com/imhuay/Algorithm_Interview_Notes-Chinese</a></p><p>如果说interview_internal_reference偏向于工程技术，那么Algorithm_Interview_Notes-Chinese更多的是围绕着算法进行展开，目前已经25w+star。</p><p>在面试过程中，偏开发和偏算法的面试差别非常大，偏开发，例如前端、后端、云服务等工程技术的会询问很多分散技术的问题，但是偏算法的往往会集中在算法和项目方面，例如，做过哪些相关的项目？使用了什么算法？这个算法具体细节是什么？等等。大多数是围绕着应聘岗位进行面试，如果发散一些，会问一些经典的数据结构和数学方面的知识。</p><p>这几年随着人工智能火热，计算机视觉、深度学习、自然语言处理方面的工作岗位也多了起来，应聘者也多了起来。这个学习资源主要围绕人工智能领域的技术进行总结，同时涵盖数学、编程、数据结构等方面的基础知识。</p><p><img src="https://s2.ax1x.com/2019/08/03/erNTrd.png" alt="erNTrd.png"></p><p>如图所示，在深度学习方面，它包含了深度学习的基础知识，例如过拟合、欠拟合、激活函数、反向传播、正则化、加速训练，同时还包含深度学习领域核心的优化算法，例如，梯度下降法、动量法、牛顿法等。</p><p>此外，在计算机视觉、自然语言处理方面也包含了诸如VGG、词向量等基础的知识。我认为，它不仅适用于即将应聘的同学，同时对于已经参加工作的同学也非常有用。</p><p><img src="https://s2.ax1x.com/2019/08/03/erN7qA.png" alt="erN7qA.png"></p><p>除了应用层面的算法之外，它还有数学基础，例如微积分、概率论方面的知识，从求导到极限、从微分到积分，泰勒级数等，样样都有。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">widthOfBinaryTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; Q;</span><br><span class="line">        Q.push(root);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(!Q.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> cur_w = Q.size();  <span class="comment">// 当前层的宽度</span></span><br><span class="line">            ans = max(ans, cur_w);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;cur_w; i++) &#123;</span><br><span class="line">                <span class="keyword">auto</span> p = Q.front();</span><br><span class="line">                Q.pop();</span><br><span class="line">                <span class="keyword">if</span> (p-&gt;left)</span><br><span class="line">                    Q.push(p-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (p-&gt;right)</span><br><span class="line">                    Q.push(p-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>除了这些偏理论的知识，它还有面试中常出现的数据结构和算法方面的总结，同时给出了编程实现，例如，动态规划、双指针、排列组合、二叉树、链表、堆、栈等，此外，Algorithm_Interview_Notes-Chinese吸引人的地方是在这些算法方面不是单纯的给出编程实现，还是列出实现的步骤和思路，非常有助于理解。</p><hr><blockquote><p>更多精彩内容请关注公众号【平凡而诗意】~</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/08/03/erNoKH.png&quot; alt=&quot;erNoKH.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;秋季招聘一般集中在每年的9月-10月份，有早一些的城市或者公司会在8月就开始进入校园，开启招聘，
    
    </summary>
    
      <category term="学习资源" scheme="https://jackpopc.github.io/categories/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90/"/>
    
    
      <category term="机器学习" scheme="https://jackpopc.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="Github" scheme="https://jackpopc.github.io/tags/Github/"/>
    
      <category term="资源" scheme="https://jackpopc.github.io/tags/%E8%B5%84%E6%BA%90/"/>
    
      <category term="算法" scheme="https://jackpopc.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
