<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>平凡而诗意</title>
  
  <subtitle>Jackpop</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://jackpopc.github.io/"/>
  <updated>2019-11-16T13:45:24.192Z</updated>
  <id>https://jackpopc.github.io/</id>
  
  <author>
    <name>Jackpop</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>效率工具 | 一款基于深度学习的代码自动补全神器</title>
    <link href="https://jackpopc.github.io/2019/11/16/tabnine/"/>
    <id>https://jackpopc.github.io/2019/11/16/tabnine/</id>
    <published>2019-11-16T13:36:00.000Z</published>
    <updated>2019-11-16T13:45:24.192Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h2><p><strong>代码补全</strong>对于大多数开发人员来说是至关重要的，它可以有效的提高开发效率、减少拼写错误和输入代码量。我们使用的大多数开发工具都自带补全功能，或者可以通过安装插件具备补全功能。<a id="more"></a>但是，以往的代码补全功能主要基于语言本身的内置函数和上下文信息进行补全，而在候选项重要程度、代码块补全方面却不理想。与其说我们常用的自动补全工具的价值在<strong>补全</strong>方面，我更倾向于认为它的价值体现在<strong>提示</strong>。</p><p>近几年随着深度学习的抬头、火热，深度神经网络在学术领域有着很多最为先进的算法，并且在很多商业领域都得到应用。因此，有想法的研究者也尝试把深度学习引入开发工具中。</p><p>在之前的一篇文章中，我介绍了一款<strong>人工智能自动补全工具Kite</strong>，它在自动补全效率、文档阅读等方面的确要优于绝大多数自动补全工具，而且配置简单。本文将介绍另外一款基于深度学习的自动补全工具—<strong>TabNine</strong>，虽然同是基于人工智能的开发工具，但是它们却有各自的侧重点。下面我就先介绍一下Kite与TabNine的区别，然后详细介绍一下TabNine的特点，各位根据自己的偏好选择其中一款进行配置。</p><h2 id="Kite与TabNine"><a href="#Kite与TabNine" class="headerlink" title="Kite与TabNine"></a><strong>Kite与TabNine</strong></h2><p>Kite与TabNine都是优秀的、基于人工智能的代码自动补全工具，相对于大多数自动补全插件，它都能让人感到非常惊艳，但是二者都有各自的侧重点，下面就来说一下Kite与TabNine各自的优点和缺点。</p><p><strong>Kite</strong></p><p>Kite更加倚重于<strong>预先存在的知识库</strong>，它是在预先存在的知识库上进行学习得到的补全经验，因此，不需要在开发过程中训练和学习，因此，它具备如下优点：</p><ul><li>补全速度快</li><li>代码块补全功能强大</li><li>简洁强大的文档阅读功能</li></ul><p>以<strong>代码块补全功能强大</strong>为例，来说一下Kite的特点，对于大多数补全工具，包括TabNine在内，主要是补全接下来要输入的<strong>字符串</strong>，而Kite不仅可以补全字符串，还可以补全代码库。举个例子，我们要导入numpy模块，对于大多数补全工具，我们输入numpy的几个字母后，它会联想出完整的numpy，但是对于Kite，当输入import num，它会根据知识库中大多数使用者的习惯直接补全import numpy as np。同样，当我们导入matplotlib中pyplot时，当我们输入from matplotlib，它会补全from matplotlib import pyplot as plt，这样显然更加高效，节省代码量。</p><p>没有哪个工具是完美无暇的，Kite也有缺点，我认为Kite是非常优秀的，甚至Python之父都对它赞不绝口，但是它也有3个缺点让我有点无法忍受，</p><ul><li>方案偏“重”</li><li>支持语言单一</li><li>占用资源</li></ul><p>首先说一下第一点，方案偏“重”。</p><p>对于大多数补全工具，它们只是一个插件，比较轻量化，而Kite相对较重，需要预先下载、安装一个200M+的软件，除了在电脑上安装Kite之外，还需要在对应的编辑器/IDE安全Kite的插件，另外，每次使用Kite自动补全之前需要把Kite打开。所以，这一系列的配置、使用过程相对较“重”。</p><p>其次说一下支持语言单一，Kite定位是一款Python自动补全工具，因此在很多特色方面都是针对Python进行优化，因此，支持语言相对单一。</p><p>最后说一下占用资源，虽然Kite内存占用情况远远比不上Pycharm、IDEA这些臃肿的开发工具，但是在win10下也要占用将近400M的内存资源，对于大多数工具相对较高，如果电脑配置偏低，打开Kite会使得系统较为卡顿。</p><p><strong>TabNine</strong></p><p><img src="https://s2.ax1x.com/2019/11/16/MBJkuj.md.png" alt></p><p>和Kite不同，首先，TabNine是基于开发者过去的使用习惯进行补全，而不是预先的知识库，因此，当项目较小或者正在向其中添加新库时，它的效果不如Kite。当然，这是二者思想上的差异，TabNine之所以成功，自然有它的优点，</p><ul><li>轻量化</li><li>配置简单</li><li>支持语言丰富</li><li>能够给出补全项的概率和地址</li></ul><p>以<strong>给出补全项的概率和地址</strong>为例来说明一下TabNine的优点，TabNine在自动补全时会给出每个候选项的概率，并且按照概率大小进行排序，此外，会给出候选项的来源及地址，这样更加方便查询和阅读。</p><p>另外，Kite在语言支持方面更加具有针对性，主要针对Python的自动补全，而TabNine支持的编程语言更加丰富，而不是针对某一特定语言。</p><p>TabNine的缺点也非常明显，</p><ul><li>补全速度慢</li><li>依赖语言服务</li></ul><p>首先说一下<strong>补全速度慢</strong>，TabNine在使用过程中需要大量的计算资源进行学习，因此它会带来高延迟。因此TabNine在专业版和企业版中提供了TabNine Cloud服务，提供GPU计算资源，当然，这都是需要付费的。</p><p>其次说一下<strong>依赖语言引擎</strong>，TabNine默认情况是关闭<strong>语义补全</strong>的，如果要开启语义补全需要安装不同编程语言对应的服务，例如Python需要安装python-language-server，每一种编程语言都需要配置对应的服务，可以选择繁琐的手动配置，针对这一点TabNine也提供了较好的解决方案，在编辑器中输入TabNine::sem，它会自动开启<strong>语义补全</strong>在开启过程中会按照对应语言的服务。</p><h2 id="TabNine"><a href="#TabNine" class="headerlink" title="TabNine"></a><strong>TabNine</strong></h2><p>前面概括性的介绍了一下TabNine与Kite各自的优缺点，这里我就详细的介绍一下TabNine强大之处与原理。</p><p><strong>优势</strong></p><p>前面已经简单的介绍了TabNine的优点，</p><ul><li>轻量化</li><li>配置简单</li><li>支持语言丰富</li><li>能够给出补全项的概率和地址</li></ul><p>这些非量化的评价指标不够直观，从另外一个可量化的指标来说一下TabNine的强大之处，</p><ul><li>支持22种编程语言</li><li>支持7类编辑器</li></ul><p><strong>支持的编程语言</strong></p><p>TabNine支持Python, JavaScript, Java, C++, C, PHP, Go, C#, Ruby, Objective-C, Rust, Swift, TypeScript, Haskell, OCaml, Scala, Kotlin, Perl, SQL, HTML, CSS和Bash这22种编程语言。</p><p><strong>支持的编辑器</strong></p><p>首先要注意，我前面所说的是<strong>7类</strong>编辑器，而不是<strong>7款</strong>，它支持vs code、IntelliJ、Sublime、Vim、Emacs、Atom、Jupyter Notebook共7类编辑器。</p><p>其中IntelliJ是一个系列，其中包括IDEA、Pycharm、Android Studio等。</p><p>Vim包括Vim(Deopleto)、Vim(Coc)。</p><p><strong>原理</strong></p><p>TabNine是基于OpenAI的GPT-2模型，在GitHub上200万个文件上进行训练得出，它的训练目标是通过之前给出的标记预测接下来的标记(token)，为了实现这个目标，它学习了复杂的行为，例如动态类型语言的推断。</p><p>然后说一下GPT-2模型，它是一个在自然语言领域名气不亚于BERT的网络模型，它使用了Transformer网络作为基础，这个模型最初是用于解决自然语言处理问题(NLP)，尽管纯粹的自然语言和代码补全有很多不同之处，但是自然语言和代码补全在语义上还是有一些可借鉴的地方，例如对于英语的理解。TabNine就利用这一点用于代码补全中函数名、参数、返回类型等方面的推断。</p><h2 id="TabNine配置"><a href="#TabNine配置" class="headerlink" title="TabNine配置"></a><strong>TabNine配置</strong></h2><p>TabNine配置相对于Kite较为简单，只需要在简单的几步即可以完成。需要再重复一遍的是，TabNine默认是不开启语言补全的，如果要开启语义补全需要安装配置对应语言的服务、引擎，当然，这对于TabNine也很简单，只需要在编辑器输入TabNine::sem即可，TabNine支持vs code、IntelliJ、Sublime、Vim、Emacs、Atom、Jupyter Notebook共7类编辑器，我在这里就挑选几个使用较多的编辑器/IDE讲解一下。</p><p><strong>vs code</strong></p><p><strong>方式一：手动安装</strong></p><p><img src="https://pic4.zhimg.com/v2-6fc986f33e07587fb25e344712c45ab3_b.gif" alt="img"></p><ol><li>打开vs code</li><li>点击插件管理</li><li>搜索tabnine</li><li>点击安装</li></ol><p>这种方式比较简洁明了，首推这一种方法。</p><p><strong>方式2：命令安装</strong></p><ol><li>打开vs code</li><li>快捷键Ctrl+P</li><li>输入ext install TabNine.tabnine-vscode</li><li>确认</li></ol><p><strong>IntelliJ Platform</strong></p><ol><li>打开设置</li><li>找到Plugins</li><li>在marketplace搜索TabNine安装</li></ol><p><strong>Sublime Text</strong></p><p><img src="https://s2.ax1x.com/2019/11/16/MBY9d1.gif" alt></p><ol><li>快捷键Ctrl+Shift+P</li><li>输入Install Package</li><li>选择Package Control:Install Package</li><li>搜索TabNine确认</li></ol><p><strong>Vim</strong></p><p><strong>方式一：Vundle</strong></p><ol><li>首选需要配置插件管理器Vundle</li><li>在.vimrc中添加Plugin ‘zxqfl/tabnine-vim’</li><li>随便打开一个vim，输入:PluginInstall</li></ol><p><strong>方式二：Git</strong></p><ol><li>克隆项目git clone —depth 1 <a href="https://github.com/zxqfl/tabnine-vim" target="_blank" rel="noopener">https://github.com/zxqfl/tabnine-vim</a></li><li>把set rtp+=~/tabnine-vim添加到.vimrc（~/tabnine-vim是克隆到本地的路径，需要根据自己的路径修改）</li></ol><p><strong>TabNine命令配置</strong></p><p>就如同前面提到的，如果没有开启语义补全，需要在编辑器中输入命令开启语义补全，TabNine支持一些命令配置方式，主要有如下几个，</p><ol><li>TabNine::sem开启语义补全</li><li>TabNine::no_sem关闭语义补全</li><li>TabNine::config打开配置页面</li><li>TabNine::version查看版本信息</li></ol><hr><h2 id="福利"><a href="#福利" class="headerlink" title="福利"></a>福利</h2><p><img src="https://pic1.zhimg.com/v2-51aa7ecfa8e21a346566b1ffe4403828_b.png" alt="img"></p><blockquote><p>我在公众号分享了Python、机器学习、计算机视觉、强化学习等领域相关的学习资源、电子文档。此外，还整理了一些高效的实用工具，如果需要可以关注公众号【平凡而诗意】，回复相应关键字获取~</p></blockquote><h2 id="作品精选"><a href="#作品精选" class="headerlink" title="作品精选"></a>作品精选</h2><p><a href="https://zhuanlan.zhihu.com/p/79671074" target="_blank" rel="noopener">Jackpop：目录 | 精选CV、Python等系列教程</a></p><p><a href="https://zhuanlan.zhihu.com/p/84590108" target="_blank" rel="noopener">Jackpop：大数据处理 | Spark&amp;HDFS集群配置及基本使用</a></p><p><a href="https://zhuanlan.zhihu.com/p/86349140" target="_blank" rel="noopener">Jackpop：实用工具 | 推荐3款令人惊艳的截图工具</a></p><p><a href="https://zhuanlan.zhihu.com/p/89172998" target="_blank" rel="noopener">Jackpop：强烈推荐 | 这将会成为一个优质的github项目</a></p><p><a href="https://www.zhihu.com/question/339417870/answer/869171272" target="_blank" rel="noopener">Jackpop：计算机小白如何开始机器学习的学习，有入门课程推荐吗?</a></p><p><a href="https://www.zhihu.com/question/27608145/answer/870130099" target="_blank" rel="noopener">Jackpop：C盘快满了，该如何清理？</a></p><p><a href="https://www.zhihu.com/question/334587481/answer/875038400" target="_blank" rel="noopener">Jackpop：2019 年双十一有哪些值得购买的东西？</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;代码补全&lt;/strong&gt;对于大多数开发人员来说是至关重要的，它可以有效的提高开发效率、减少拼写错误和输入代码量。我们使用的大多数开发工具都自带补全功能，或者可以通过安装插件具备补全功能。
    
    </summary>
    
      <category term="开发工具" scheme="https://jackpopc.github.io/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="工具" scheme="https://jackpopc.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="实用" scheme="https://jackpopc.github.io/tags/%E5%AE%9E%E7%94%A8/"/>
    
      <category term="插件" scheme="https://jackpopc.github.io/tags/%E6%8F%92%E4%BB%B6/"/>
    
      <category term="开发工具" scheme="https://jackpopc.github.io/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>【进阶Python】第八讲：代理模式</title>
    <link href="https://jackpopc.github.io/2019/11/15/proxy/"/>
    <id>https://jackpopc.github.io/2019/11/15/proxy/</id>
    <published>2019-11-15T13:46:51.000Z</published>
    <updated>2019-11-15T15:59:51.079Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>学会使用一门编程语言来完成一项功能非常容易，尤其是Python、Go这些脚本语言，也许对于有一定编程基础的同学而言只需要一周或者一天时间。但是如果要想让写的代码变得更加简洁易读、执行效率更高、可扩展性更好，<a id="more"></a>那么就需要超越编程语言之外的知识，这就是<b>设计模式</b>。</p><p>在前面文章中，我介绍了一种比较常用的一种设计模式：<b>单例模式</b>。其实软件设计模式有非常多，代理模式、桥接模式、适配器、享元、工厂模式等。这些设计模式有的用的较多，有的在特定场景下才会用到，我会挑选个别应用场景较多的讲解一下。本文的要讲的就是<b>代理模式</b>，话不多说，下面开始代理模式的介绍及在Python中代理模式的实现方式。</p><h1 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h1><p><img src="https://s2.ax1x.com/2019/11/15/Mwki5V.png" alt="Mwki5V.png"></p><p>提到<b>代理</b>这个词汇，应该很多人都不陌生，甚至会有很多人用过。在编程语言之外，我们所接触的<b>代理</b>主要是在网络通信方面会涉及。当我们的网络不能直接与目标主机进行通信时，例如我们不能直接访问Google、Facebook，我们可以通过搭建代理服务器的方式实现我们所用的网络与目标主机之间的通信，这就是网络中代理的概念。用一句话来概括就是：<b>允许一个网络终端（一般为客户端）通过这个服务与另一个网络终端（一般为服务器）进行非直接的连接</b>。</p><p>之所以开始便讲解网络代理，是因为代理模式和网络代理有着很多相似的特点，而我们日常中接触更多的是网络代理，这样类比一下能够有助于大家的理解。</p><p>在<b>代理模式</b>中，我们作为访问者就相当于编程语言中调用的实体，目标主机就相当于被调用的实体，它们二者直接不产生直接联系，而是通过中间的代理服务器(代理实体)来实现二者的间接联系。</p><p><b>代理模式的作用</b></p><p>一个概念的产生，自然有它的价值存在，代理模式也是这样，简而言之，概括代理模式的作用如下：</p><blockquote><p>当我们访问一个实体考虑到安全等因素不方便时，代理可以为这个实体提供一个替代者，来控制它的访问权限和访问内容。</p></blockquote><p>通俗的来讲，代理模式就如同一个”过滤器”，它<b>不实现具体功能</b>，具体功能由被调用的实体来实现，代理实现的是对调用的控制功能，它能够允许或者拒绝调用实体对被调用实体的访问。</p><p>举个例子，我们访问一个具备敏感数据时，需要提供一个验证信息，比如，用户名、密码，代理模式完成的是更具访问者提供的用户名和密码来判断是否允许它进一步调用实体的功能。</p><p><b>代理模式的适用场景</b><br>一个设计模式，只有当它有了应用场景，它才具备存在的价值。代理模式有很多可以使用的场景，主要分为如下几类：</p><blockquote><p><b>远程代理</b>：为一个对象的地址空间提供局部代表。</p><p><b>虚拟代理</b>：根据需要来创建开销较大的对象。</p><p><b>保护代理</b>：用于对象应该具有不同访问权限的场景，控制对原始对象的访问。</p><p><b>智能指引</b>：取代简单的指针，它在访问对象时执行一些附加操作。</p><p>— 引自《设计模式：可复用面向对象软件的基础》</p></blockquote><h1 id="Python代理模式"><a href="#Python代理模式" class="headerlink" title="Python代理模式"></a>Python代理模式</h1><p><img src="https://s2.ax1x.com/2019/11/15/MwkkCT.png" alt="MwkkCT.png"></p><p>代理模式在Java、C++中使用较多，可以用于虚拟代理和远程代理。由于Python这门语言相对简单，在企业中也常用于算法模块的验证，在一些大型系统很少会采用Python这门语言，因此，在软件设计模式方面考虑相对较少。但是，我认为，养成一个良好的软件设计思维，对日常开发和维护也具有非常多的好处，能够让开发效率更高，能够让代码可靠性更高，能够让后期维护成本更低。</p><p>在开发代码实现Python代理模式之前，我们首先来设定一个应用场景，这样才能够更加体现它的价值，同时让各位更加容易理解。</p><p><b>场景设定</b></p><p>假如，我们现在想了解一个班级的情况，主要包括两点：人数和学习成绩。</p><p>当我们想要了解这个班级的人数时，这个数据不敏感，不涉及隐私，因此可以直接访问。但是，当我们想查询特定某个学生成绩时，这样就涉及隐私信息，需要提供对应学生的姓名(user_name)，访问的密码(password)。</p><p><b>需求分析</b></p><p>针对这个场景，我们可以先分析一下，访问者就如同上述图中的客户端(Client)，获取班级人数、成绩这些实际的功能是由实体对象实现，也就是图中的RealSubject。Client与RealSubject之间不能直接通信，它们只能通过中间的代理(Proxy)进行通信。而Proxy主要的职责就相当于一个控制开关，如果Client要访问班级人数，Proxy会检查这项数据所需要的权限，然后发现班级人数是非敏感数据可以直接访问，那么它会调用实体对象中的方法，返回结果。如果Client要访问某个学生的成绩，Proxy会检查这项数据是敏感数据，需要提供用户名和密码，如果Client提供的正确，则允许访问，否则拒绝访问。</p><p><b>编程实践</b></p><p>第一步，我们自定义一个异常处理类，当我们要访问的用户不在班级成绩列表时，则抛出异常，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NotFindError</span><span class="params">(Exception)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, msg)</span>:</span></span><br><span class="line">        self.msg = msg</span><br></pre></td></tr></table></figure><p>第二步，实现实体类，实体类实现了具体的功能，针对这个场景就两个方法：获取班级人数、获取指定学生的成绩，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RealSubject</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.score = &#123;</span><br><span class="line">            <span class="string">"张三"</span>: <span class="number">90</span>,</span><br><span class="line">            <span class="string">"李四"</span>: <span class="number">59</span>,</span><br><span class="line">            <span class="string">"王二"</span>: <span class="number">61</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">num_students</span><span class="params">(self)</span>:</span></span><br><span class="line">        num = len(self.score.keys())</span><br><span class="line">        print(<span class="string">"The number of students is &#123;num&#125;"</span>.format(num=num))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_score</span><span class="params">(self, user_name)</span>:</span></span><br><span class="line">        _score = self.score.get(user_name)</span><br><span class="line">        print(<span class="string">"The score of &#123;user&#125; is &#123;score&#125;"</span>.format(user=user_name,</span><br><span class="line">                                                      score=_score))</span><br></pre></td></tr></table></figure><p>第三步，实现代理(Proxy)，它通过对应功能的访问权限来确定是<b>接受</b>这个访问，还是<b>拒绝</b>这个访问，</p><blockquote><p>注意：在这个示例中，我把密码直接写在初始化方法中，实际的项目是不允许这样的，不能把密码写在代码中，另外也不能使用明文密码，需要使用加密工具对明文密码进行加密。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Proxy</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.default_passwd = <span class="string">"9l0skjlsa"</span></span><br><span class="line">        self.real_subject = RealSubject()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">num_students</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.real_subject.num_students()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_score</span><span class="params">(self, user_name)</span>:</span></span><br><span class="line">        print(<span class="string">"You are visiting &#123;&#125; score ..."</span>.format(user_name))</span><br><span class="line">        passwd = input(<span class="string">"Please input password : "</span>)</span><br><span class="line">        <span class="keyword">if</span> passwd == self.default_passwd:</span><br><span class="line">            <span class="keyword">if</span> user_name <span class="keyword">in</span> self.real_subject.score.keys():</span><br><span class="line">                <span class="keyword">return</span> self.real_subject.get_score(user_name)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">raise</span> NotFindError(<span class="string">"The student you are visiting not found."</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">"The password you provided is wrong!"</span>)</span><br></pre></td></tr></table></figure><p>然后就是实现Client来调用对应的功能，为了测试上述代理的功能，使用3个测试样例，</p><ol><li>密码错误，用户名正确；</li><li>密码正确，用户名错误；</li><li>密码正确，用户名正确；</li></ol><p><b>密码错误，用户名正确</b></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">client</span><span class="params">()</span>:</span></span><br><span class="line">    proxy = Proxy()</span><br><span class="line">    proxy.get_score(<span class="string">"张三"</span>)</span><br><span class="line">    </span><br><span class="line">client()</span><br><span class="line"></span><br><span class="line"><span class="comment"># shell</span></span><br><span class="line">You are visiting 张三 score ...</span><br><span class="line">Please input password : kdksla</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">ValueError: The password you provided <span class="keyword">is</span> wrong!</span><br></pre></td></tr></table></figure><p><b>密码正确，用户名错误</b></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">client</span><span class="params">()</span>:</span></span><br><span class="line">    proxy = Proxy()</span><br><span class="line">    proxy.get_score(<span class="string">"李三"</span>)</span><br><span class="line">    </span><br><span class="line">client()</span><br><span class="line"></span><br><span class="line"><span class="comment"># shell</span></span><br><span class="line">You are visiting 张三 score ...</span><br><span class="line">Please input password : <span class="number">9l</span>0skjlsa</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">NotFindError: The student you are visiting <span class="keyword">not</span> found.</span><br></pre></td></tr></table></figure><p><b>密码正确，用户名正确</b></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">client</span><span class="params">()</span>:</span></span><br><span class="line">    proxy = Proxy()</span><br><span class="line">    proxy.get_score(<span class="string">"李四"</span>)</span><br><span class="line">    </span><br><span class="line">client()</span><br><span class="line"></span><br><span class="line"><span class="comment"># shell</span></span><br><span class="line">You are visiting 张三 score ...</span><br><span class="line">Please input password : <span class="number">9l</span>0skjlsa</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">The score of 李四 <span class="keyword">is</span> <span class="number">59</span></span><br></pre></td></tr></table></figure><p>本讲完整代码如下，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NotFindError</span><span class="params">(Exception)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, msg)</span>:</span></span><br><span class="line">        self.msg = msg</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RealSubject</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.score = &#123;</span><br><span class="line">            <span class="string">"张三"</span>: <span class="number">90</span>,</span><br><span class="line">            <span class="string">"李四"</span>: <span class="number">59</span>,</span><br><span class="line">            <span class="string">"王二"</span>: <span class="number">61</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">num_students</span><span class="params">(self)</span>:</span></span><br><span class="line">        num = len(self.score.keys())</span><br><span class="line">        print(<span class="string">"The number of students is &#123;num&#125;"</span>.format(num=num))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_score</span><span class="params">(self, user_name)</span>:</span></span><br><span class="line">        _score = self.score.get(user_name)</span><br><span class="line">        print(<span class="string">"The score of &#123;user&#125; is &#123;score&#125;"</span>.format(user=user_name,</span><br><span class="line">                                                      score=_score))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Proxy</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.default_passwd = <span class="string">"9l0skjlsa"</span></span><br><span class="line">        self.real_subject = RealSubject()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">num_students</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.real_subject.num_students()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_score</span><span class="params">(self, user_name)</span>:</span></span><br><span class="line">        print(<span class="string">"You are visiting &#123;&#125; score ..."</span>.format(user_name))</span><br><span class="line">        passwd = input(<span class="string">"Please input password : "</span>)</span><br><span class="line">        <span class="keyword">if</span> passwd == self.default_passwd:</span><br><span class="line">            <span class="keyword">if</span> user_name <span class="keyword">in</span> self.real_subject.score.keys():</span><br><span class="line">                <span class="keyword">return</span> self.real_subject.get_score(user_name)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">raise</span> NotFindError(<span class="string">"The student you are visiting not found."</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">"The password you provided is wrong!"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">client</span><span class="params">()</span>:</span></span><br><span class="line">    proxy = Proxy()</span><br><span class="line">    proxy.get_score(<span class="string">"张三"</span>)</span><br><span class="line"></span><br><span class="line">client()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;学会使用一门编程语言来完成一项功能非常容易，尤其是Python、Go这些脚本语言，也许对于有一定编程基础的同学而言只需要一周或者一天时间。但是如果要想让写的代码变得更加简洁易读、执行效率更高、可扩展性更好，
    
    </summary>
    
      <category term="Python" scheme="https://jackpopc.github.io/categories/Python/"/>
    
    
      <category term="编程" scheme="https://jackpopc.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Python" scheme="https://jackpopc.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>实用工具 | 让动画从1080p秒变4k</title>
    <link href="https://jackpopc.github.io/2019/11/07/anime4k/"/>
    <id>https://jackpopc.github.io/2019/11/07/anime4k/</id>
    <published>2019-11-07T13:32:59.000Z</published>
    <updated>2019-11-07T15:27:30.809Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><img src="C:\Users\Li\Desktop\4b90f603738da977ffce8a29b851f8198718e3cb.jpg" alt="4b90f603738da977ffce8a29b851f8198718e3cb"></p><p>视频是我们日常生活中经常接触到的一种媒体形式，电影、电视剧、短视频、动画等。其中动画占据着我们娱乐生活中的一个很大比重，以我个人为例，偶尔会去电影院看一下电影，但是大多数都是通过下载到电脑的方式进行观看。我们接触的动画大多数为720p，再清晰一些的有1080p，而至于4k，这个概念似乎只存在于新闻里，却从未接触过，本文就来介绍一个强大的开源工具—Anime4k，能够<b>实时</b>、<b>高质量</b>的放大动画视频，能够轻松使得1080p变成4k。下面就来介绍一下这个优质开源的项目。</p><h1 id="Anime4k"><a href="#Anime4k" class="headerlink" title="Anime4k"></a>Anime4k</h1><p>图像放大在学术领域研究的也很多，尤其是最近几年人工智能在图像处理领域的广泛应用，很多研究者利用机器学习、深度学习进行视频图像放大，虽然深度学习方法在放大效果方面取得了一些成绩，但是在速度方面并不是很理想，我们都知道，实时视频流对速度要求也很高，如果每一帧放大速度太慢，那样会严重影响观感，即便是清晰度方面得到了提升，但是也无法使用。</p><p>本文介绍的Anime4k没有使用深度学习这些基于训练的方法，但是它却能够同时实现图像放大的实时及高质量。以往也有一些动画放大算法，例如，</p><ul><li>NGU：6ms</li><li>Waifu2x：1s</li></ul><p>而本文介绍的Anime4k把一副1080p的图像放大只2160p只需要3ms左右(Vega 64 GPU平台)。</p><p>Anime4k的实时和高质量使得它在保证图像清晰的情况下保证视频的连贯性，能够完全满足我们日常观看动漫的需求。</p><p>由于本文主要是介绍这款开源工具的配置及使用，因此不详细展开Anime4k的实现过程，如果感兴趣可以访问Anime4k的项目地址。</p><p><a href="https://github.com/bloc97/Anime4K" target="_blank" rel="noopener">https://github.com/bloc97/Anime4K</a></p><p>目前Anime4k可以支持多款主流、强大的视频播放器，只需要配置一下就可以让播放器具备实时图像放大功能，能够高效的提升动漫的清晰度，Anime4k支持的播放器如下，</p><ul><li>PotPlayer</li><li>MPC-BE</li><li>MPC-HC</li><li>MPV</li><li>madVR</li></ul><p>上述5款播放器都是开源，本文就拿我个人认为比较不错的两款播放器来介绍一下如何配置Anime4k这款工具。</p><h1 id="PotPlayer"><a href="#PotPlayer" class="headerlink" title="PotPlayer"></a>PotPlayer</h1><p>PotPlayer是一款开源、简洁且倍受欢迎的离线视频播放器，它不仅功能强大，支持丰富的定制化功能，而且使用简单，没有广告，这相对于大多数国产视频播放器要良心很多，因此，我在这里也推荐大家尝试一下这款播放器。</p><p>话不多说，现在开始介绍PotPlayer+Anime4k的配置过程。</p><p><b>1. 下载安装PotPlayer</b></p><p>可以访问链接<a href="http://www.potplayer.org/下载PotPlayer安装包，然后双击安装即可。" target="_blank" rel="noopener">http://www.potplayer.org/下载PotPlayer安装包，然后双击安装即可。</a></p><p><img src="C:\Users\Li\AppData\Roaming\Typora\typora-user-images\1573137178313.png" alt="1573137178313"></p><p><b>2. 下载Anime4k HLSL文件</b></p><p>打开链接，<a href="https://github.com/bloc97/Anime4K/releases" target="_blank" rel="noopener">https://github.com/bloc97/Anime4K/releases</a></p><p><img src="C:\Users\Li\AppData\Roaming\Typora\typora-user-images\1573137255696.png" alt="1573137255696"></p><p>选择<b>Anime4K_HLSL.zip</b>下载。</p><p><b>3. 解压并复制到指定文件夹</b></p><p>解压第2步下载的压缩包，把其中HLSL文件移动到PotPlayer安装目录下<b>PxShader</b>文件夹里，如果安装PotPlayer没有修改安装路径的话，默认位置在<b>C:\Program Files (x86)\DAUM\PotPlayer\PxShader</b>。</p><p><b>4. 配置PotPlayer</b></p><p>打开PotPlayer播放器，依次点选如下选项，</p><ul><li>视频</li><li>像素着色</li><li>调整尺寸后的着色集</li></ul><p><img src="C:\Users\Li\AppData\Roaming\Typora\typora-user-images\1573137692290.png" alt="1573137692290"></p><p>一定要注意，是调整后的着色期，不要选择调整尺寸前的着色集。</p><p>然后点击<b>组合编辑</b>，添加如下4个HLSL文件，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-Anime4K_ComputeLum  </span><br><span class="line">-Anime4K_Push  </span><br><span class="line">-Anime4K_ComputeGradient  </span><br><span class="line">-Anime4K_PushGrad_Weak</span><br></pre></td></tr></table></figure><blockquote><p>如果原图像尺寸小于或等于1080p则选择Anime4K_PushGrad_Weak ，如果大于1080p，则选择Anime4K_PushGrad。</p></blockquote><p>如果找不到这几个选择可以重启PotPlayer，</p><p><img src="C:\Users\Li\AppData\Roaming\Typora\typora-user-images\1573137940374.png" alt="1573137940374"></p><p>然后依次点击<b>视频-&gt;像素着色-&gt;调整尺寸后的着色集-&gt;组合</b>即可，</p><p><img src="C:\Users\Li\AppData\Roaming\Typora\typora-user-images\1573138012844.png" alt="1573138012844"></p><h1 id="MPC-BE"><a href="#MPC-BE" class="headerlink" title="MPC-BE"></a>MPC-BE</h1><p>MPC-BE是一款开源简洁的视频播放器，内容占用比PotPlayer还要小。MPC-BE+Anime4k的配置方式和PotPlayer非常相似，所以，有的过程就简略的介绍一下。下面就来看一下它的配置过程。</p><p><b>1. 下载安装MPC-BE</b></p><p><a href="https://sourceforge.net/projects/mpcbe/" target="_blank" rel="noopener">https://sourceforge.net/projects/mpcbe/</a></p><p><b>2. 下载Anime4k HLSL文件</b></p><p>打开链接，<a href="https://github.com/bloc97/Anime4K/releases" target="_blank" rel="noopener">https://github.com/bloc97/Anime4K/releases</a></p><p><b>3. 解压复制到指定文件夹</b></p><p>把上一步下载HLSL压缩包解压，放到下面路径，</p><p><b>C:\Users\YourUserName\AppData\Roaming\MPC-BE\Shaders</b></p><p><b>4. 配置MPC-BE</b></p><p>这一步和PotPlayer配置不同，MPC-BE配置需要依次选择如下选择，</p><ul><li>播放</li><li>着色器</li><li>选择着色器</li></ul><p>下面要做的和PotPlayer类似，添加HLSL文件，</p><p><img src="C:\Users\Li\AppData\Roaming\Typora\typora-user-images\1573139385705.png" alt="1573139385705"></p><p><img src="C:\Users\Li\AppData\Roaming\Typora\typora-user-images\1573139300581.png" alt="1573139300581"></p><p><img src="C:\Users\Li\AppData\Roaming\Typora\typora-user-images\1573138921146.png" alt="1573138921146"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;C:\Users\Li\Desktop\4b90f603738da977ffce8a29b851f8198718e3cb
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>【进阶Python】第七讲：接口与抽象基类</title>
    <link href="https://jackpopc.github.io/2019/10/27/abstract/"/>
    <id>https://jackpopc.github.io/2019/10/27/abstract/</id>
    <published>2019-10-27T11:10:52.000Z</published>
    <updated>2019-10-27T13:22:05.699Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>抽象基类(abstract base class,ABC)，提到这个概念应该会马上联想到面向对象、继承。作为继承的一种，它拥有继承中代码共享、提高代码的重用性等优点。例如，下面示例，<a id="more"></a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eat</span><span class="params">(self, kind)</span>:</span></span><br><span class="line">        print(<span class="string">"&#123;&#125; eat food...."</span>.format(kind))</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span><span class="params">(Animal)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span><span class="params">(Animal)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">    </span><br><span class="line">dog = Dog()</span><br><span class="line">cat = Cat()</span><br><span class="line">dog.eat(<span class="string">"dog"</span>)</span><br><span class="line">cat.eat(<span class="string">"cat"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">dog eat food....</span><br><span class="line">cat eat food....</span><br></pre></td></tr></table></figure><p>狗(Dog)和猫(Cat)都属于动物(Animal)，它们有很多类似的属性和动作，我们可以在父类中实现这些方法，在子类中直接继承或者重载父类中的方法，这样减少了代码的重复性，提高了代码的共享能力。</p><p>作为继承的一种，抽象基类有用继承的上述这些优点，但是它与普通的继承也有不同之处，</p><ul><li>抽象基类不能实例化</li><li>子类需要实现基类指定的抽象方法</li></ul><p>看到这里应该会意识到，抽象基类有一种<b>接口</b>的感觉，没错，抽象基类的出现主要是功能就是类似于Java等编程语言中的接口。但是需要明确一点，Python语言中没有interface这个概念，只是这是一种约定俗成的编程规范，就如同Python也没有真实意义上的私有变量，我们在编程中可以规范的使用下划线来表示某个变量为私有变量。</p><p>尽管Python中没有接口这个关键字，但是抽象基类实现的功能主要围绕接口在展开，因此，首先类比Java来阐述一下编程语言中接口的概念，然后介绍一下Python中如何实现抽象基类。</p><h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><p>接口(Interface)是对象公开方法的一种集合，在Java中通常以interface关键字来定义，接口虽然实现过程中和<b>类</b>相似，但是却具有不同的概念。具体而言，类与接口主要有以下几点不同之处：</p><ul><li>类实现了对象的属性和方法，而接口指定了使用该接口需要实现哪些方法</li><li>类可以实例化，而接口不可以被实例化</li><li>类中的方法可以是实现，接口中的方法都是抽象方法</li></ul><blockquote><p><b>抽象方法</b>：抽象方法的概念是父类中只负责声明该方法，但不具体实现这个方法，实现部分由继承该类的子类负责实现。</p></blockquote><p>如果觉得上述描述有点云里雾里、对接口的概念依然不是非常清楚，不妨来试想一个场景：当你开发一个项目或者服务，你需要给上下游的组件提供接口，让别人来调用你的程序接口(Application Programming Interface，API)，上下游组件该怎么样才能达到想要的目的和你的组件无缝衔接？需要通过按照你接口中规定的抽象方法来实现，例如，你提供一个访问网络请求的接口，你不会去实现host、username、password的注册和发送请求，这些需要调用的用户去实现，你只需要规定：“调用者必须实现指定方法才能实现调用”即可。</p><h1 id="抽象基类"><a href="#抽象基类" class="headerlink" title="抽象基类"></a>抽象基类</h1><p>虽然Python中抽象基类和接口概念非常相近，但是它们还是有一些不同之处，例如，</p><ul><li>接口需要被实现的子类完成接口中指定的所有方法，而抽象基类不是，抽象基类则没有这么严格的要求</li><li>接口需要所有方法都是抽象方法，而抽象基类中有抽象方法，也有自己实现的方法</li></ul><p>正是因为抽象基类和接口的不同之处使得接口之所以称为接口、抽象基类之所以称为抽象基类。</p><p><b>为什么使用抽象基类？</b></p><p>前面铺垫了这么多，话说回来，为什么需要抽象基类？</p><p>存在的即是合理的，抽象基类的存在自然有它的价值。当你学会一种编程语言的语法时，你可以轻松的完成一项功能的开发，但是如果希望把代码完成的更加优美高效，那么就需要在设计模式等方面下一些功夫，抽象基类就是其中的一个选择，抽象基类具有以下优点：</p><ul><li>处理继承问题方面更加规范、系统</li><li>明确调用之间的相互关系</li><li>使得继承层次更加清晰</li><li>限定子类实现的方法</li></ul><p><b>什么是抽象基类？</b></p><p>前面已经介绍了很多有关接口的概念，抽象基类和接口有很多相似之处，例如需要包含抽象方法，不能被实例化，如果更加确切的定义抽象基类：必须包含一个抽象函数(纯虚函数)，它是一个不完整的类，它有已经被实现的方法，也有需要子类重写的方法。</p><h1 id="抽象基类使用场景"><a href="#抽象基类使用场景" class="headerlink" title="抽象基类使用场景"></a>抽象基类使用场景</h1><p>一项功能只有具有应用场景才能体现出它的价值，如果仅仅是为了看上去高逼格，那么倒不如使用最简单的条件、循环语句，没必要花里胡哨，让代码变得难以维护、晦涩难懂。</p><p>抽象基类首先它具备普通继承的功能，因此，在代码可以共用，或者需要获取额外属性的时候可以考虑使用抽象基类，例如，狗、猫、牛、羊这些动物有很多共有的属性和方法，我们可以通过实现一个基类，让每个特定的对象来继承它，这样不仅可以实现多态，还可以提高代码的复用能力。</p><p>当然，上述说的这些场景都偏重于普通继承的优势，而抽象基类的特别之处更加偏向于<b>接口</b>的特点，因此，它的使用场景和接口也有很多相通之处，例如我们开发一个系统，下面有若干个组件，每个组件都需要按照指定的规范来实现特定的方法，这时候我可以发挥抽象基类的<b>限定功能的优势</b>。</p><p>下面就结合这个场景来介绍Python中抽象基类的实现方法。</p><h1 id="Python抽象基类"><a href="#Python抽象基类" class="headerlink" title="Python抽象基类"></a>Python抽象基类</h1><p><b>场景介绍</b></p><p>假如我们现在实现了一个数据中台的开发，我们对外提供一个接口让不同组件通过这个接口进行访问数据库，来读取数据，我们给数据接口主要有2个功能，</p><ul><li>登录数据库</li><li>读取数据</li><li>执行SQL语句</li></ul><p>可以想象，<b>登录数据库</b>这个功能在不同组件之间可以共用，不同组件只需要提供host、user、passwd即可，至于读取数据这是每个组件都必须单独实现的，可以声明为抽象方法，执行SQL语句也是每个子类需要实现的，可以声明为抽象的静态方法。</p><p><b>实现</b></p><p>Python标准库中有一个模块<b>abc</b>可以实现抽象基类和抽象方法，它们的实现方式如下：</p><p><b>抽象基类</b>：通过继承abc模块中的ABC类来实现抽象基类。</p><p><b>抽象方法</b>：通过装饰器的方法来调用abc模块中abstractmethod方法来注解抽象基类的方法。</p><blockquote><p>abstractmethod注解除了可以实现抽象方法外，还可以注解类方法(@classmethod)、静态方法(@staticmethod)、属性(@property)。</p></blockquote><p>下面就先实现抽象基类，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABC</span><br><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> abstractmethod</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Database</span><span class="params">(ABC)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">register</span><span class="params">(self, host, user, password)</span>:</span></span><br><span class="line">        print(<span class="string">"Host : &#123;&#125;"</span>.format(host))</span><br><span class="line">        print(<span class="string">"User : &#123;&#125;"</span>.format(user))</span><br><span class="line">        print(<span class="string">"Password : &#123;&#125;"</span>.format(password))</span><br><span class="line">        print(<span class="string">"Register Success!"</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">query</span><span class="params">(self, *args)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        传入查询数据的SQL语句并执行</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">execute</span><span class="params">(sql_string)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        执行SQL语句</span></span><br><span class="line"><span class="string">        """</span></span><br></pre></td></tr></table></figure><p>从抽象基类<b>Database</b>的实现可以看出，它共包含3个方法，其中<b>register</b>是每个子类都需要的，直接实现在抽象基类里，是一个普通的类方法。<b>query</b>和<b>execute</b>只是在基类中进行类声明，给出了描述，但并没有实现，它限定了继承<b>Database</b>的子类必须实现这两个方法。</p><p>下面就来实现两个组件(子类)，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Component1</span><span class="params">(Database)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, host, user, password)</span>:</span></span><br><span class="line">        self.register(host, user, password)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">execute</span><span class="params">(sql_string)</span>:</span></span><br><span class="line">        print(sql_string)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">query</span><span class="params">(self, *args)</span>:</span></span><br><span class="line">        sql_string = <span class="string">"SELECT ID FROM db_name"</span></span><br><span class="line">        self.execute(sql_string)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Component2</span><span class="params">(Database)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, host, user, password)</span>:</span></span><br><span class="line">        self.register(host, user, password)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">execute</span><span class="params">(sql_string)</span>:</span></span><br><span class="line">        print(sql_string)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">query</span><span class="params">(self, *args)</span>:</span></span><br><span class="line">        sql_string = <span class="string">"SELECT NAME FROM db_name"</span></span><br><span class="line">        self.execute(sql_string)</span><br><span class="line"></span><br><span class="line">comp1 = Component1(<span class="string">"00.00.00.00"</span>, <span class="string">"abc"</span>, <span class="string">"000000"</span>)</span><br><span class="line">comp2 = Component2(<span class="string">"11.11.11.11"</span>, <span class="string">"ABC"</span>, <span class="string">"111111"</span>)</span><br><span class="line">comp1.query()</span><br><span class="line">comp2.query()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">Host : <span class="number">00.00</span><span class="number">.00</span><span class="number">.00</span></span><br><span class="line">User : abc</span><br><span class="line">Password : <span class="number">000000</span></span><br><span class="line">Register Success!</span><br><span class="line">Host : <span class="number">11.11</span><span class="number">.11</span><span class="number">.11</span></span><br><span class="line">User : ABC</span><br><span class="line">Password : <span class="number">111111</span></span><br><span class="line">Register Success!</span><br><span class="line">SELECT ID FROM db_name</span><br><span class="line">SELECT NAME FROM db_name</span><br></pre></td></tr></table></figure><p>上述是通过Python标准库中abc模块实现了抽象基类，其实在Python中collections中也实现了抽象基类，numbers中也定义了有关数字对象的抽象基类，可见，抽象基类在Python中占据着至关重要的地位。</p><h1 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h1><p>本文所涉及的完整代码可以查看github项目<b>advance-python</b>，也可以直接访问下方链接，</p><p><a href="https://github.com/Jackpopc/advance-python/blob/master/5-abstract .ipynb" target="_blank" rel="noopener">https://github.com/Jackpopc/advance-python/blob/master/5-abstract%20.ipynb</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;抽象基类(abstract base class,ABC)，提到这个概念应该会马上联想到面向对象、继承。作为继承的一种，它拥有继承中代码共享、提高代码的重用性等优点。例如，下面示例，
    
    </summary>
    
      <category term="Python" scheme="https://jackpopc.github.io/categories/Python/"/>
    
    
      <category term="编程" scheme="https://jackpopc.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Python" scheme="https://jackpopc.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>【动手学计算机视觉】第十七讲：卷积神经网络之VGG</title>
    <link href="https://jackpopc.github.io/2019/10/27/vgg/"/>
    <id>https://jackpopc.github.io/2019/10/27/vgg/</id>
    <published>2019-10-27T04:51:41.000Z</published>
    <updated>2019-10-27T13:36:05.697Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><a href="https://imgchr.com/i/KyYVj1" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/10/27/KyYVj1.md.png" alt="KyYVj1.md.png"></a></p><p>2014年对于计算机视觉领域是一个丰收的一年，在这一年的ImageNet图像识别挑战赛(ILSVRC,ImageNet Large Scale Visual Recognition Challenge)中出现了两个经典、响至深的卷积神经网络模型，<a id="more"></a>其中第一名是GoogLeNet、第二名是VGG，都可以称得上是深度计算机视觉发展过程中的经典之作。</p><p>虽然在名次上GoogLeNet盖过了VGG，但是在可迁移性方面GoogLeNet对比于VGG却有很大的差距，而且在模型构建思想方面对比于它之前的AlexNet、LeNet做出了很大的改进，因此，VGG后来常作为后续卷积神经网络模型的基础模块，用于特征提取。直到5年后的今天，依然可以在很多新颖的CNN模型中可以见到VGG的身影，本文就来详细介绍一下这个经典的卷积神经网络模型。        </p><h1 id="VGG模型"><a href="#VGG模型" class="headerlink" title="VGG模型"></a>VGG模型</h1><p><img src="https://s2.ax1x.com/2019/10/27/KytAIS.png" alt="config"></p><p>VGG(VERY DEEP CONVOLUTIONAL NETWORKS FOR LARGE-SCALE IMAGE RECOGNITION)，是由牛津大学的研究者提出，它的名称也是以作者所在实验室而命名(Visual Geometry Group)。</p><p>前一篇文章介绍了经典的AlexNet，虽然它在识别效果方面非常令人惊艳，但是这些都是建立在对超参数进行大量的调整的基础上，而它并没有提出一种明确的模型设计规则以便指导后续的新网络模型设计，这也限制了它的迁移能力。因此，虽然它很知名，但是在近几年的模型基础框架却很少出现AlexNet的身影，反观VGG则成为了很多新模型基础框架的必选项之一，这也是它相对于AlexNet的优势之一：<b>VGG提出用基础块代替网络层的思想，这使得它在构建深度网络模型时可以重复使用这些基础块。</b></p><p>正如前面所说，VGG使用了<b>块</b>代替<b>层</b>的思想，具体的来说，它提出了构建基础的<b>卷积块</b>和<b>全连接块</b>来替代<b>卷积层</b>和<b>全连接层</b>，而这里的<b>块</b>是由多个<b>输出通道相同</b>的层组成。</p><p>VGG和AlexNet指代单一的模型不同，VGG其实包含多个不同的模型，从上图可以看出，它主要包括下列模型，</p><ul><li>VGG-11</li><li>VGG-13</li><li>VGG-16</li><li>VGG-19</li></ul><p>其中，后面的数字11、13、16、19是网络层数。</p><p>从图中可以看出，VGG的特点是每个<b>卷积块</b>(由1个或多个卷积层组成)后面跟随一个最大池化层，整体架构和AlexNet非常类似，主要区别就是把层替换成了块。</p><p>从图中红框标记可以看出，每个卷积块中输出通道数相同，另外从横向维度来看，不同模型在相同卷积块中输出通道也相同。</p><p>下面就以比较常用的VGG-16这个模型为例来介绍一下VGG的模型架构。</p><p>VGG-16是由<b>5个卷积块</b>和<b>3个全连接层</b>共8部分组成(回想一下，AlexNet也是由8个部分组成，只不过AlexNet是由5个卷积层和3个全连接层组成)，下面详细介绍每一个部门的详细情况。</p><p><b>注意：</b>前两篇文章我们在搭建LeNet和AlexNet时会发现，不同层的卷积核、步长均有差别，这也是迁移过程中比较困难的一点，而在VGG中就没有这样的困扰，VGG卷积块中统一采用的是<b>3*3</b>的卷积核，卷积层的步长均为<b>1</b>，而在池化层窗口大小统一采用<b>2*2</b>，步长为<b>2</b>。因为每个卷积层、池化层窗口大小、步长都是确定的，因此要搭建VGG我们只需要关注每一层输入输出的通道数即可。</p><p><b>卷积块1</b></p><p>包含<b>2</b>个卷积层，输入是<b>224*224*3</b>的图像，输入通道数为<b>3</b>，输出通道数为<b>64</b>。</p><p><b>卷积块2</b></p><p>包含<b>2</b>个卷积层，输入是上一个卷积块的输出，输入通道数为<b>64</b>，输出通道数为<b>128</b>。</p><p><b>卷积块3</b></p><p>包含<b>3</b>个卷积层，输入是上一个卷积块的输出，输入通道数为<b>128</b>，输出通道数为<b>256</b>。</p><p><b>卷积块4</b></p><p>包含<b>3</b>个卷积层，输入是上一个卷积块的输出，输入通道数为<b>256</b>，输出通道数为<b>512</b>。</p><p><b>卷积块5</b></p><p>包含<b>3</b>个卷积层，输入是上一个卷积块的输出，输入通道数为<b>512</b>，输出通道数为<b>512</b>。</p><p><b>全连接层1</b></p><p>输入为上一层的输出，输入通道数为前一卷积块输出reshape成一维的长度,输出通道数为<b>4096</b>。</p><p><b>全连接层2</b></p><p>输入为上一层的输出，输入通道数为<b>4096</b>,输出通道数为<b>4096</b>。</p><p><b>全连接层3</b></p><p>输入为上一层的输出，输入通道数为<b>4096</b>,输出通道数为<b>1000</b>。</p><p><b>激活函数</b></p><p>VGG中每层使用的激活函数为<b>ReLU</b>激活函数。</p><p>由于VGG非常经典，所以，网络上有关于VGG-16、VGG-19预训练的权重，为了为了展示一下每一层的架构，读取VGG-16预训练权重看一下，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">path = <span class="string">"vgg16.npy"</span></span><br><span class="line">layers = [<span class="string">"conv1_1"</span>, <span class="string">"conv1_2"</span>,</span><br><span class="line">          <span class="string">"conv2_1"</span>, <span class="string">"conv2_2"</span>,</span><br><span class="line">          <span class="string">"conv3_1"</span>, <span class="string">"conv3_2"</span>, <span class="string">"conv3_3"</span>,</span><br><span class="line">          <span class="string">"conv4_1"</span>, <span class="string">"conv4_2"</span>, <span class="string">"conv4_3"</span>,</span><br><span class="line">          <span class="string">"conv5_1"</span>, <span class="string">"conv5_2"</span>, <span class="string">"conv5_3"</span>,</span><br><span class="line">          <span class="string">"fc6"</span>, <span class="string">"fc7"</span>, <span class="string">"fc8"</span>]</span><br><span class="line"></span><br><span class="line">data_dict = np.load(path, encoding=<span class="string">'latin1'</span>).item()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> layer <span class="keyword">in</span> layers:</span><br><span class="line">    print(data_dict[layer][<span class="number">0</span>].shape)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">(<span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">64</span>)</span><br><span class="line">(<span class="number">3</span>, <span class="number">3</span>, <span class="number">64</span>, <span class="number">64</span>)</span><br><span class="line">(<span class="number">3</span>, <span class="number">3</span>, <span class="number">64</span>, <span class="number">128</span>)</span><br><span class="line">(<span class="number">3</span>, <span class="number">3</span>, <span class="number">128</span>, <span class="number">128</span>)</span><br><span class="line">(<span class="number">3</span>, <span class="number">3</span>, <span class="number">128</span>, <span class="number">256</span>)</span><br><span class="line">(<span class="number">3</span>, <span class="number">3</span>, <span class="number">256</span>, <span class="number">256</span>)</span><br><span class="line">(<span class="number">3</span>, <span class="number">3</span>, <span class="number">256</span>, <span class="number">256</span>)</span><br><span class="line">(<span class="number">3</span>, <span class="number">3</span>, <span class="number">256</span>, <span class="number">512</span>)</span><br><span class="line">(<span class="number">3</span>, <span class="number">3</span>, <span class="number">512</span>, <span class="number">512</span>)</span><br><span class="line">(<span class="number">3</span>, <span class="number">3</span>, <span class="number">512</span>, <span class="number">512</span>)</span><br><span class="line">(<span class="number">3</span>, <span class="number">3</span>, <span class="number">512</span>, <span class="number">512</span>)</span><br><span class="line">(<span class="number">3</span>, <span class="number">3</span>, <span class="number">512</span>, <span class="number">512</span>)</span><br><span class="line">(<span class="number">3</span>, <span class="number">3</span>, <span class="number">512</span>, <span class="number">512</span>)</span><br><span class="line">(<span class="number">25088</span>, <span class="number">4096</span>)</span><br><span class="line">(<span class="number">4096</span>, <span class="number">4096</span>)</span><br><span class="line">(<span class="number">4096</span>, <span class="number">1000</span>)</span><br></pre></td></tr></table></figure><p>网络共16层，卷积层部分为<b>1*4</b>维的，其中从前到后分别是<b>卷积核高度</b>、<b>卷积核宽度</b>、<b>输入数据通道数</b>、<b>输出数据通道数</b>。</p><p>到此为止，应该已经了解了VGG的模型结构，下面就开始使用tensorflow编程实现一下 VGG。</p><h1 id="编程实践"><a href="#编程实践" class="headerlink" title="编程实践"></a>编程实践</h1><p>因为 VGG非常经典，所以网络上有VGG的预训练权重，我们可以直接读取预训练的权重去搭建模型，这样就可以忽略对输入和输出通道数的感知，要简单很多，但是为了更加清楚的理解网络模型，在这里还是从最基本的部分开始搭建，自己初始化权重和偏差，这样能够更加清楚每层输入和输出的结构。</p><p><b>卷积块</b></p><p>经过前面的介绍应该了解，VGG的主要特点就在于卷积块的使用，因此，我们首先来完成卷积块部分的编写。在完成一段代码的编写之前，我们应该首先弄明白两点：输入和输出。</p><p>输出当然很明确，就是经过每个卷积块(多个卷积层)卷积、激活后的tensor，我们要明确的就是应该输入哪些参数？</p><p>最重要的3个输入：<b>要进行运算的tensor</b>、<b>每个卷积块内卷积层的个数</b>、<b>输出通道数</b>。</p><p>当然，我们为了更加规范的搭建模型，也需要对每一层规定一个命名空间，这样还需要输入每一层的名称。至于<b>输入通道数</b>，我们可以通过tensorflow的get_shape函数获取，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">conv_block</span><span class="params">(self, X, num_layers, block_index, num_channels)</span>:</span></span><br><span class="line">    in_channels = int(X.get_shape()[<span class="number">-1</span>])</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(num_layers):</span><br><span class="line">        name = <span class="string">"conv&#123;&#125;_&#123;&#125;"</span>.format(block_index, i)</span><br><span class="line">        <span class="keyword">with</span> tf.variable_scope(name) <span class="keyword">as</span> scope:</span><br><span class="line">            weight = tf.get_variable(<span class="string">"weight"</span>, [<span class="number">3</span>, <span class="number">3</span>, in_channels, num_channels])</span><br><span class="line">            bias = tf.get_variable(<span class="string">"bias"</span>, [num_channels])</span><br><span class="line">        conv = tf.nn.conv2d(X, weight, strides=[<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>], padding=<span class="string">"SAME"</span>)</span><br><span class="line">        X = tf.nn.relu(tf.nn.bias_add(conv, bias))</span><br><span class="line">        in_channels = num_channels</span><br><span class="line">        print(X.get_shape())</span><br><span class="line">    <span class="keyword">return</span> X</span><br></pre></td></tr></table></figure><p>从代码中可以看出，有几个参数是固定的：</p><ul><li>卷积窗口大小</li><li>步长</li><li>填充方式</li><li>激活函数</li></ul><p>到此为止，我们就完成了VGG最核心一部分的搭建。</p><p><b>池化层</b></p><p>之前看过前两篇关于AlexNet、LeNet的同学应该记得，池化层有两个重要的参数：<b>窗口大小</b>、<b>步长</b>。由于在VGG中这两个超参数是固定的，因此，不用再作为函数的入参，直接写在代码中即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">max_pool</span><span class="params">(self, X)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> tf.nn.max_pool(X, ksize=[<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>], strides=[<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>], padding=<span class="string">"SAME"</span>)</span><br></pre></td></tr></table></figure><p><b>全连接层</b></p><p>至于全连接层，和前面介绍的两个模型没有什么区别，我们只需要知道输出通道数即可，每一层的输出为上一层的输出，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">full_connect_layer</span><span class="params">(self, X, out_filters, name)</span>:</span></span><br><span class="line">    in_filters = X.get_shape()[<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">with</span> tf.variable_scope(name) <span class="keyword">as</span> scope:</span><br><span class="line">        w_fc = tf.get_variable(<span class="string">"weight"</span>, shape=[in_filters, out_filters])</span><br><span class="line">        b_fc = tf.get_variable(<span class="string">"bias"</span>, shape=[out_filters], trainable=<span class="literal">True</span>)</span><br><span class="line">    fc = tf.nn.xw_plus_b(X, w_fc, b_fc)</span><br><span class="line">    <span class="keyword">return</span> tf.nn.relu(fc)</span><br></pre></td></tr></table></figure><p>由于不同网络模型之前主要的不同之处就在于模型的结构，至于训练和验证过程中需要的准确率、损失函数、优化函数等都大同小异，在前两篇文章中已经实现了训练和验证部分，所以这里就不再赘述。在本文里，我使用numpy生成一个随机的测试集测试一下网络模型是否搭建成功即可。</p><p><b>测试</b></p><p>首先使用numpy生成符合正态分布的随机数，形状为(5, 224, 224, 3)，5为批量数据的大小，244为输入图像的尺寸，3为输入图像的通道数，设定输出类别数为1000，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    X = np.random.normal(size=(<span class="number">5</span>, <span class="number">224</span>, <span class="number">224</span>, <span class="number">3</span>))</span><br><span class="line">    images = tf.placeholder(<span class="string">"float"</span>, [<span class="number">5</span>, <span class="number">224</span>, <span class="number">224</span>, <span class="number">3</span>])</span><br><span class="line">    vgg = VGG(<span class="number">1000</span>)</span><br><span class="line">    writer = tf.summary.FileWriter(<span class="string">"logs"</span>)</span><br><span class="line">    <span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">        model = vgg.create(images)</span><br><span class="line">        sess.run(tf.global_variables_initializer())</span><br><span class="line">        writer.add_graph(sess.graph)</span><br><span class="line">        prob = sess.run(model, feed_dict=&#123;images: X&#125;)</span><br><span class="line">        print(sess.run(tf.argmax(prob, <span class="number">1</span>)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">(<span class="number">5</span>, <span class="number">224</span>, <span class="number">224</span>, <span class="number">64</span>)</span><br><span class="line">(<span class="number">5</span>, <span class="number">224</span>, <span class="number">224</span>, <span class="number">64</span>)</span><br><span class="line">(<span class="number">5</span>, <span class="number">112</span>, <span class="number">112</span>, <span class="number">128</span>)</span><br><span class="line">(<span class="number">5</span>, <span class="number">112</span>, <span class="number">112</span>, <span class="number">128</span>)</span><br><span class="line">(<span class="number">5</span>, <span class="number">56</span>, <span class="number">56</span>, <span class="number">256</span>)</span><br><span class="line">(<span class="number">5</span>, <span class="number">56</span>, <span class="number">56</span>, <span class="number">256</span>)</span><br><span class="line">(<span class="number">5</span>, <span class="number">56</span>, <span class="number">56</span>, <span class="number">256</span>)</span><br><span class="line">(<span class="number">5</span>, <span class="number">28</span>, <span class="number">28</span>, <span class="number">512</span>)</span><br><span class="line">(<span class="number">5</span>, <span class="number">28</span>, <span class="number">28</span>, <span class="number">512</span>)</span><br><span class="line">(<span class="number">5</span>, <span class="number">28</span>, <span class="number">28</span>, <span class="number">512</span>)</span><br><span class="line">(<span class="number">5</span>, <span class="number">14</span>, <span class="number">14</span>, <span class="number">512</span>)</span><br><span class="line">(<span class="number">5</span>, <span class="number">14</span>, <span class="number">14</span>, <span class="number">512</span>)</span><br><span class="line">(<span class="number">5</span>, <span class="number">14</span>, <span class="number">14</span>, <span class="number">512</span>)</span><br><span class="line">(<span class="number">5</span>, <span class="number">4096</span>)</span><br><span class="line">(<span class="number">5</span>, <span class="number">4096</span>)</span><br><span class="line">(<span class="number">5</span>, <span class="number">1000</span>)</span><br><span class="line">[<span class="number">862</span> <span class="number">862</span> <span class="number">862</span> <span class="number">862</span> <span class="number">862</span>]</span><br></pre></td></tr></table></figure><p>可以对比看出，每层网络的尺寸和前面加载的预训练模型是匹配的，下面在看一下tensorboard的结果，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> tensorboard --logdir=<span class="string">"logs"</span></span></span><br></pre></td></tr></table></figure><p>结果，</p><p><a href="https://imgchr.com/i/KyY8gA" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/10/27/KyY8gA.md.gif" alt="KyY8gA.md.gif"></a></p><h1 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h1><p>完整代码请查看github项目<b>aiLearnNotes</b>，也可以直接访问下面链接，</p><p><a href="https://github.com/Jackpopc/aiLearnNotes/blob/master/computer_vision/VGG-16.py" target="_blank" rel="noopener">https://github.com/Jackpopc/aiLearnNotes/blob/master/computer_vision/VGG-16.py</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://imgchr.com/i/KyYVj1&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/10/27/KyYVj1.md.png&quot; alt=&quot;KyYVj1.md.png&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2014年对于计算机视觉领域是一个丰收的一年，在这一年的ImageNet图像识别挑战赛(ILSVRC,ImageNet Large Scale Visual Recognition Challenge)中出现了两个经典、响至深的卷积神经网络模型，
    
    </summary>
    
      <category term="计算机视觉" scheme="https://jackpopc.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
    
      <category term="CV" scheme="https://jackpopc.github.io/tags/CV/"/>
    
      <category term="AI" scheme="https://jackpopc.github.io/tags/AI/"/>
    
      <category term="图像处理" scheme="https://jackpopc.github.io/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>【进阶Python】第六讲：单例模式的妙用</title>
    <link href="https://jackpopc.github.io/2019/10/19/singleton/"/>
    <id>https://jackpopc.github.io/2019/10/19/singleton/</id>
    <published>2019-10-19T12:19:20.000Z</published>
    <updated>2019-10-19T14:46:43.981Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在<b>第三讲：类的特殊方法(上篇)</b>中我在讲解Python特殊方法<b>__new__</b>的使用时提及了一个概念—单例模式，这是一个软件设计中非常重要的概念，由于它不属于某一类特定的语言，既可以用于Java、也可以用于Python，因此在这些单一编程语言的书籍里很少特意花费篇幅介绍单例模式，因此，我准备用这整篇文章来介绍一下Python的单例模式的实现及使用场景。</p><a id="more"></a>本文，我将从如下3个方面阐述Python单例模式的使用，- 单例模式的概念- Python单例模式的实现- 单例模式的使用场景# 单例模式首先看一下<b>维基百科</b>对单例模式的解释，> 单例模式，也叫单子模式，是一种常用的软件设计模式。在应用这个模式时，单例对象的类必须保证只有一个实例存在。许多时候整个系统只需要拥有一个的全局对象，这样有利于我们协调系统整体的行为。比如在某个服务器程序中，该服务器的配置信息存放在一个文件中，这些配置数据由一个单例对象统一读取，然后服务进程中的其他对象再通过这个单例对象获取这些配置信息。这种方式简化了在复杂环境下的配置管理。上述描述也许有点让人云里雾里，我来提炼一下维基百科关于单例模式解释的关键点，1. 单例模式是一种软件设计模式，而不是专属于某种编程语言的语法；2. 单例模式只有一个实例存在；3. 单例模式有助于协调系统的整体性、统一性；<b>软件设计模式</b>我一直认为，对于一门编程语言“入门容易，精通不易”，哪怕是对于很多人都认为简单的Python语言。我们学会一门语言的基本语法和基本使用也许只需要2个月、2个周，甚至2天或者2个小时，但是如果用一门编程语言开发出高性能的系统，却是一件日积月累的事情。当使用一门编程语言时一定要认清一个问题，代码不仅是给机器看的，同时也要给人看。因此，我们实现一个工程项目，要同时兼顾代码的高效性和简洁易读性。在效率方面我们可以借助分而治之、动态规划、二叉树、B-树等算法设计模式和数据结构，但是要实现代码的简洁性和高效性还离不开一个好的<b>软件设计模式</b>，软件设计模式有很多种，例如，- 工厂模式- 原型模式- 单例模式- 生成器模式- ......使用合理的软件设计模式可以使得代码重用性更高、更易于理解、可靠性更高。<b>单例模式只有一个实例存在</b>这是单例模式的主要特征，也是设计单例模式的要求，和普通软件设计模式允许多个实例同时存在不同，单例模式只允许一个实例存在，首先来看一个示例，<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Software</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">soft1 = Software()</span><br><span class="line">soft2 = Software()</span><br><span class="line">print(id(soft1))</span><br><span class="line">print(id(soft2))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line"><span class="number">2538846619576</span></span><br><span class="line"><span class="number">2538846620024</span></span><br></pre></td></tr></table></figure><p>上述给出的Python的一个普通软件设计模式，当我们定义一个名为<b>Software</b>的类后，我们先后实例化两个对象，分别是<b>soft1</b>和<b>soft2</b>，输出它们的地址可以看出，它们不是同一个示例，这就限制了它在某些场景下无法使用，后面关于单例模式的使用场景部分会专门介绍。</p><p><b>单例模式有助于协调系统的整体性、统一性</b></p><p>由于单例模式的设计要求使得每一个应用、活动只有一个实例，这使得不管我们怎么去调用、实例化，当前唯一存在一个实例，这在资源调度、日志管理、信息注册等应用场景下保证了只有一个实例对其进行操作，而避免了多个实例同时操作一个对象，这保证了协调系统的整体性和统一性。</p><h1 id="Python单例模式"><a href="#Python单例模式" class="headerlink" title="Python单例模式"></a>Python单例模式</h1><p>其实，关于Python单例模式的实现，在<b>第三讲：类的特殊方法(上篇)</b>中已经有所提及，可以通过重写<b>__new__</b>方法来实现单例模式，但是Python实现单例模式不仅包含这一种方式，还可以使用装饰器来实现单例模式，下面来看一下两种实现Python单例模式的方式。</p><p>首先，定义一个名为<b>Singleton</b>的基类，在这个基类里面对new方法进行重写，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, *args, **kw)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> hasattr(cls, <span class="string">'_instance'</span>):</span><br><span class="line">            orig = super(Singleton, cls)</span><br><span class="line">            cls._instance = orig.__new__(cls)</span><br><span class="line">        <span class="keyword">return</span> cls._instance</span><br></pre></td></tr></table></figure><p>然后，凡是继承<b>Singleton</b>基类的子类都属于单例模式，下面来看一下，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Books</span><span class="params">(Singleton)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"> </span><br><span class="line">book1 = Books()</span><br><span class="line">book2 = Books()</span><br><span class="line">print(id(book1))</span><br><span class="line">print(id(book2))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line"><span class="number">2538847457968</span></span><br><span class="line"><span class="number">2538847457968</span></span><br></pre></td></tr></table></figure><p>可以从上面输出看得出来，我们虽然对Books类实例化两次，分别得到两个名为book1和book2的实例，但是id却是相同的，也就说这两个实例指向同一个地址，为同一个实例。</p><p><b>装饰器</b></p><p>在第二讲中我详细的介绍了Python装饰器的使用，简而言之，Python装饰器就是操作函数的函数，当然，它类也可以作为装饰器的输入。利用装饰器实现Python单例模式就是通过类进行操作实现单例模式，</p><p>首先，我们完成装饰器的编写，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">singleton</span><span class="params">(cls, *args, **kw)</span>:</span>    </span><br><span class="line">    instances = &#123;&#125;    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">()</span>:</span>    </span><br><span class="line">        <span class="keyword">if</span> cls <span class="keyword">not</span> <span class="keyword">in</span> instances:    </span><br><span class="line">            instances[cls] = cls(*args, **kw)    </span><br><span class="line">        <span class="keyword">return</span> instances[cls]    </span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br></pre></td></tr></table></figure><p>然后调用装饰器，实现单例模式，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@singleton</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    </span><br><span class="line">animal1 = Animal()</span><br><span class="line">animal2 = Animal()</span><br><span class="line">print(id(animal1))</span><br><span class="line">print(id(animal2))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line"><span class="number">2538848208544</span></span><br><span class="line"><span class="number">2538848208544</span></span><br></pre></td></tr></table></figure><p>看一下上面的输出，和new方法实现的效果是相同的。</p><p>除此之外，还可以通过<b>__metaclass__</b>元类、共有属性等来实现，但是由于它本质上与上述两种方式并没有什么区别，也许看代码过程中会觉得有点不太明白，其实上述两种方式都是基于同一个思想进行实现的：<b>创建实例(instance)时首先判断是否已经存在，如果已经存在则返回，否则创建。</b></p><h1 id="单例模式的使用场景"><a href="#单例模式的使用场景" class="headerlink" title="单例模式的使用场景"></a>单例模式的使用场景</h1><p>由于单例模式的特殊性，使得它具备<b>整体性、统一性</b>的优势，因此，它的使用场景大多数也是围绕这两点优势进行展开的，如果遇到以下场景，我们可以考虑是否能够使用单例模式来实现，</p><ul><li>资源管理的场景</li><li>难以同步的场景</li><li>涉及共享的场景</li><li>有关认证的场景</li></ul><p>以上述第四点展开进行讨论一下，结合代码更加容易理解单例模式的妙处所在。</p><p><b>场景描述</b></p><p>做项目开发过程中，大多数岗位都会和数据打交道，无论是前端还是后端。假如，我们存储数据工具是SQL Server，我们需要通过host、user、passwd来连接数据库进行读取数据，这时候就需要<b>一次认证，多次调用</b>，请注意这句话，很关键。</p><p><b>普通模式</b></p><p>我们首先来实现一个连接SQL的类，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SqlClient</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, host, user, passwd)</span>:</span></span><br><span class="line">        self.host = host</span><br><span class="line">        self.user = user</span><br><span class="line">        self.passwd = passwd</span><br><span class="line">        self.register()</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">register</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.info = <span class="string">"&#123;&#125;--&#123;&#125;---&#123;&#125;"</span>.format(self.host, self.user, self.passwd)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">select</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"SELECT * FROM &#123;&#125;"</span>.format(self.host))</span><br></pre></td></tr></table></figure><p>SqlClient中有3个方法，<b>__init__</b>用于初始化参数，register是认证SQL客户端，select是执行SQL语句的操作。</p><p>到这里，我们完成了SQL的认证，后面我们会在不同的地方查找数据，也就是在多个地方需要调用<b>SqlClient</b>类的select方法，试想一下我们该怎么实现？</p><p>有两种方法：</p><ul><li>反复实例化、反复认证</li><li>把实例化后的对象作为参数传入到每个用到select的函数里</li></ul><p>先看第一种，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">host = <span class="string">"10.293.291.19"</span></span><br><span class="line">user = <span class="string">"admin"</span></span><br><span class="line">passwd = <span class="string">"666666"</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">use_data_1</span><span class="params">()</span>:</span></span><br><span class="line">    sql_client = SqlClient(host, user, passwd)</span><br><span class="line">    sql_client.select()</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">use_data_2</span><span class="params">()</span>:</span></span><br><span class="line">    sql_client = SqlClient(host, user, passwd)</span><br><span class="line">    sql_client.select()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">use_data_3</span><span class="params">()</span>:</span></span><br><span class="line">    sql_client = SqlClient(host, user, passwd)</span><br><span class="line">    sql_client.select()</span><br><span class="line">    </span><br><span class="line">use_data_1()</span><br><span class="line">use_data_2()</span><br><span class="line">use_data_3()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">SELECT * FROM <span class="number">10.293</span><span class="number">.291</span><span class="number">.19</span></span><br><span class="line">SELECT * FROM <span class="number">10.293</span><span class="number">.291</span><span class="number">.19</span></span><br><span class="line">SELECT * FROM <span class="number">10.293</span><span class="number">.291</span><span class="number">.19</span></span><br></pre></td></tr></table></figure><p>可以看到，我们在<b>use_data_1、use_data_2、use_data_3</b>三处使用到了SQL选择工具，每一次我们都要重新实例化SqlClient，显然，这是很麻烦的。</p><p>然后再看一下第二种方式，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">host = <span class="string">"10.293.291.19"</span></span><br><span class="line">user = <span class="string">"admin"</span></span><br><span class="line">passwd = <span class="string">"666666"</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">use_data_1</span><span class="params">(sql_client)</span>:</span></span><br><span class="line">    sql_client.select()</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">use_data_2</span><span class="params">(sql_client)</span>:</span></span><br><span class="line">    sql_client.select()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">use_data_3</span><span class="params">(sql_client)</span>:</span></span><br><span class="line">    sql_client.select()</span><br><span class="line">    </span><br><span class="line">sql_client = SqlClient(host, user, passwd)</span><br><span class="line">use_data_1(sql_client)</span><br><span class="line">use_data_2(sql_client)</span><br><span class="line">use_data_3(sql_client)</span><br></pre></td></tr></table></figure><p>我们可以先对实例化SqlClient，然后作为参数传入到每一个用到SQL工具的地方。</p><p>这样看来显然比第一种要好很多，在代码简洁性方面比第一种方法优化了不少，但是，开发中我们应该意识到一个问题，尽量少传参数，尤其是链式调用的函数，只在其中某几个环境用到，我们却需要不断的把它当作参数一致往下传递，如果这样的话，我们会发现，我们会传递很多参数，例如下面这个示例，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">host = <span class="string">"10.293.291.19"</span></span><br><span class="line">user = <span class="string">"admin"</span></span><br><span class="line">passwd = <span class="string">"666666"</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">use_data_1</span><span class="params">(sql_client)</span>:</span></span><br><span class="line">    sql_client.select()</span><br><span class="line">    use_data_2(sql_client)</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">use_data_2</span><span class="params">(sql_client)</span>:</span></span><br><span class="line">    use_data_3(sql_client)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">use_data_3</span><span class="params">(sql_client)</span>:</span></span><br><span class="line">    sql_client.select()</span><br><span class="line">    </span><br><span class="line">sql_client = SqlClient(host, user, passwd)</span><br><span class="line">use_data_1(sql_client)</span><br></pre></td></tr></table></figure><p>可以看到上述示例，use_data_1调用use_data_2，use_data_2调用use_data_3,而我们在use_data_1、use_data_3中需要用到SQL工具，但是在use_data_2这个中间环节用不到，但是为了让参数继续传递下去，sql_client却不得不作为use_data_2的一个入参。</p><p><b>单例模式</b></p><p>这时候我们就可以使用单例模式来轻松解决这个问题，我们只需要实例化一次用于认证，然后再每个位置调用即可，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, *args, **kw)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> hasattr(cls, <span class="string">'_instance'</span>):</span><br><span class="line">            orig = super(Singleton, cls)</span><br><span class="line">            cls._instance = orig.__new__(cls)</span><br><span class="line">        <span class="keyword">return</span> cls._instance</span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SqlClient</span><span class="params">(Singleton)</span>:</span></span><br><span class="line">    info = <span class="literal">None</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">register</span><span class="params">(self, host, user, passwd)</span>:</span></span><br><span class="line">        self.info = <span class="string">"&#123;&#125;--&#123;&#125;--&#123;&#125;"</span>.format(host, user, passwd)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">select</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(self.info)</span><br></pre></td></tr></table></figure><p>我们通过继承Singleton实现SqlClient的单例模式，我们只需要调用register一次，用于认证客户端，然后后期每次重新实例化都是指向的同一个实例，也就是已经认证过的示例，我们后面任何其他地方调用的地方直接使用select方法即可，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">use_data_1</span><span class="params">()</span>:</span></span><br><span class="line">    SqlClient().select()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">use_data_2</span><span class="params">()</span>:</span></span><br><span class="line">    SqlClient().select()</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">use_data_3</span><span class="params">()</span>:</span></span><br><span class="line">    SqlClient().select()</span><br><span class="line">    </span><br><span class="line">SqlClient().register(host, user, passwd)</span><br><span class="line">use_data_1()</span><br><span class="line">use_data_2()</span><br><span class="line">use_data_3()</span><br></pre></td></tr></table></figure><p>依此可以发散思维一下，凡是类似的场景都可以考虑一下是否可以使用单例模式。</p><p>当然，凡事既有优点就会有缺点，单例模式也是，它可以实现系统的整体性和统一性，但是也不是在任何场景下都是适用的，例如，</p><ul><li>多线程</li><li>可变对象</li></ul><p>在这些场景下，它违背了单例模式单一性原则，而且很容易因此数据错误。</p><p>因此，使用单例模式之前需要考虑一下对应场景是否适合，如果适合，单例模式能够大大提高代码的效率，同时使得代码更加简洁，但是如果不适合而强行使用单例模式，那样会导致很多未知的问题。</p><h1 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h1><p>我把完整代码已经放在github，感兴趣的可以点击下方链接，或者直接搜索项目<b><strong>advance-python</strong></b>，</p><p><a href="https://github.com/Jackpopc/advance-python/blob/master/4-Singleton.ipynb" target="_blank" rel="noopener">https://github.com/Jackpopc/advance-python/blob/master/4-Singleton.ipynb</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;在&lt;b&gt;第三讲：类的特殊方法(上篇)&lt;/b&gt;中我在讲解Python特殊方法&lt;b&gt;__new__&lt;/b&gt;的使用时提及了一个概念—单例模式，这是一个软件设计中非常重要的概念，由于它不属于某一类特定的语言，既可以用于Java、也可以用于Python，因此在这些单一编程语言的书籍里很少特意花费篇幅介绍单例模式，因此，我准备用这整篇文章来介绍一下Python的单例模式的实现及使用场景。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="https://jackpopc.github.io/categories/Python/"/>
    
    
      <category term="编程" scheme="https://jackpopc.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Python" scheme="https://jackpopc.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>实用工具 | 2款强大的C盘清理工具</title>
    <link href="https://jackpopc.github.io/2019/10/16/clean-c/"/>
    <id>https://jackpopc.github.io/2019/10/16/clean-c/</id>
    <published>2019-10-16T11:42:15.000Z</published>
    <updated>2019-10-19T14:46:38.572Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><img src="https://s2.ax1x.com/2019/10/16/KFI86P.jpg" alt="KFI86P.jpg"></p><p>如果是我，绝大多数情况看到这样的标题我是不会点进来看的。</p><p>有几类软件在我心里被认为是毫无用处的鸡肋，其中就有C盘清理工具。</p><p><a id="more"></a>作为一个经常跟电脑打交道的开发者，当看到C盘空间从100G、80G、50G、30G、10G逐渐减小的过程中，就如同看到手机电量从100%逐渐降至80%、50%、20%、5%一样，让我心神不宁、坐立不安。</p><p>有时候会很疑惑，我明明没有安装任何软件，为什么C盘空间还在持续缩小？然后会打开C盘逐个的去看一下每个目录的空间占用情况，然后发现对于那些大文件无从下手、不知道有什么作用，最终还是灰溜溜的放弃。</p><p>有时无奈之余会想着求助C盘清理工具吧，平时在各种平台看到过太多各式各样的C盘清理工具，例如，比较知名的360、电脑管家、魔方等，但是，经过一段时间的对比使用之后会发现，效果可以说是微乎其微。<b>就如同经过某些电脑管家清理内存之后它告诉你，“速度提升<em>*%”，然而，当把它卸载后你会电脑运行的速度要远远超过\</em>*%</b>。</p><p>因此，久而久之就不得不改掉这种强迫症，不再去关注内存的缩小，直到前段时间我遇到两款工具，本来我没有抱太大情况，心想软件不大、免安装，倒不如试一下，用过之后我才发现，竟然有这么强大的C盘清理工具，能够轻松清理C盘N个G的工具，下面就来介绍一下这两款工具。</p><h1 id="Windows-Update-Clean-Tool"><a href="#Windows-Update-Clean-Tool" class="headerlink" title="Windows Update Clean Tool"></a>Windows Update Clean Tool</h1><p>在介绍这两款工具之前我们先看一下windows自带的清理工具的情况，然后能够做一下明显的对比，</p><p><b>首先，鼠标右键点击C盘盘符</b></p><p><img src="https://s2.ax1x.com/2019/10/16/KF5hsf.png" alt="KF5hsf.png"></p><p><b>然后，点击磁盘清理，同时点击清理系统文件</b></p><p><img src="https://s2.ax1x.com/2019/10/16/KF5IeS.png" alt="KF5IeS.png"></p><p>从上图可以看出，全选windows自带清理工具识别出来的垃圾空间占用量为<b>135MB</b>。</p><p>下面来看一下<b>Windows Update Clean Tool</b>的情况，没有占用空间综合，粗略估计至少有<b>1.4GB</b>,</p><p><img src="https://s2.ax1x.com/2019/10/16/KFIiWR.png" alt="KFIiWR.png"></p><p>经过对比，现在对Windows Update Clean Tool这款工具的强大之处已经一目了然，但是它的强大之处远不止我们静态看到的这些，它不仅能够识别如下类别垃圾：</p><ul><li>临时文件</li><li>日志文件</li><li>冗余文件</li><li>安装源</li><li>缓存</li><li>……</li></ul><p>它还有一点是其他C盘清理工具是无法比拟的，那就是<b>速度快！！！</b></p><p>我们使用清理工具，当然也包括windows自带的工具会发现，扫描过程非常缓慢，少则几分钟，多则几十分钟都有可能。而Windows Update Clean Tool只需要<b>1分钟</b>内就可以完成垃圾的扫描，我说的1分钟是对绝大多数机型，如果性能好一些的电脑10秒内即可完成扫描。</p><p>最后还需要补充3点，<b>Windows Update Clean Tool无需安装，解压即可使用！！！内存占用小，只有4.4MB！！！更重要的是免费！！！</b></p><h1 id="WICleanup"><a href="#WICleanup" class="headerlink" title="WICleanup"></a>WICleanup</h1><p>Windows Update Clean Tool是一款针对不同类型文件的清理工具，它能够清理安装源、缓存等类型的垃圾，而<b>WICleanup</b>则是一款纯粹的<b>冗余文件清理工具</b>，它能够更加深层次、专注的挖掘MSI补丁程序冗余文件，然后对其进行扫描和清理，它和Windows Update Clean Tool的侧重点不同，因此两款工具可以结合使用对C盘进行清理。</p><p><img src="https://s2.ax1x.com/2019/10/16/KFIkS1.png" alt="KFIkS1.png"></p><p>从上图可以看出经过Windows Update Clean Tool清理之后，WICleanup还可以扫描述几百兆的冗余文件，由于我有一个经常清理电脑的习惯，所以电脑垃圾相对较少，在办公电脑上我尝试了一下上述两款工具，能够迅速清理出5GB以上的垃圾。</p><p>同样需要补充3点，<b>WICleanup内存占用更小，只要120KB！！！它同样是绿色免安装的，解压即可使用！！！WICleanup同样是一款完全免费的工具。</b></p><h1 id="免责声明"><a href="#免责声明" class="headerlink" title="免责声明"></a>免责声明</h1><p>windows是一款庞大而复杂的系统，作为一个非系统开发者，我对它内部的很多文件功能也不是完全了解，只是我发现这两款工具非常好用，因此分享给大家。但是，强大的清理功能随之带来的就是更高的风险。因此，在删除的过程中切勿盲目点按，需要看清楚软件的提醒，以Windows Update Clean Tool为例，它会有<b>推荐操作</b>，推荐你是保留还是删除，为了保险起见还是应该慎重按照软件的提示使用。如果因为使用上述软件造成了系统损坏问题，请不要强加责备。当然，经过我在多台电脑上试用，目前还没有发生什么问题。</p><h1 id="下载方式"><a href="#下载方式" class="headerlink" title="下载方式"></a>下载方式</h1><p>我已经把上述两款工具打包进行共享，如果需要可以关注公众号，后台回复关键字<b><font color="red">“clean”</font></b>获取~</p><p><img src="https://s2.ax1x.com/2019/10/16/KFIEy6.png" alt="KFIEy6.png"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/10/16/KFI86P.jpg&quot; alt=&quot;KFI86P.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;如果是我，绝大多数情况看到这样的标题我是不会点进来看的。&lt;/p&gt;
&lt;p&gt;有几类软件在我心里被认为是毫无用处的鸡肋，其中就有C盘清理工具。&lt;/p&gt;
&lt;p&gt;
    
    </summary>
    
      <category term="实用工具" scheme="https://jackpopc.github.io/categories/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="工具" scheme="https://jackpopc.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="实用" scheme="https://jackpopc.github.io/tags/%E5%AE%9E%E7%94%A8/"/>
    
      <category term="清理" scheme="https://jackpopc.github.io/tags/%E6%B8%85%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>【动手学计算机视觉】第十六讲：卷积神经网络之AlexNet</title>
    <link href="https://jackpopc.github.io/2019/10/13/alexnet/"/>
    <id>https://jackpopc.github.io/2019/10/13/alexnet/</id>
    <published>2019-10-13T06:43:46.000Z</published>
    <updated>2019-10-13T08:58:33.298Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><img src="https://s2.ax1x.com/2019/10/13/uv4Na8.png" alt="uv4Na8.png"></p><p>前文详细介绍了卷积神经网络的开山之作<b>LeNet</b>，虽然近几年卷积神经网络非常热门，但是在<b>LeNet</b>出现后的十几年里，在目标识别领域卷积神经网络一直被传统目标识别算法(特征提取+分类器)所压制，直到2012年AlexNet(ImageNet Classification with Deep Convolutional<br>Neural Networks)<a id="more"></a>在ImageNet挑战赛一举夺魁，使得卷积神经网络再次引起人们的重视，并因此而一发不可收拾，卷积神经网络的研究如雨后春笋一般不断涌现，推陈出新。</p><p><b>AlexNet</b>是以它的第一作者Alex Krizhevsky而命名，这篇文章中也有深度学习领域三位大牛之一的Geoffrey Hinton的身影。AlexNet之所以这么有名气，不仅仅是因为获取比赛冠军这么简单。这么多年，目标识别、目标跟踪相关的比赛层出不穷，获得冠军的团队也变得非常庞大，但是反观一下能够像 AlexNet影响力这么大的，却是寥寥可数。</p><p>AlexNet相比于上一代的LeNet它首先在数据集上做了很多工作，</p><p><b>第一点：数据集</b></p><p>我们都知道，限制深度学习的两大因素分别输算力和数据集，AlexNet引入了数据增广技术，对图像进行颜色变换、裁剪、翻转等操作。</p><p><b>第二点：激活函数</b></p><p>在激活函数方面它采用ReLU函数代替Sigmoid函数，前面我用一篇文章详细的介绍了不同激活函数的优缺点，如果看过的同学应该清楚，ReLU激活函数不仅在计算方面比Sigmoid更加简单，而且可以克服Sigmoid函数在接近0和1时难以训练的问题。</p><p><b>第三点：Dropout</b></p><p>这也是AlexNet相对于LeNet比较大一点不同之处，AlexNet引入了Dropout用于解决模型训练过程中容易出现过拟合的问题，此后作者还发表几篇文章详细的介绍Dropout算法，它的引入使得卷积神经网络效果大大提升，直到如今Dropout在模型训练过程中依然被广泛使用。</p><p><b>第四点：模型结构</b></p><p>卷积神经网络的每次迭代，模型架构都会发生非常大的变化，卷积核大小、网络层数、跳跃连接等等，这也是不同卷积神经网络模型之间的区别最明显的一点，由于网络模型比较庞大，一言半语无法描述完整，下面我就来详细介绍一下AlexNet的网络模型。</p><h1 id="AlexNet"><a href="#AlexNet" class="headerlink" title="AlexNet"></a>AlexNet</h1><p><a href="https://imgchr.com/i/uv4UIS" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/10/13/uv4UIS.png" alt="uv4UIS.png"></a></p><p>如果读过前面一片文章应该了解，LeNet是一个5层的卷积神经网络模型，它有两个卷积层和3个全连接层。对比而言，AlexNet是一个8层的卷积升级网络模型，它有5个卷积层和3个全连接层。</p><p>我们在搭建一个网络模型的过程中，重点应该关注如下几点：</p><ul><li>卷积核大小</li><li>输入输出通道数</li><li>步长</li><li>激活函数</li></ul><p>关于AlexNet中使用的激活函数前面已经介绍过，它使用的是ReLU激活函数，它5层卷积层除了第一层卷积核为<b>11*11</b>、第二次为<b>5*5</b>之外，其余三层均为<b>3*3</b>，下面就详细介绍一下AlexNet的模型结构，</p><p><b>第一层：卷积层</b></p><p>卷积核大小<b>11*11</b>，输入通道数根据输入图像而定，输出通道数为<b>96</b>，步长为<b>4</b>。</p><p>池化层窗口大小为<b>3*3</b>，步长为<b>2</b>。</p><p><b>第二层：卷积层</b></p><p>卷积核大小<b>5*5</b>，输入通道数为<b>96</b>，输出通道数为<b>256</b>，步长为<b>2</b>。</p><p>池化层窗口大小为<b>3*3</b>，步长为<b>2</b>。</p><p><b>第三层：卷积层</b></p><p>卷积核大小<b>3*3</b>，输入通道数为<b>256</b>，输出通道数为<b>384</b>，步长为<b>1</b>。</p><p><b>第四层：卷积层</b></p><p>卷积核大小<b>3*3</b>，输入通道数为<b>384</b>，输出通道数为<b>384</b>，步长为<b>1</b>。</p><p><b>第五层：卷积层</b></p><p>卷积核大小<b>3*3</b>，输入通道数为<b>384</b>，输出通道数为<b>256</b>，步长为<b>1</b>。</p><p>池化层窗口大小为<b>3*3</b>，步长为<b>2</b>。</p><p><b>第六层：全连接层</b></p><p>输入大小为上一层的输出，输出大小为<b>4096</b>。</p><p>Dropout概率为<b>0.5</b>。</p><p><b>第七层：全连接层</b></p><p>输入大小为<b>4096</b>，输出大小为<b>4096</b>。</p><p>Dropout概率为<b>0.5</b>。</p><p><b>第八层：全连接层</b></p><p>输入大小为<b>4096</b>，输出大小为<b>分类数</b>。</p><p><b>注意：</b>需要注意一点，5个卷积层中前2个卷积层后面都会紧跟一个池化层，而第3、4层卷积层后面没有池化层，而是连续3、4、5层三个卷积层后才加入一个池化层。</p><h1 id="编程实践"><a href="#编程实践" class="headerlink" title="编程实践"></a>编程实践</h1><p><img src="https://s2.ax1x.com/2019/10/13/uv4wGQ.png" alt="uv4wGQ.png"></p><p>在动手实践LeNet文章中，我介绍了网络搭建的过程，这种方式同样适用于除LeNet之外的其他模型的搭建，我们需要首先完成网络模型的搭建，然后再编写训练、验证函数部分。</p><p>在前面一篇文章为了让大家更加容易理解tensorflow的使用，更加清晰的看到网络搭建的过程，因此逐行编码进行模型搭建。但是，我们会发现，同类型的网络层之间很多参数是相同的，例如卷积核大小、输出通道数、变量作用于的名称，我们逐行搭建会有很多代码冗余，我们完全可以把这些通用参数作为传入参数提炼出来。因此，本文编程实践中会侧重于代码规范，提高代码的可读性。</p><p>编程实践中主要根据tensorflow接口的不同之处把网络架构分为如下4个模块：</p><ul><li>卷积层</li><li>池化层</li><li>全连接层</li><li>Dropout</li></ul><p><b>卷积层</b></p><p>针对卷积层，我们把<b>输入、卷积核大小、输入通道数、步长、变量作用域</b>作为入参，我们使用tensorflow时会发现，我们同样需要知道输入数据的通道数，关于这个变量，我们可以通过获取输入数据的尺寸获得，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">conv_layer</span><span class="params">(self, X, ksize, out_filters, stride, name)</span>:</span></span><br><span class="line">    in_filters = int(X.get_shape()[<span class="number">-1</span>])</span><br><span class="line">    <span class="keyword">with</span> tf.variable_scope(name) <span class="keyword">as</span> scope:</span><br><span class="line">        weight = tf.get_variable(<span class="string">"weight"</span>, [ksize, ksize, in_filters, out_filters])</span><br><span class="line">        bias = tf.get_variable(<span class="string">"bias"</span>, [out_filters])</span><br><span class="line">    conv = tf.nn.conv2d(X, weight, strides=[<span class="number">1</span>, stride, stride, <span class="number">1</span>], padding=<span class="string">"SAME"</span>)</span><br><span class="line">    activation = tf.nn.relu(tf.nn.bias_add(conv, bias))</span><br><span class="line">    <span class="keyword">return</span> activation</span><br></pre></td></tr></table></figure><p>上面，我们经过获取权重、偏差，卷积运算，激活函数3个部分完成了卷积模块的实现。AlexNet有5个卷积层，不同层之间的主要区别就体现在<b>conv_layer</b>的入参上面，因此我们只需要修改函数的入参就可以完成不同卷积层的搭建。</p><p><b>池化层</b></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pool_layer</span><span class="params">(self, X, ksize, stride)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> tf.nn.max_pool(X, ksize=[<span class="number">1</span>, ksize, ksize, <span class="number">1</span>], strides=[<span class="number">1</span>, stride, stride, <span class="number">1</span>], padding=<span class="string">"SAME"</span>)</span><br></pre></td></tr></table></figure><p><b>全连接层</b></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">full_connect_layer</span><span class="params">(self, X, out_filters, name)</span>:</span></span><br><span class="line">    in_filters = X.get_shape()[<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">with</span> tf.variable_scope(name) <span class="keyword">as</span> scope:</span><br><span class="line">        w_fc = tf.get_variable(<span class="string">"weight"</span>, shape=[in_filters, out_filters])</span><br><span class="line">        b_fc = tf.get_variable(<span class="string">"bias"</span>, shape=[out_filters], trainable=<span class="literal">True</span>)</span><br><span class="line">    fc = tf.nn.xw_plus_b(X, w_fc, b_fc)</span><br><span class="line">    <span class="keyword">return</span> tf.nn.relu(fc)</span><br></pre></td></tr></table></figure><p><b>Dropout</b></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dropout</span><span class="params">(self, X, keep_prob)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> tf.nn.dropout(X, keep_prob)</span><br></pre></td></tr></table></figure><p>到这里，我们就完成了卷积层、池化层、全连接层、Dropout四个模块的编写，下面我们只需要把不同模块按照AlexNet的模型累加在一起即可，</p><p><b>模型</b></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create</span><span class="params">(self, X)</span>:</span></span><br><span class="line">    X = tf.reshape(X, [<span class="number">-1</span>, <span class="number">28</span>, <span class="number">28</span>, <span class="number">1</span>])</span><br><span class="line">    conv_layer1 = self.conv_layer(X, <span class="number">11</span>, <span class="number">96</span>, <span class="number">4</span>, <span class="string">"Layer1"</span>)</span><br><span class="line">    pool_layer1 = self.pool_layer(conv_layer1, <span class="number">3</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    conv_layer2 = self.conv_layer(pool_layer1, <span class="number">5</span>, <span class="number">256</span>, <span class="number">2</span>, <span class="string">"Layer2"</span>)</span><br><span class="line">    pool_layer2 = self.pool_layer(conv_layer2, <span class="number">3</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    conv_layer3 = self.conv_layer(pool_layer2, <span class="number">3</span>, <span class="number">384</span>, <span class="number">1</span>, <span class="string">"Layer3"</span>)</span><br><span class="line">    conv_layer4 = self.conv_layer(conv_layer3, <span class="number">3</span>, <span class="number">384</span>, <span class="number">1</span>, <span class="string">"Layer4"</span>)</span><br><span class="line">    conv_layer5 = self.conv_layer(conv_layer4, <span class="number">3</span>, <span class="number">256</span>, <span class="number">1</span>, <span class="string">"Layer5"</span>)</span><br><span class="line">    pool_layer = self.pool_layer(conv_layer5, <span class="number">3</span>, <span class="number">2</span>)</span><br><span class="line">    _, x, y, z = pool_layer.get_shape()</span><br><span class="line">    full_connect_size = x * y * z</span><br><span class="line">    flatten = tf.reshape(pool_layer, [<span class="number">-1</span>, full_connect_size])</span><br><span class="line">    fc_1 = self.full_connect_layer(flatten, <span class="number">4096</span>, <span class="string">"fc_1"</span>)</span><br><span class="line">    drop1 = self.dropout(fc_1, self.keep_prob)</span><br><span class="line">    fc_2 = self.full_connect_layer(drop1, <span class="number">4096</span>, <span class="string">"fc_2"</span>)</span><br><span class="line">    drop2 = self.dropout(fc_2, self.keep_prob)</span><br><span class="line">    fc_3 = self.full_connect_layer(drop2, self.num_classes, <span class="string">"fc_3"</span>)</span><br><span class="line">    <span class="keyword">return</span> fc_3</span><br></pre></td></tr></table></figure><p>返回结果是一个<b>1*m</b>维的向量，其中m是类别数，以本文使用的MNIST为例，输入是一个<b>1*10</b>的详细，每一个数字对应于索引数字的概率值。</p><p>上述就是完整模型的搭建过程，下面我们就需要把输入传入模型，然后获取预测输出，进而构建误差函数进行训练模型。</p><p><b>训练验证</b></p><p>训练验证部分入参有3个，分别是，</p><ul><li>输入数据</li><li>标签</li><li>预测值</li></ul><p>其中输入数据和标签为占位符，会在图启动运算时传入真实数据，预测值为模型的输出，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train_val</span><span class="params">(X, y, y_)</span>:</span></span><br><span class="line">    loss = tf.reduce_mean(tf.nn.softmax_cross_entropy_with_logits(labels=y, logits=y_))</span><br><span class="line">    optimizer = tf.train.AdamOptimizer(learning_rate=LR)</span><br><span class="line">    train_op = optimizer.minimize(loss)</span><br><span class="line">    tf.summary.scalar(<span class="string">"loss"</span>, loss)</span><br><span class="line"></span><br><span class="line">    correct_pred = tf.equal(tf.argmax(y, <span class="number">1</span>), tf.argmax(y_, <span class="number">1</span>))</span><br><span class="line">    accuracy = tf.reduce_mean(tf.cast(correct_pred, tf.float32))</span><br><span class="line">    merged = tf.summary.merge_all()</span><br><span class="line">    writer = tf.summary.FileWriter(<span class="string">"logs"</span>)</span><br><span class="line">    saver = tf.train.Saver()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">        sess.run(tf.global_variables_initializer())</span><br><span class="line">        writer.add_graph(sess.graph)</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> epoch <span class="keyword">in</span> range(EPOCHS):</span><br><span class="line">            <span class="keyword">for</span> step <span class="keyword">in</span> range(MAX_STEPS):</span><br><span class="line">                batch_xs, batch_ys = mnist.train.next_batch(BATCH_SIZE)</span><br><span class="line">                summary, loss_val, _ = sess.run([merged, loss, train_op],</span><br><span class="line">                                                feed_dict=&#123;X: batch_xs, y: batch_ys&#125;)</span><br><span class="line">                print(<span class="string">"epoch : &#123;&#125;----loss : &#123;&#125;"</span>.format(epoch, loss_val))</span><br><span class="line">                writer.add_summary(summary, i)</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">        saver.save(sess, os.path.join(<span class="string">"temp"</span>, <span class="string">"mode.ckpt"</span>))</span><br><span class="line"></span><br><span class="line">        test_acc = <span class="number">0</span></span><br><span class="line">        test_count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">            batch_xs, batch_ys = mnist.test.next_batch(BATCH_SIZE)</span><br><span class="line">            acc = sess.run(accuracy, feed_dict=&#123;X: batch_xs, y: batch_ys&#125;)</span><br><span class="line">            test_acc += acc</span><br><span class="line">            test_count += <span class="number">1</span></span><br><span class="line">        print(<span class="string">"accuracy : &#123;&#125;"</span>.format(test_acc / test_count))</span><br></pre></td></tr></table></figure><p>上述就是AlexNet模型搭建和训练过程。</p><p><b>注意：</b>同一个模型在不同的数据集上表现会存在很大差异，例如LeNet是在MNIST的基础上进行搭建和验证的，因此卷积核、步长等这些超参数都已经进行了精心的调节，因此只需要按照模型搭建完成即可得到99%以上的准确率。而AlexNet是在ImageNet的图像上进行调优的，ImageNet的图像相对于MNIST<b>28*28</b>的图像要大很多，因此卷积核、步长都要大很多，但是这样对于图像较小的MNIST来说就相对较大，很难提取细节特征，因此如果用默认的结构效果甚至比不上20年轻的LeNet。这也是为什么深度学习模型可复制性差的原因，尽管是两个非常类似的任务，同一个模型在两个任务上表现得效果也会存在很大的差异，这需要工程时对其进行反复的调节、优化。</p><h1 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h1><p>如果需要完整代码可以在github搜索项目<a href="https://github.com/Jackpopc/aiLearnNotes" target="_blank" rel="noopener"><strong>aiLearnNotes</strong></a>，或者复制下方链接直接打开，</p><p><a href="https://github.com/Jackpopc/aiLearnNotes/blob/master/computer_vision/AlexNet.py" target="_blank" rel="noopener">https://github.com/Jackpopc/aiLearnNotes/blob/master/computer_vision/AlexNet.py</a></p><hr><blockquote><p>更多精彩内容，请关注公众号【平凡而诗意】~</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/10/13/uv4Na8.png&quot; alt=&quot;uv4Na8.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;前文详细介绍了卷积神经网络的开山之作&lt;b&gt;LeNet&lt;/b&gt;，虽然近几年卷积神经网络非常热门，但是在&lt;b&gt;LeNet&lt;/b&gt;出现后的十几年里，在目标识别领域卷积神经网络一直被传统目标识别算法(特征提取+分类器)所压制，直到2012年AlexNet(ImageNet Classification with Deep Convolutional&lt;br&gt;Neural Networks)
    
    </summary>
    
      <category term="计算机视觉" scheme="https://jackpopc.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
    
      <category term="CV" scheme="https://jackpopc.github.io/tags/CV/"/>
    
      <category term="AI" scheme="https://jackpopc.github.io/tags/AI/"/>
    
      <category term="图像处理" scheme="https://jackpopc.github.io/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>实用工具 | 推荐3款令人惊艳的截图工具</title>
    <link href="https://jackpopc.github.io/2019/10/11/screenshot/"/>
    <id>https://jackpopc.github.io/2019/10/11/screenshot/</id>
    <published>2019-10-11T12:35:14.000Z</published>
    <updated>2019-10-13T08:54:53.596Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>截图是我们日常生活中经常会用到的一种功能，windows虽然自带截图功能，但是功能相对单一，灵活度较差，而且连续截图非常不方便。因此很多人会选择微信、QQ等聊天工具自带的截图工具，尽管这些工具携带的截图工具相对于windows自带的好一些，但是功能依然谈不上强大，而且最致命的一点就是<a id="more"></a>，为了使用一个截图功能还要安装或打开另外一个工具，这显然是非常不方便的。</p><p>平时我也会有很多场景下需要用到截图工具，因此对截图功能的依赖相对较强，所以一直都在不断的寻觅、尝试不同的截图工具，在这个过程中试用过很多截图工具，但是有3款给我留下印象最为深刻，把这些工具推荐给大家，各位可以根据自己的需求进行选择。</p><h1 id="Snipaste"><a href="#Snipaste" class="headerlink" title="Snipaste"></a>Snipaste</h1><p><img src="https://s2.ax1x.com/2019/10/13/uvhehQ.png" alt="uvhehQ.png"></p><p>之所以第一个推荐snipaste这款截图工具，是因为这是我使用最长，也觉得最为顺手的一款截图工具，至今我依然在使用这款截图工具，虽然本文推荐3款工具，但是如果仅仅用于截图，我还是首推snipaste这款工具。</p><p>添加文字、马赛克、涂鸦等这些功能在其他很多截图工具中也非常常见，这里就不再赘述。每款工具如果深挖都能找出长篇大论的优点，我不喜欢这样繁琐而不实用的过程，我就提几点我使用过程中觉得比较实用的、具有特色的功能，</p><ul><li>自动识别边界框</li><li>贴图</li><li>快捷键</li><li>精细化截图</li></ul><p><b>自动识别边界框</b>，Snipaste能够自动识别窗口和窗口内部的按钮，当鼠标箭头指向对应位置时<b>不需要拖动鼠标</b>，即可截图。</p><p><img src="https://s2.ax1x.com/2019/10/13/uvhu1s.gif" alt="uvhu1s.gif"></p><p><b>贴图</b>，我认为这是Snipaste最大的特色之一，也是比较吸引我的一点，你能够把截取的图像贴到屏幕上，始终置定，这样无论你打开什么窗口贴图都会一直显示，这样就能够避免重复的在不同窗口之间切换，能够大大提高效率。</p><p><b>快捷键</b>，这是最初吸引我使用这款工具的原因。很多截图工具，包括windows自带的截图工具都有快捷键，为什么却偏偏Snipaste吸引到我了？因为它的快捷键设置简单、容易记忆、使用方便，<code>&lt;F1&gt;</code>截图、<code>&lt;F3&gt;</code>贴图，不需要使用复杂的组合键，这对于我这种懒的记忆的人是一个非常具有吸引力的点。</p><p><b>精细化截图</b>，截图过程中snipaste可以精确的显示鼠标所在点的<b>坐标</b>，<b>颜色</b>，它可以精确到像素级进行调整，能够精确的截图我们所需要的内容。</p><h1 id="FastStone-Capture"><a href="#FastStone-Capture" class="headerlink" title="FastStone Capture"></a>FastStone Capture</h1><p><img src="https://s2.ax1x.com/2019/10/13/uvh37T.png" alt="uvh37T.png"></p><p>Snipaste已经足够强大了，至少对于我这种仅限于静态截图的已经足够使用了。但是它并不是万能的。如果非要选择一款能够和Snipaste抗衡，能够弥补Snipaste不足的截图工具，那么一定非FastStone Capture莫属，这里提几点<b>Snipaste所不具备的功能</b>,</p><ul><li>捕捉手绘区域</li><li>录屏</li><li>滚动截屏</li></ul><p><img src="https://s2.ax1x.com/2019/10/13/uvhU39.gif" alt="uvhU39.gif"></p><p><b>捕捉手绘区域</b>，你可以通过FastStone Capture捕捉任意你希望截取的形状，这相对于大多数截图工具仅限于截图矩形框而言，的确是一个特色。</p><p><img src="https://s2.ax1x.com/2019/10/13/uvh0nx.png" alt="uvh0nx.png"></p><p><b>录屏</b>，和截图一样，录屏在很多场景下也是很常用的一个功能，例如，演示、教学、游戏等，虽然能够在网上找到很多录屏工具，但是大多数比较臃肿。相对而言，就体现出FastStone Capture的强大之处，单纯把它当作一个录屏工具它就非常强大了，在录屏时有很大的灵活性，你可以手动选择录屏区域，也可以选择窗口进行录屏，也可以选择录制全屏。</p><p><img src="https://s2.ax1x.com/2019/10/13/uvh5Hf.png" alt="uvh5Hf.png"></p><p><b>滚动截屏</b>，我们都知道现在手机端已经实现了滚动截屏，这样在我们浏览网页、分享、收藏过程中非常实用，但是电脑端却很少有截图工具实现这项功能，FastStone Capture就可以实现电脑端的滚动截屏，只需要点击<b>鼠标左键</b>它能够自动滚动截屏，非常方便。</p><h1 id="ShareX"><a href="#ShareX" class="headerlink" title="ShareX"></a>ShareX</h1><p><img src="https://s2.ax1x.com/2019/10/13/uvhhut.png" alt="uvhhut.png"></p><p>Snipaste、FastStone Capture这两款工具应该很多人都听说过或者自己也用过，因此前面就简单的介绍了一下，但是对于ShareX，我觉得需要大书特书一番，这是一款<b>不仅限于截图的强大工具</b>。</p><p>如果说snipaste和FastStone Capture主要围绕截图、录屏进行展开，那么ShareX可以说是一款强大的综合工具，甚至可以说它的功能能够让你觉得非常惊艳，可以把它称为<b>截图领域的百宝箱</b>。</p><p><b>截图</b></p><p><img src="https://s2.ax1x.com/2019/10/13/uvhq3j.png" alt="uvhq3j.png"></p><p>既然本文是以以截图展开的，那么提到ShareX还是首先讲一下它的截图功能，可以认为它是前面两款截图工具的结合体，它不仅有常见的全屏、窗口截图，它还有如下截图功能，</p><ul><li>网页捕捉</li><li>文本捕捉</li><li>滚动捕捉</li><li>录制GIF</li><li>滚动捕捉</li></ul><p>可以说是一款集截图和录制为一体的工具。</p><p><b>OCR</b></p><p><img src="https://s2.ax1x.com/2019/10/13/uv4Grt.gif" alt="uv4Grt.gif"></p><p>我们在日常工作中经常会遇到无法复制或者编辑PDF或者某些网站的文字内容，这时候我们就不得不借助一些PDF转换工具，但是效果差强人意。因此，剩下唯一的方法就是选择OCR识别文字。在之前的文章里我介绍过两款OCR工具，分别是电脑端的<b>天若OCR</b>和手机端的<b>白描</b>，其实，ShareX这款”不务正业”的截图工具也具备这项功能，它集成了OCR识别API，另外，它能够支持中文、英文、德语、法语等25种语言的识别。</p><p><b>工具箱</b></p><p><img src="https://s2.ax1x.com/2019/10/13/uvhxbV.png" alt="uvhxbV.png"></p><p>除了强大的OCR识别之外，ShareX还包含很多实用的工具集，例如，</p><ul><li>拾色器</li><li>图像合成</li><li>二维码生成和解码</li><li>尺子</li><li>哈希值检查</li><li>……</li></ul><p><b>连续动作</b></p><p><img src="https://s2.ax1x.com/2019/10/13/uv4SET.png" alt="uv4SET.png"></p><p>我觉得这是ShareX在<b>截图</b>方面对比于snipaste和FastStone Capture的一大”杀器”。</p><p>首先想一下，我们截图之后会做哪些动作？</p><ul><li>发送给别人</li><li>保存到本地</li><li>上传到图床</li></ul><p>以我为例，我平时需要维护我的个人主页，因此我截图前后需要经历以下几个步骤：</p><ul><li>截图</li><li>保存到本地</li><li>上传到图床</li><li>拷贝URL</li></ul><p>对于一副截图，我需要先后经历4个动作，因此，我在维护个人主页时最为头疼的点就是对于图片的处理，但是有了ShareX能够轻松的把这4个动作精简为一个动作。</p><p>ShareX可以定义<b>截图后的动作</b>和<b>上传后的动作</b>，例如截图后的动作包含打印、保存、复制到剪切板、上传，而上传后的动作包含分享网址、复制URL到剪切板。因此，通过配置连续的<b>截图后的动作</b>和<b>上传后的动作</b>就可以简单的截图后完成一系列的动作，我觉得这对于我来说真的解决了一个大问题。</p><p>当然，每个人都可以根据自己的工作场景自定义一个连续的动作，例如，你平时经常需要把截图打印出来，你可以定义截图后的动作为打印。如果你想快捷的使用OCR文字识别功能，你也可以把截图后的动作定义为文字识别。</p><hr><blockquote><p>更多精彩内容，请关注公众号【平凡而诗意】~</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;截图是我们日常生活中经常会用到的一种功能，windows虽然自带截图功能，但是功能相对单一，灵活度较差，而且连续截图非常不方便。因此很多人会选择微信、QQ等聊天工具自带的截图工具，尽管这些工具携带的截图工具相对于windows自带的好一些，但是功能依然谈不上强大，而且最致命的一点就是
    
    </summary>
    
      <category term="实用工具" scheme="https://jackpopc.github.io/categories/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="工具" scheme="https://jackpopc.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="实用" scheme="https://jackpopc.github.io/tags/%E5%AE%9E%E7%94%A8/"/>
    
      <category term="截图" scheme="https://jackpopc.github.io/tags/%E6%88%AA%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>大数据处理 | Spark&amp;HDFS集群配置及基本使用</title>
    <link href="https://jackpopc.github.io/2019/10/08/spark/"/>
    <id>https://jackpopc.github.io/2019/10/08/spark/</id>
    <published>2019-10-08T14:06:40.000Z</published>
    <updated>2019-10-08T14:22:49.460Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Spark简介"><a href="#Spark简介" class="headerlink" title="Spark简介"></a><strong>Spark简介</strong></h2><p><img src="https://s2.ax1x.com/2019/10/08/uhcnzV.png" alt="uhcnzV.png"></p><p>Spark是由加州伯克利大学AMP实验室于2009年开发并于2013年加入Apache的开源大数据并行计算框架，它凭借自身独有的优势迅速成为Apache三大分布式计算框架之一，对比于常用的hadoop，它具有低时延、速度快、通用性强等优点。<a id="more"></a>此外，Spark具有完善的生态系统，在资源调度方面它拥有Mesos和YARN，在存储方面它支持本地文件系统、HDFS、Amazon S3、HBase等，在数据仓库方面它拥有Hive SQL、Spark SQL，在接口方面它拥有mlib、GraphX等。</p><p>除了运算和生态方面的优势，Spark在数据处理方式方面同时支持批计算和流计算，虽然Spark在流计算方面不如storm、flink能够支持毫秒级别，但是对于大多数对实时性要求不高的在线计算已经足够使用。</p><p>基于上述众多优点使得Spark成为一个非常热门和受欢迎的大数据处理框架，目前在很多大型公司被广泛使用。</p><p>Spark不仅可以支持集群模式，还可以支持单机模式，但是我认为之所以使用大数据处理框架，它的主要优势就体现在多机并行方面，随着数据集的增加和节点数量的增加，它的对比于传统并行模式和其他大数据处理框架的优势更加明显。单机Spark配置相对集群配置相对简单一些，也节省很多步骤，因此，本文就讲解一下集群Spark配置方式，本文的配置是建立在已经配制好JDK的基础上，所以不再详细介绍JDK的安装和配置。</p><h2 id="Hadoop集群环境搭建"><a href="#Hadoop集群环境搭建" class="headerlink" title="Hadoop集群环境搭建"></a><strong>Hadoop集群环境搭建</strong></h2><p><img src="https://s2.ax1x.com/2019/10/08/uhcMsU.png" alt="uhcMsU.png"></p><p>Spark可以读取多种数据源的数据，例如Amazon s3、HBase、HDFS、本地文件系统，由于数据存放在某一个节点路径下，在Spark集群的其他节点无法直接读取相应路径下的数据，而HBase、Amazon s3这些存储服务在很多场景下很难满足，例如学校实验室。因此本文就以HDFS为例来进行讲解。</p><p>Hadoop主要包括两个部门，HDFS文件存储系统用于存储数据源，MapReduce用于从文件存储系统读取数据并进行分布式处理，由于本文只用到文件存储系统HDFS，用不到MapReduce，所以本文就配置一下集群Hadoop，讲解HDFS的使用，不深入研究MapReduce的使用。</p><p><strong>准备工作</strong></p><p>首先要保证集群中不同节点能够互相通信，然后为每个节点配置对应的hostname，后面会用到，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ vim /etc/hosts</span><br><span class="line">10.110.113.132  master</span><br><span class="line">10.110.113.133  slave0</span><br><span class="line">10.110.113.134  slave1</span><br><span class="line">10.110.113.135  slave2</span><br></pre></td></tr></table></figure><p>上述master和slave是每个节点的hostname，可以作为IP的地带，通过ping的方式可以测试hostname是否正常通信，可以在master节点上测试是否连接到不同的slave节点，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ping slave0</span><br><span class="line">或者</span><br><span class="line">$ ping 10.110.113.133</span><br></pre></td></tr></table></figure><p><strong>注：</strong>hostname的配置可以通过sudo vim /etc/hostname修改文件进行配置。</p><p><strong>ssh无密码登陆集群机器</strong></p><p>由于集群配置hadoop涉及多台机器，当在master节点启动或者关闭集群hadoop时需要输入所有slave节点的密码，这样显然太麻烦，因此需要配置无密码登陆，这样后续启动时就不需要输入密码，</p><p>首先，如果节点没有安装ssh需要安装ssh，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install ssh</span><br></pre></td></tr></table></figure><p>然后，在每个节点上输入下面命令，测试是否能够正常登陆每个节点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh localhost</span><br></pre></td></tr></table></figure><p>为了保证master节点能够无密码登陆所有slave节点，需要首先生成master节点的公钥，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen  -t  rsa</span><br></pre></td></tr></table></figure><p>一直点击确定即可，然后会在home路径下生成两个文件，id_rsa和id_rsa.pub，这时需要把id_rsa.pub的内容追加到authorized_keys后面，然后把master节点id_rsa.pub拷贝到所有slave节点并追加到所有slave节点authorized_keys的后面，</p><p>首先在master节点执行操作，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cat ~/.ssh/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys</span><br></pre></td></tr></table></figure><p>然后把master节点生成的id_rsa.pub拷贝到所有slave节点，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ scp ~/.ssh/id_rsa.pub user_name@slave0:/home/user_name/</span><br><span class="line">$ scp ~/.ssh/id_rsa.pub user_name@slave1:/home/user_name/</span><br><span class="line">$ scp ~/.ssh/id_rsa.pub user_name@slave2:/home/user_name/</span><br></pre></td></tr></table></figure><p>上述user_name是slave节点的用户名，然后把id_rsa.pub追加到每个slave节点authorized_keys的后面，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cat ~/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys</span><br></pre></td></tr></table></figure><p>然后可以在master节点上通过下方命令测试是否能够正常登陆每个slave节点，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ssh slave0</span><br><span class="line">$ ssh slave1</span><br><span class="line">$ ssh slave2</span><br></pre></td></tr></table></figure><p><strong>注意：</strong>上述都是假设master和每个slave节点的用户名user_name一样的前提下，如果不一样需要修改~/.ssh/config文件。</p><p><strong>安装Hadoop</strong></p><p><img src="https://s2.ax1x.com/2019/10/08/uhcKMT.png" alt="uhcKMT.png"></p><p>打开下面链接进入到下载页面，点击下载binary文件，把hadoop-3.2.1.tar.gz文件下载到home路径下，</p><p><a href="https://hadoop.apache.org/releases.html" target="_blank" rel="noopener">https://hadoop.apache.org/releases.html</a></p><p>然后解压下载的文件到指定目录，同时需要修改对应目录的拥有者，因为hadoop在启动后会记录日志文件，如果不修改拥有者则没有权限写入文件，无法正常启动，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo tar -zxvf ~/下载/hadoop-3.2.1.tar.gz -C /usr/local  </span><br><span class="line">$ cd /usr/local/</span><br><span class="line">$ sudo mv ./hadoop-3.2.1/ ./hadoop          </span><br><span class="line">$ sudo chown -R user_name ./hadoop</span><br></pre></td></tr></table></figure><p>然后，把hadoop路径加入到环境变量里，如果需要长期有效，需要修改~/.bashrc，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export HADOOP_HOME=/usr/local/hadoop</span><br><span class="line">export PATH=$PATH:$HADOOP_HOME/bin:$HADOOP_HOME/sbin</span><br></pre></td></tr></table></figure><p>然后保存退出，执行下面命令让环境变量生效，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ source ~/.bashrc</span><br></pre></td></tr></table></figure><p><strong>集群配置</strong></p><p>首先进入到Hadoop配置文件所在目录，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cd /usr/local/hadoop/etc/hadoop</span><br></pre></td></tr></table></figure><p>然后修改slave节点配置文件，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ vim slaves</span><br><span class="line">slave0</span><br><span class="line">slave1</span><br><span class="line">slave2</span><br></pre></td></tr></table></figure><p><strong>注意：</strong>上述slave0~2不是IP地址，是前面配置的hostname。</p><p>首先配置core-site.xml，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">   &lt;property&gt;</span><br><span class="line">      &lt;name&gt;hadoop.tmp.dir&lt;/name&gt;</span><br><span class="line">      &lt;value&gt;file:/usr/local/hadoop/tmp&lt;/value&gt;</span><br><span class="line">      &lt;description&gt;Abase for other temporary directories.&lt;/description&gt;</span><br><span class="line">   &lt;/property&gt;</span><br><span class="line">   &lt;property&gt;</span><br><span class="line">      &lt;name&gt;fs.defaultFS&lt;/name&gt;</span><br><span class="line">      &lt;value&gt;hdfs://master:9000&lt;/value&gt;</span><br><span class="line">   &lt;/property&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure><p>上述内容只需要修改<value>hdfs://master:9000</value>这一句即可，其他的不需要修改，需要根据自己定义的master节点的hostname进行修改，例如你的master节点的hostname是hadoop，那么就需要修改成<value>hdfs://hadoop:9000</value>，端口默认为9000，</p><p>然后配置hdfs-site.xml，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;dfs.replication&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;1&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure><p>这里dfs.replication默认值是3，它的含义是数据副本备份的数量，如果slave节点数量小于这个数的话则会报错，所以为了防止报错可以把这个值改为1，当然如果slave节点大于等于3的话也可以不修改。</p><p>如果需要使用MapReduce还需要配置mapred-site.xml，因为本文只使用HDFS而不实用MapReduce，因此就不配置mapred-site.xml了。</p><p>另外，如果需要yarn资源调度的话，需要修改yarn-site.xml，yarn是一个资源调度和分配工具，Spark本身自带资源管理器，也可以与yarn、Mesos结合使用，本文就使用Spark自带的资源管理器。</p><p>最后，需要在hadoop中配置JAVA环境，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ vim /usr/local/hadoop/etc/hadoop/hadoop-env.sh</span><br><span class="line">export JAVA_HOME=/path/to/java</span><br></pre></td></tr></table></figure><p>上述/path/to/java需要替换成自己JAVA安装的路径。</p><p><strong>slave节点配置</strong></p><p>上述全部操作都是在master节点进行的，下面需要配置slave节点。配置slave节点比较容易，只需要把文件打包复制到各个slave节点，解压即可，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ tar -zcf ~/hadoop.tar.gz /usr/local/hadoop</span><br><span class="line">$ scp ~/hadoop.tar.gz slave0:~/</span><br><span class="line">$ scp ~/hadoop.tar.gz slave1:~/</span><br><span class="line">$ scp ~/hadoop.tar.gz slave2:~/</span><br></pre></td></tr></table></figure><p>然后在各个slave节点上都执行下面相同操作，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo rm -rf /usr/local/hadoop</span><br><span class="line">$ sudo tar -zxvf ~/hadoop.tar.gz -C /usr/local</span><br><span class="line">$ sudo chown -R user_name /usr/local/hadoop</span><br></pre></td></tr></table></figure><p><strong>启动Hadoop集群</strong></p><p>通过上述的配置，master节点和slave节点的Hadoop都配置好了，下面需要做的就是启动集群上每个节点的Hadoop，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cd /usr/local/hadoop</span><br><span class="line">$ ./bin/hdfs namenode -format</span><br><span class="line">$ ./sbin/start-all.sh</span><br></pre></td></tr></table></figure><p><strong>注意：</strong>./bin/hdfs namenode -format这一句命令很重要，不能缺少。如果前面没有配置ssh免密登陆，执行./sbin/start-all.sh时会让输入密码。</p><p>然后在每个节点上执行下面命令，会在master节点上看到多了一个NameNode，slave节点上会多出DataNode，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ jps</span><br></pre></td></tr></table></figure><h2 id="HDFS简单使用"><a href="#HDFS简单使用" class="headerlink" title="HDFS简单使用"></a><strong>HDFS简单使用</strong></h2><p>HDFS的使用和Linux命令非常相似，例如上传数据用put，创建目录用mkdir，查看目录内容用ls，删除目录用rm，但是也有不同之处，下面就来看一下简单的示例，</p><p><strong>创建目录</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./bin/hdfs dfs -mkdir -p /hello</span><br></pre></td></tr></table></figure><p><strong>上传文件到HDFS</strong></p><p>首先先新建一个本地文件，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ vim ~/test.txt</span><br><span class="line">hello world</span><br><span class="line">hello world</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure><p>然后使用下面命令进行上传，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./bin/hdfs dfs -put ~/test.txt /hello</span><br></pre></td></tr></table></figure><p><strong>查看目录和文件内容</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ ./bin/hdfs dfs -ls /hello</span><br><span class="line">/hello/test.txt</span><br><span class="line">$ ./bin/hdfs dfs -cat /hello/test.txt</span><br><span class="line">hello world</span><br><span class="line">hello world</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure><p>然后我们就可以用Spark访问hdfs文件系统的文件，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">text_file = sc.textFile(&quot;hdfs://master:9000/hello/text.txt&quot;)</span><br></pre></td></tr></table></figure><p>文件的路径分为两部分，一部分是前面core-site.xml中配置的hostname:port，一部分是HDFS上传文件的相对路径。</p><h2 id="Spark集群环境搭建"><a href="#Spark集群环境搭建" class="headerlink" title="Spark集群环境搭建"></a><strong>Spark集群环境搭建</strong></h2><p><img src="https://s2.ax1x.com/2019/10/08/uhcQLF.png" alt="uhcQLF.png"></p><p>如果已经理解了上述Hadoop集群环境的搭建，那么学习Spark集群环境的搭建会容易很多，因为Hadoop和Spark不仅安装包目录结构非常相似，在配置方面也十分接近。均是在master节点上进行所有配置，然后打包复制到每个slave节点，然后启动集群Spark即可，下面就来详细介绍一下Spark集群环境的搭建。</p><p><strong>下载安装</strong></p><p><img src="https://s2.ax1x.com/2019/10/08/uhc1Z4.png" alt="uhc1Z4.png"></p><p>进入Spark的下载目录，</p><p><a href="https://spark.apache.org/downloads.html" target="_blank" rel="noopener">https://spark.apache.org/downloads.html</a></p><p>可以看到Spark分多个版本，有基于Hadoop构建好的，有没基于Hadoop构建的，有基于Hadoop2.6之前版本构建的，也有基于Hadoop2.7以后版本构建的，由于前面讲解Hadoop集群环境搭建时采用的是Hadoop 3.2.1，因此，而且本文需要使用HDFS依赖Hadoop，因此需要下载<strong>Pre-built</strong> <strong>for</strong> <strong>Apache Hadoop 2.7 and later</strong>,</p><p>把spark-2.4.4-bin-hadoop2.7.tgz文件下载到home路径下，然后解压到指定目录，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tar -zxvf ~/spark-2.4.4-bin-hadoop2.7.tgz -C /usr/local/</span><br></pre></td></tr></table></figure><p>然后进入目录并像Hadoop那样，修改Spark目录的拥有者，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cd /usr/local</span><br><span class="line">$ sudo mv ./spark-2.4.4-bin-hadoop2.7 ./spark</span><br><span class="line">$ sudo chowm -R user_name ./spark</span><br></pre></td></tr></table></figure><p><strong>配置环境变量</strong></p><p>修改bashrc，配置环境变量，把Spark的bin和sbin路径加入到环境变量，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ vim ~/.bashrc</span><br><span class="line">export SPARK_HOME=/usr/local/spark</span><br><span class="line">export PATH=$PATH:$SPARK_HOME/bin:$SPARK_HOME/sbin</span><br><span class="line">export PYTHONPATH=$SPARK_HOME/python:$SPARK_HOME/python/lib/py4j-0.10.7-src.zip:$PYTHONPATH</span><br><span class="line">export PYSPARK_PYTHON=python3</span><br></pre></td></tr></table></figure><p><strong>Master节点配置</strong></p><p>进入Spark目录，修改spark-env.sh文件，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd /usr/local/spark</span><br><span class="line">$ vim ./conf/spark-env.sh</span><br></pre></td></tr></table></figure><p>在spark-env.sh中添加下面内容，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export SPARK_DIST_CLASSPATH=$(/usr/local/hadoop/bin/hadoop classpath)</span><br><span class="line">export HADOOP_CONF_DIR=/usr/local/hadoop/etc/hadoop</span><br><span class="line">export  SPARK_MASTER_IP=10.110.113.132</span><br></pre></td></tr></table></figure><p>SPARK_MASTER_IP指定的是master节点的IP，后面启动集群Spark时slave节点会注册到SPARK_MASTER_IP，如果这一项不配置，Spark集群则没有可使用资源，</p><p><strong>修改slaves文件</strong></p><p>配置完master节点信息之后需要配置slave节点信息，slave节点的信息配置在slaves文件里，由于Spark目录下没有这个文件，因此需要首先从slaves.template拷贝一下，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd /usr/local/spark/</span><br><span class="line">$ cp ./conf/slaves.template ./conf/slaves</span><br></pre></td></tr></table></figure><p>然后添加如下内容，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">slave0</span><br><span class="line">slave0</span><br><span class="line">slave1</span><br></pre></td></tr></table></figure><p>需要注意的是，slaves文件里配置的是运行作业任务的节点(worker)，这样的话master的节点只作为控制节点，而不作为工作节点，如果需要把master节点的资源也充分利用起来，需要把master节点也加入到slaves文件中。</p><p><strong>slave节点配置</strong></p><p>首先在master节点上把配制好的目录进行打包，拷贝到每个slave节点上，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ cd /usr/local</span><br><span class="line">$ tar -zcf ~/spar.tar.gz ./spark</span><br><span class="line">$ scp ~/spark/tar.gz slave0:~/</span><br><span class="line">$ scp ~/spark/tar.gz slave1:~/</span><br><span class="line">$ scp ~/spark/tar.gz slave2:~/</span><br></pre></td></tr></table></figure><p>然后在每个slave节点上执行下方命令，把文件解压到相应路径下，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo rm -rf /usr/local/spark</span><br><span class="line">$ sudo tar -zxvf ~/spark.tar.gz -C /usr/local</span><br><span class="line">$ sudo chown -R user_name /usr/local/spark</span><br></pre></td></tr></table></figure><p>这样就完成了slave节点的配置。</p><p><strong>启动Spark集群</strong></p><p>如果要使用HDFS的话，在启动Spark集群前需要先启动Hadoop集群，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd /usr/local/hadoop/</span><br><span class="line">$ ./sbin/start-all.sh</span><br></pre></td></tr></table></figure><p>然后进入Spark目录，启动Spark集群，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd /usr/local/spark</span><br><span class="line">$ ./sbin/start-all.sh</span><br></pre></td></tr></table></figure><p>需要说明一下，前面配置Hadoop集群是提到，需要配置ssh免密登陆，对于Spark也是同样的道理，如果不配置ssh免密登陆的话，执行./sbin/start-all.sh会提示输入密码。</p><p>除了使用./sbin/start-all.sh启动Spark集群外，还可以分开启动，先启动master节点，然后启动slave节点，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ./sbin/start-master.sh</span><br><span class="line">$ ./sbin/start-slaves.sh</span><br></pre></td></tr></table></figure><p>如果前面没有完成<strong>Master节点配置</strong>指定master节点IP，那么执行./sbin/start-slaves.sh时则无法注册master节点的IP，这样集群计算资源则无法使用。除了配置spark-env.sh指定master节点IP外，还可以通过下面方式指定注册的master节点IP，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./sbin/start-slave.sh 10.110.113.132</span><br></pre></td></tr></table></figure><p>然后分别在master节点和slave节点执行下面命令会看到分别多出一个Master进程和Worker进程。</p><h2 id="Spark基本使用"><a href="#Spark基本使用" class="headerlink" title="Spark基本使用"></a><strong>Spark基本使用</strong></h2><p><strong>运行原理</strong></p><p>如果使用过tensorflow的话，应该对Spark的使用很容易理解，Spark的计算过程和tensorflow有相似之处。</p><p>回忆一下，我们在使用tensorflow时需要首先构造一个计算图，然后实例化一个session，然后用session.run来启动图运算。</p><p>其实Spark也是这样，RDD(弹性分布式数据集)是Spark中最重要的概念之一，它提供了一个共享内存模型。Saprk的执行过程中主要包括两个动作：转换与行动。其中转换操作就如同tensorflow中的构造计算图的过程，在这个过程中Spark构造一个有向无环图(DAG)，但是不进行运算，输入为RDD输出则是一个不同的RDD，当执行行动操作时就如同tensorflow中的session.run，开始执行运算。</p><p>Spark中有很多转换操作，例如，</p><ul><li>groupByKey</li><li>reduceByKey</li><li>sortByKey</li><li>map</li><li>filter</li><li>join</li><li>……</li></ul><p>行动操作包括，</p><ul><li>count</li><li>collect</li><li>first</li><li>foreach</li><li>reduce</li><li>take</li><li>……</li></ul><p><strong>运行模式</strong></p><p>Spark中通过master url来执行Spark的运行模式，Spark的运行模式包括本地运行、集群运行、yarn集群等，关于Spark master url的指定不同运行模式的含义如下，</p><p><strong>URL值运行模式</strong>local使用1个线程本地化运行local[K]使用K个线程本地化运行local[*]使用逻辑CPU个数数量的线程来本地化运行spark://HOST:PORT指定集群模式运行Sparkyarn-cluster集群模式连接YARN集群yarn-client客户端模式连接YARN集群mesos://HOST:PORT连接到指定的Mesos集群</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a><strong>示例</strong></h2><p>下面就以一个简单的示例把前面Hadoop和Spark串联在一起，讲解一下HDFS+Spark的使用方法。</p><p><strong>上传数据到HDFS</strong></p><p>新建一个hello_world.txt的本地文件，并在文件中添加3行hello world，然后上传至HDFS，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ cd /usr/local/hadoop/</span><br><span class="line">$ ./bin/hdfs dfs -mkdir -p /usr/hadoop</span><br><span class="line">$ touch hello_world.txt</span><br><span class="line">$ echo -e &quot;hello world \nhello world \nhello world&quot; &gt;&gt; hello_world.txt</span><br><span class="line">$ ./bin/hdfs dfs -put ./hello_world.txt /usr/hadoop</span><br></pre></td></tr></table></figure><p><strong>编写Spark程序</strong></p><p>新建一个spark.py的Python文件，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vim spark.py</span><br></pre></td></tr></table></figure><p>添加如下内容，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">from pyspark import SparkConf</span><br><span class="line">from pyspark import SparkContext</span><br><span class="line"></span><br><span class="line">conf = SparkConf().setAppName(&quot;FirstProject&quot;).setMaster(&quot;local[*]&quot;)</span><br><span class="line">sc = SparkContext.getOrCreate(conf)</span><br><span class="line">rdd = sc.textFile(&quot;hdfs:///master:9000/usr/hadoop/hello_world.txt&quot;)</span><br><span class="line">rdd.map(lambda line: line).foreach(print)</span><br></pre></td></tr></table></figure><p>然后运行程序，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ python spark.py</span><br><span class="line">hello world</span><br><span class="line">hello world</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure><p>以上就是Spark的集群配置过程和基本使用方法。</p><hr><h2 id="往期内容"><a href="#往期内容" class="headerlink" title="往期内容"></a>往期内容</h2><p><a href="https://jackpopc.github.io/2019/09/14/jupyter/#more">开发工具 | 你真的会用jupyter吗？</a></p><p><a href="https://jackpopc.github.io/2019/09/01/cnn-dropout/">【动手学计算机视觉】第十四讲：正则化之Dropout</a></p><p><a href="https://jackpopc.github.io/2019/09/13/lenet/">【动手学计算机视觉】第十五讲：卷积神经网络之LeNet</a></p><blockquote><p>更多精彩内容，请关注公众号【平凡而诗意】，或者收藏我的个人主页~</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Spark简介&quot;&gt;&lt;a href=&quot;#Spark简介&quot; class=&quot;headerlink&quot; title=&quot;Spark简介&quot;&gt;&lt;/a&gt;&lt;strong&gt;Spark简介&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/10/08/uhcnzV.png&quot; alt=&quot;uhcnzV.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;Spark是由加州伯克利大学AMP实验室于2009年开发并于2013年加入Apache的开源大数据并行计算框架，它凭借自身独有的优势迅速成为Apache三大分布式计算框架之一，对比于常用的hadoop，它具有低时延、速度快、通用性强等优点。
    
    </summary>
    
      <category term="IT技术" scheme="https://jackpopc.github.io/categories/IT%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="大数据" scheme="https://jackpopc.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="Spark" scheme="https://jackpopc.github.io/tags/Spark/"/>
    
      <category term="Hadoop" scheme="https://jackpopc.github.io/tags/Hadoop/"/>
    
  </entry>
  
  <entry>
    <title>【进阶Python】第五讲：迭代器与生成器</title>
    <link href="https://jackpopc.github.io/2019/10/08/generator-iterator/"/>
    <id>https://jackpopc.github.io/2019/10/08/generator-iterator/</id>
    <published>2019-10-08T14:03:51.000Z</published>
    <updated>2019-10-08T14:38:27.556Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h2><p>迭代是Python中常用且非常强大的一个功能，它可以用于访问集合、列表、字符串、字典等数据结构的元素。我们经常使用循环和条件语句，我们也清楚哪些是可以迭代访问，但是具体它们之间有什么有什么异同之处？有哪些特点？什么是迭代器、什么是生成器、什么是可迭代对象？这些问题对于初学者而言却是很少去细致的研究，本文就来详细阐述一下它们之间的关系已经它们的特别之处。<a id="more"></a></p><h2 id="可迭代对象"><a href="#可迭代对象" class="headerlink" title="可迭代对象"></a><strong>可迭代对象</strong></h2><p><img src="https://s2.ax1x.com/2019/10/08/uhyvcT.png" alt="uhyvcT.png"></p><p>在讲解迭代器和生成器之前，先介绍一下可迭代对象。</p><p>可迭代对象是Python中一个非常庞大的概念，它主要包括如下三类：</p><ul><li>迭代器</li><li>序列</li><li>字典</li></ul><p>从上图可以看出不同概念之间的关系，迭代器是可迭代对象的一个子集，而生成器又是迭代器的一个子集，是一种特殊的迭代器。除了迭代器之外，Python中还有序列、字典等可迭代对象。</p><p>现在已经直观的了解了可迭代对象与迭代器、生成器之间的关系，那么用Python语言怎么表述它们的区别呢？</p><ul><li><strong>可迭代对象需要实现<strong>iter</strong>方法</strong></li><li><strong>迭代器不仅要实现<strong>iter</strong>方法，还需要实现<strong>next</strong>方法</strong></li></ul><p>在使用层面，可迭代对象可以通过<strong>in</strong>和<strong>not in</strong>访问对象中的元素，举一个例子，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">X = set([1,2,3,4,5])</span><br><span class="line">print(X)</span><br><span class="line">print(type(X))</span><br><span class="line">print(1 in X)</span><br><span class="line">print(2 not in X)</span><br><span class="line">for x in X:</span><br><span class="line">    print(x)</span><br><span class="line">    </span><br><span class="line"># 输出</span><br><span class="line">&#123;1, 2, 3, 4, 5&#125;</span><br><span class="line">&lt;class &apos;set&apos;&gt;</span><br><span class="line">True</span><br><span class="line">False</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td></tr></table></figure><p>前面提到，可迭代对象实现了<strong><strong>iter</strong></strong>方法，但是它没有实现<strong><strong>next</strong></strong>，这也是判定迭代器和其他可迭代对象的关键之处，可以看一下通过next访问上述示例中可迭代对象<strong>X</strong>会报错，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">next(X)</span><br><span class="line"></span><br><span class="line"># 输出</span><br><span class="line">TypeError: &apos;set&apos; object is not an iterator</span><br></pre></td></tr></table></figure><p>报的错误是<strong>‘set’ object is not an iterator</strong>，它指明了set集合是一个可迭代对象，但不是迭代器，下面就来介绍一下迭代器。</p><h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a><strong>迭代器</strong></h2><p>迭代器是可迭代对象的一个子集，它是一个可以记住遍历的位置的对象，它与列表、元组、集合、字符串这些可迭代对象的区别就在于next方法的实现，其他列表、元组、集合、字符串这些可迭代对象可以很简单的转化成迭代器，通过Python内置的<strong>iter</strong>函数能够轻松把可迭代对象转化为迭代器，下面来看一个例子，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">X = [1,2,3,4,5]</span><br><span class="line">print(type(X))</span><br><span class="line">Y = iter(X)</span><br><span class="line">print(type(Y))</span><br><span class="line">print(next(Y))</span><br><span class="line">print(next(Y))</span><br><span class="line">print(next(Y))</span><br><span class="line"></span><br><span class="line"># 输出</span><br><span class="line">&lt;class &apos;list&apos;&gt;</span><br><span class="line">&lt;class &apos;list_iterator&apos;&gt;</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure><p>从上述示例中我们可以看出两点：</p><ul><li>通过iter函数把list转化成了迭代器</li><li>可迭代器能够记住遍历位置，能够通过next方法不断从前往后访问</li></ul><p>除了Python内置的<strong>iter</strong>之外，还可以通过Python内置的工具包<strong>itertools</strong>创建迭代器，其中函数包括，</p><ul><li>count</li><li>cycle</li><li>repeat</li><li>accumulate</li><li>chain</li><li>compress</li><li>dropwhile</li><li>islice</li><li>product</li><li>permutations</li><li>combinations</li><li>……</li></ul><p><strong>itertools</strong>中包含很多用于创建迭代器的实用方法，如果感兴趣嗯可以访问官方文档进行详细了解。</p><p>当然，也可以自己通过实现<strong><strong>iter</strong></strong>和<strong><strong>next</strong></strong>方法来定义迭代器，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Iterator(object):</span><br><span class="line">    def __init__(self, array):</span><br><span class="line">        self.x = array</span><br><span class="line">        self.index = 0</span><br><span class="line">    </span><br><span class="line">    def __iter__(self):</span><br><span class="line">        return self</span><br><span class="line">    </span><br><span class="line">    def __next__(self):</span><br><span class="line">        if self.index &lt; len(self.x):</span><br><span class="line">            value = self.x[self.index]</span><br><span class="line">            self.index += 1</span><br><span class="line">        else:</span><br><span class="line">            raise StopIteration</span><br><span class="line">        return value</span><br><span class="line">    </span><br><span class="line">it = Iterator([1,2,3,4,5])</span><br><span class="line">print(type(it))</span><br><span class="line">for i in it:</span><br><span class="line">    print(i)</span><br><span class="line"></span><br><span class="line"># 输出</span><br><span class="line">&lt;class &apos;__main__.Iterator&apos;&gt;</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td></tr></table></figure><h2 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a><strong>生成器</strong></h2><p>从文章开头的流程图可以直观的看出，生成器是迭代器的子集，换句话说，生成器一定是迭代器，但是迭代器不全是生成器对象。</p><p>提及生成器就不得不提及一个Python中的关键字<strong>yiled</strong>，在Python中一个函数可以用yiled替代return返回值，这样的话这个函数就变成了一个生成器对象，举个例子对比一下，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def generator(array):</span><br><span class="line">    for i in array:</span><br><span class="line">        return i</span><br><span class="line">    </span><br><span class="line">gen = generator([1,2,3,4,5])</span><br><span class="line">print(type(gen))</span><br><span class="line"></span><br><span class="line"># 输出</span><br><span class="line">&lt;class &apos;int&apos;&gt;</span><br></pre></td></tr></table></figure><p>这是我们常见的return返回方式，这样的话generator函数获取的是一个int型对象，下面看一下换成yield关键字，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def generator(array):</span><br><span class="line">    for i in array:</span><br><span class="line">        yield(i)</span><br><span class="line">        </span><br><span class="line">gen = generator([1,2,3,4,5])</span><br><span class="line">print(type(gen))</span><br><span class="line"></span><br><span class="line"># 输出</span><br><span class="line">&lt;class &apos;generator&apos;&gt;</span><br></pre></td></tr></table></figure><p>这样的话获取的是一个生成器generator，除了yield之外，在Python3.3之后还加入了<strong>yield from</strong>获取生成器，允许一个生成器将其部分操作委派给另一个生成器，使得生成器的用法变得更加简洁，<strong>yield from</strong>后面需要加上可迭代对象，这样可以把可迭代对象变成生成器，当然，这里的可迭代对象不仅包含列表、元组，还包含迭代器、生成器。<strong>yield from</strong>相对于<strong>yield</strong>的有几个主要优点：</p><ul><li>代码更加简洁</li><li>可以用于生成器嵌套</li><li>易于异常处理</li></ul><p>下面就从简洁代码方面举个例子说明一下，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">def generator(array):</span><br><span class="line">    for sub_array in array:</span><br><span class="line">        yield from sub_array</span><br><span class="line"></span><br><span class="line">gen = generator([(1,2,3), (4,5,6,7)])</span><br><span class="line"></span><br><span class="line"># 输出</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td></tr></table></figure><p>当我们需要访问多层/多维可迭代对象时，我们就不需要逐层的去用<strong>for … in …</strong>去访问，可以简单的通过yiled from把生成器委派给子生成器，除此之外还可以通过<strong>生成器表达式</strong>的方法得到生成式，后面会介绍。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">print(next(gen))</span><br><span class="line">print(next(gen))</span><br><span class="line"></span><br><span class="line"># 输出</span><br><span class="line">1</span><br><span class="line">2</span><br></pre></td></tr></table></figure><p>通过上面示例可以看出，生成器可以像迭代器那样使用iter和next方法。</p><p>读到这里可以会有疑惑，从这个示例看来生成器和迭代器并没有什么区别啊？为什么生成器还可以称得上是Python中的一大亮点？</p><p>首先它对比于迭代器在编码方面更加简洁，这是显而易见的，其次生成器运行速度更快，最后一点，也是需要着重说明的一点：节省内存。</p><p>也许在一些理论性实验、学术论文阶段可以不考虑这些工程化的问题，但是在公司做项目时，内存和资源占用是无法逃避的问题 。如果我们使用其他可迭代对象处理庞大的数据时，当创建或者返回值时会申请用于存储整个可迭代对象的内存，显然这是非常浪费的，因为有的元素当前我们用不到，也不会去访问，但它却一直占用这内存。这时候就体现了生成器的优点，它不是一次性把所有的结果都返回，而是当我们每读取一次，它会返回一个结果，当我们不读取时，它就是一个生成器表达式，几乎不占用内存。</p><h2 id="生成器表达式"><a href="#生成器表达式" class="headerlink" title="生成器表达式"></a><strong>生成器表达式</strong></h2><p>首先来看一个对比示例，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">X = [1, 2, 3, 4, 5]</span><br><span class="line">it = [i for i in X]</span><br><span class="line">gen = (i for i in X)</span><br><span class="line">print(type(X))</span><br><span class="line">print(type(it))</span><br><span class="line">print(type(gen))</span><br><span class="line"></span><br><span class="line"># 输出</span><br><span class="line">&lt;class &apos;list&apos;&gt;</span><br><span class="line">&lt;class &apos;list&apos;&gt;</span><br><span class="line">&lt;class &apos;generator&apos;&gt;</span><br></pre></td></tr></table></figure><p>首先说一下<strong>it = [i for i in X]</strong>，这种用法叫做<strong>列表生成式</strong>，在很多编程规范中非常推崇的一种替代for循环的方式，仔细看一下代码会发现，<strong>it = [i for i in X]</strong>与<strong>gen = (i for i in X)</strong>的区别非常小，只是一个用了中括号，一个用了小括号，但是它们的区别缺失非常大的，使用中括号的叫做列表生成式，获得的返回值是一个列表，而使用小括号叫做生成器表达式，获得的返回结果是一个生成器，这也是前面提到的，除了使用yield和yield from两个关键字外还可以使用生成器表达式获得生成器。</p><hr><h2 id="往期内容"><a href="#往期内容" class="headerlink" title="往期内容"></a>往期内容</h2><p><a href="https://jackpopc.github.io/2019/09/14/jupyter/#more">开发工具 | 你真的会用jupyter吗？</a></p><p><a href="https://jackpopc.github.io/2019/09/01/cnn-dropout/">【动手学计算机视觉】第十四讲：正则化之Dropout</a></p><p><a href="https://jackpopc.github.io/2019/09/13/lenet/">【动手学计算机视觉】第十五讲：卷积神经网络之LeNet</a></p><blockquote><p>更多精彩内容，请关注公众号【平凡而诗意】，也可以收藏我的个人主页~</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;迭代是Python中常用且非常强大的一个功能，它可以用于访问集合、列表、字符串、字典等数据结构的元素。我们经常使用循环和条件语句，我们也清楚哪些是可以迭代访问，但是具体它们之间有什么有什么异同之处？有哪些特点？什么是迭代器、什么是生成器、什么是可迭代对象？这些问题对于初学者而言却是很少去细致的研究，本文就来详细阐述一下它们之间的关系已经它们的特别之处。
    
    </summary>
    
      <category term="Python" scheme="https://jackpopc.github.io/categories/Python/"/>
    
    
      <category term="编程" scheme="https://jackpopc.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Python" scheme="https://jackpopc.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>实用工具 | 推荐10款令人惊艳的免费手机APP</title>
    <link href="https://jackpopc.github.io/2019/09/22/app/"/>
    <id>https://jackpopc.github.io/2019/09/22/app/</id>
    <published>2019-09-22T03:54:28.000Z</published>
    <updated>2019-09-22T06:18:15.987Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我是一个对各种软件、APP充满着好奇心的人，空闲的时候就会打开应用市场，花费上几分钟时间看一下最近有没有什么新鲜的APP。</p><p>我也是一个非常挑剔的人，尽管一个APP相对于整部手机的内存可以忽略不计，但是当体验APP时不足以令我惊艳时我还是会毫不犹豫的把它卸载。</p><p><a id="more"></a>久而久之，我手机上的APP并没有多起来，但是经过各种筛选留下来的我认为都是有很多亮点的。本文就推荐10款不错的APP，后续如果遇到什么好用的APP会再次推荐。</p><blockquote><p>备注：个人使用的是荣耀手机，所以下述APP均可在华为应用市场下载，其他Android系统的品牌手机应该也可以找到对应的APP。</p></blockquote><h1 id="1-一个木涵"><a href="#1-一个木涵" class="headerlink" title="1. 一个木涵"></a>1. 一个木涵</h1><p><img src="https://s2.ax1x.com/2019/09/22/uptnmD.png" alt="uptnmD.png"></p><p>我认为这款APP可以称得上”APP中的百宝箱”，它一款APP集合了几十甚至上百款APP的功能，它的包括但不限于如下功能，</p><ul><li>OCR图片文字识别</li><li>文件清理</li><li>植物识别</li><li>动物识别</li><li>菜品识别</li><li>果蔬识别</li><li>历史上的今天</li><li>进制转换</li><li>画板</li><li>时间屏幕</li><li>汇率转换</li><li>快递查询</li><li>网速测试</li><li>指南针</li><li>二维码生成</li><li>GIF合成</li><li>表情制作</li><li>获取壁纸</li><li>……</li></ul><h1 id="2-全历史"><a href="#2-全历史" class="headerlink" title="2. 全历史"></a>2. 全历史</h1><p><img src="https://s2.ax1x.com/2019/09/22/uptu0e.png" alt="uptu0e.png"></p><p>当我体验一段时间全历史这款APP时我被惊艳了，令人耳目一新。</p><p>我是一个历史爱好者，也是我坚持时间最长的一个兴趣爱好，但是这么多年来有关历史的书籍、工具从没有让我眼前一亮的感觉，大多数都是枯燥乏味、千篇一律、高深莫测，也许这就是越来越少的人喜欢历史的原因吧。</p><p>当我看到这一款APP时，我感觉它真的与众不同，它包含历史地图、关系图谱、国家历史、古书籍、画作、疆域变迁等内容。以<b>时间轴</b>的方式直观展现历史的变迁和上下承接关系，非常吸引人。另外，关系图谱这项功能引起了我的极大兴趣，它直观的展现你所关注人物的关系网络，甚至可以推至几百年前，让你觉得原来历史这么奇妙。</p><h1 id="3-咔嗒"><a href="#3-咔嗒" class="headerlink" title="3. 咔嗒"></a>3. 咔嗒</h1><p><img src="https://s2.ax1x.com/2019/09/22/uptKTH.png" alt="uptKTH.png"></p><p>多媒体盛行的时代，图像在里面占据着不可替代的地位。我同样也是一个摄影爱好者，每当去到一个地方喜欢拍着一些体现不同风土人情、自然风貌的照片。但是我又是一个对修图一窍不通的人，因此每当和朋友谈起不修图时我美其名曰”我喜欢自然、原始的样貌”。其实，适当的修图能够让一幅图像更加有意境，更加吸引人。但是PS这些技术太难学了，虽然近几年所谓的“一键美化”工具层出不穷，但是我觉得99%的APP都是噱头，与其说一键美化，倒不如说是“一键不伦不类”。</p><p>当体验咔嗒这款APP时我并没有抱多大希望，但是体验后顿时让我改观，效果真的让其他美化APP黯然失色。它是一款基于AI的美化工具，能够精准识别图像中的物体，例如汽车、天空、海、建筑物等，然后根据不同的场景选择对应的滤镜对其进行美化，真正可以称得上“一键美化”，上图中左图为原图，右图为一键美化的图片，没有经过任何手动调整的图片。</p><h1 id="4-不做手机控"><a href="#4-不做手机控" class="headerlink" title="4. 不做手机控"></a>4. 不做手机控</h1><p><img src="https://s2.ax1x.com/2019/09/22/uptltA.png" alt="uptltA.png"></p><p>手机在我们生活中的地位越来越无法取代，学习时、工作时、走路时、吃饭时、排队时…无论何时何地总是不乏低头族。慢慢的手机成了让人又爱又恨的东西，它的确给生活带来了很大的便捷和乐趣，但是也的确占据了很多宝贵的时光。可是没办法，自制力是一件很难做到的事情，仅凭自己的意志太困难了。</p><p>和美化工具一样，近几年批判手机负面影响的人越来越多的同时，习惯养成类APP也层出不穷，但是我认为大多数都是在向用户进行妥协，在一些不痛不痒的地带进行约束，制约权还是在用户自身。我觉得不做手机控是一个另类，它相比于其他APP要求更高的权限，当然，它的控制力度更强，当你在计划工作时间内它可以约束除白名单外的任何APP，连自己都无法解开，除非消耗积分。此外，它还有睡眠计划、白噪声、手机使用统计等实用功能，让你对自己的使用情况一目了然。</p><h1 id="5-Stork"><a href="#5-Stork" class="headerlink" title="5. Stork"></a>5. Stork</h1><p><img src="https://s2.ax1x.com/2019/09/22/upt1fI.png" alt="upt1fI.png"></p><p>Stork中文名文献鸟，是一款由斯坦福大学研究人员开发的一款文献追踪神器。</p><p>对于高校学生、科研人员，或者从事偏研究性质岗位的工作人员而言，需要不断的跟踪自己所在领域的前言成果。当然这有很多种方法，可以用谷歌学术订阅对应作者的动态，可以每天关注arXiv，但是我个人并不喜欢这样的方式，以谷歌学术为例，假如我订阅李飞飞的相关文章，她每年挂名的文章可能多达几十篇，而且我认为其中90%是不值得花费时间看的，换句话说，通过arXiv和谷歌学术追踪到的信息很多是没价值的。</p><p>而Stork不同，你可以灵活使用这款APP，可以像谷歌学术那样通过作者名进行订阅，也可以通过关键字进行订阅，它会按照你自己规定的推送频率给你邮件推送相关文章，按照影响因子进行排序，同时还会提供相应文章的下载链接，非常方便。</p><h1 id="6-句读"><a href="#6-句读" class="headerlink" title="6. 句读"></a>6. 句读</h1><p><img src="https://s2.ax1x.com/2019/09/22/uptYX8.png" alt="uptYX8.png"></p><p>优美的句子总是在不经意之间直击人的心灵深处，</p><blockquote><p>人在无端微笑时，不是百无聊赖，就是痛苦难当。(王小波《黄金时代》)</p></blockquote><p>我只所以继续句读这款APP是因为它的特立独行，信息爆炸的时代，各种文字类相关的APP都变了味道，每天推送数不清的文章，而大多数都是没有任何印象的内容，这就锻炼一个人从嘈杂内容中过滤有价值信息的能力。还好有这款句读APP，它每天精选一句话，仅仅一句话，从社区中提炼出一句热门、优美的句子。也许每天你只需要停留5秒钟，久而久之就会发现自己收获了很多。</p><h1 id="7-白描"><a href="#7-白描" class="headerlink" title="7. 白描"></a>7. 白描</h1><p><img src="https://s2.ax1x.com/2019/09/22/uptNnS.png" alt="uptNnS.png"></p><p>图片和PDF转换成可编辑的文字一直以来都是一件令人困扰的事情，转化后的文本混乱，质量差。因此，一直以来我并不信任各种所谓的OCR工具，直到遇到白描这款APP，能够精准、高效的识别图片中的文字，转换后的文本整洁、干净，同时速度非常快，可以看一下上图中识别图片中文字的效果。</p><p>另外需要说明一下，普通用户每天限制识别5次，我觉得这对于大多数用户已经足够使用甚至用不完。</p><h1 id="8-夜间护眼"><a href="#8-夜间护眼" class="headerlink" title="8. 夜间护眼"></a>8. 夜间护眼</h1><p><img src="https://s2.ax1x.com/2019/09/22/upta7Q.png" alt="upta7Q.png"></p><p>我们对手机的依赖越来越重，看书、追剧、看新闻、社交等等，每天眼睛对着屏幕的时间占比非常高，久而久之，对眼睛的伤害自然很严重。一些手机制造商逐渐的开始在手机中加入夜间模式，其实完全没有必要苦苦等待一个定制化的系统功能，不如尝试一下夜间护眼这款APP，它支持夜间、助眠、阅读、游戏等模式，还支持手动调节屏幕颜色，能够针对不同场景设置不同的屏幕颜色，这样在保证我们使用手机的舒适感的情况下同时保护了我们的眼睛。</p><p>此外，它还有很多实用的小功能，例如强制横屏让你的手机秒变平板、视力测试等。</p><h1 id="9-讯飞语记"><a href="#9-讯飞语记" class="headerlink" title="9. 讯飞语记"></a>9. 讯飞语记</h1><p><img src="https://s2.ax1x.com/2019/09/22/upt0ts.png" alt="upt0ts.png"></p><p>我认为养成记录是一个很不错的习惯，俗话说“好记忆不如一个烂笔头”，但是道理都懂，记录是一件让人觉得很麻烦的事情。讯飞语记让这件事情变的简单起来，讯飞在语音识别领域的积淀自然不用多讲，非常厉害，它能够通过对你说话的语音进行快速、准确的识别，然后做好记事记录。此外，它不仅限于一款语音记事APP，它还支持文字识别、待办事项，同时还可以用于笔记排版。</p><p>此外，语言方面讯飞语记在语言/方言方面支持普通话、英语、粤语、四川话、东北话、河南话、山东话、上海话、武汉话、闽南语。</p><h1 id="10-藏书馆"><a href="#10-藏书馆" class="headerlink" title="10. 藏书馆"></a>10. 藏书馆</h1><p><img src="https://s2.ax1x.com/2019/09/22/uptI91.png" alt="uptI91.png"></p><p>也许，电子阅读有很多利润可图，因此，越来越多的互联网、传统出版公司开始进入这一块领域。那些被夸赞的天花烂坠的阅读APP试用了很多，无一例外，均采用<strong>少量免费诱导，然后让你不得不付费的手段</strong>，直到我遇到藏书馆这款APP，可以说让我<strong>豁然开朗</strong>，和其他电子阅读千篇一律的模式不同，藏书馆采用<strong>开放、共享</strong>的运营模式，其他书友可以在这里分享他们的书籍，然后你可以免费的借阅，这就给这款阅读APP带来两个无法比拟的优势：</p><ul><li>免费</li><li>资源丰富</li></ul><p>例如，前段时间朋友向我推荐了一本曼昆的《经济学原理》，我在多款APP上都没有找到这本书籍，最终却在藏书馆这款APP上找到很多阅读资源。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;我是一个对各种软件、APP充满着好奇心的人，空闲的时候就会打开应用市场，花费上几分钟时间看一下最近有没有什么新鲜的APP。&lt;/p&gt;
&lt;p&gt;我也是一个非常挑剔的人，尽管一个APP相对于整部手机的内存可以忽略不计，但是当体验APP时不足以令我惊艳时我还是会毫不犹豫的把它卸载。&lt;/p&gt;
&lt;p&gt;
    
    </summary>
    
      <category term="实用工具" scheme="https://jackpopc.github.io/categories/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="实用工具" scheme="https://jackpopc.github.io/tags/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/"/>
    
      <category term="APP" scheme="https://jackpopc.github.io/tags/APP/"/>
    
      <category term="手机" scheme="https://jackpopc.github.io/tags/%E6%89%8B%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>通用技术 | 正则表达式</title>
    <link href="https://jackpopc.github.io/2019/09/21/regex/"/>
    <id>https://jackpopc.github.io/2019/09/21/regex/</id>
    <published>2019-09-21T11:52:57.000Z</published>
    <updated>2019-09-22T06:17:55.788Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>正则表达式(Regular Expression)是一种既简单，又使用非常广泛的一种技术，我在题目中称其为”必会技术”，这并不夸张，无论是从事开发工作还是做一些文案类工作，甚至日常使用电脑搜索一个文件，都会接触到正则表达式。当然，在很多场景下不使用正则表达式也可以完成同样的工作，但是相对要麻烦很多。</p><a id="more"></a>正则表达式，不熟悉的人第一眼看上去很容易把它认为是一种数学或者其他理工科中的一种表达公式，其实它和公式并没有太大关系。正则表达式是一种文本匹配模式，它能够使用一个或多个简单的字符，去描述匹配一些复杂句法的规则，例如网页、身份证号、出生年月日、家庭住址等。正是因为它的简单且不失强大的特性，它在很多地方都有着应用，一下举几个例子，- everything文件搜索- Python、JS、PHP相关开发- pycharm、sublime等编辑器及IDE- 爬虫- ......也许说到这里还是有一些同学感觉云里雾里，下面就以一个简单的例子来说明一下。<b>假如</b>，给你一个长篇的文章或者上万字的网页，你想从其中匹配出里面的信息，例如<b>身份证号</b>，你会怎么办？当然，这有很多种方法，甚至可以采用最笨的遍历方法去寻找，但是这并不是一个聪明的选择，我们这时就可以使用一个简短的正则表达式来进行匹配，假设下面是要匹配的文本，在陆游的《钗头凤·红酥手》和唐婉的《钗头凤·世情薄》之间插入一个18位、末位为X的假身份证号，<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">红酥手，黄縢酒，满城春色宫墙柳。东风恶，欢情薄。一怀愁绪，几年离索。错、错、错。</span><br><span class="line">春如旧，人空瘦，泪痕红浥鲛绡透。桃花落，闲池阁。山盟虽在，锦书难托。莫、莫、莫！</span><br><span class="line">23453419901011908X</span><br><span class="line">世情薄，人情恶，雨送黄昏花易落。晓风干，泪痕残，欲笺心事，独语斜阑。难，难，难！</span><br><span class="line">人成各，今非昨，病魂常似秋千索。角声寒，夜阑珊，怕人寻问，咽泪装欢。瞒，瞒，瞒！</span><br></pre></td></tr></table></figure><p>对于文本中身份证号的匹配就可以使用下面这段正则表达式，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(\d&#123;18&#125;)|([0-9]&#123;17&#125;(X|x$))</span><br></pre></td></tr></table></figure><p>看一下匹配结果，</p><p><img src="https://s2.ax1x.com/2019/09/22/upNPu8.png" alt="upNPu8.png"></p><p>在解释上述正则表达式含义之前，我们首先想一下身份证号有哪些特点，</p><ul><li>身份证号长度为15位或者18位</li><li>末位为数字或者大写X或者小写x</li></ul><p>以上述文本为例，身份证号长度为18、末位为X，下面来看一下上述正则表达式，</p><p>正则表达式中竖线 <b>|</b> 表示“或”的意思，可以在多个片段中进行选择，所以上述正则表达式可以分为2部分，</p><ol><li>(\d{18})</li><li>([0-9]{17}(X|x$))</li></ol><p>其中<b>(\d{18})</b>中<b>\d</b>匹配任意数字，后面大括号是对前面子表达式的限定符，括号里为整数，表示的含义是匹配前面子表达式的次数，因此这个表达式的含义就是匹配<b>\d</b>18次，换句话说就是匹配数字18次，而有些身份证号就是18位的纯数字，因此这个表达式可以匹配18位纯数字的身份证号。</p><p>然后再看<b>([0-9]{17}(X|x$))</b>，这里面[0-9]和\d的含义是相同的，匹配0-9之间的数字，后面的17的含义是匹配前面数字17次，然后<b>X|x$</b>的含义是以X或x结尾，$是匹配结尾的含义，因此这个表达式的含义就是匹配另外一种身份证号，前面为数字末位为X或x的身份证号。</p><p>到这里，就应该了解了上述正则表达式的含义，匹配两种身份号，一种为纯数字，一种末位为X或x。</p><p>当然，正则表达式的价值远不止于匹配身份证号这么简单，它可以用于一些自然语言处理的数据粗提取，可以用于网页爬虫去匹配一些网页内容、网页链接，同时还可以用于linux命令行的字符、文件匹配。</p><p>读到这里应该就明白，正则表达式就是<b>一些具有特殊含义字符以不同方式组合在一起形成的文本匹配模式</b>，因此，学习正则表达式的关键点也就很明确了，需要了解不同字符的含义，下面就来详细介绍一下。</p><h1 id="字符分类"><a href="#字符分类" class="headerlink" title="字符分类"></a>字符分类</h1><p>我把正则表达式的字符分为如下三类分别进行讲解，</p><ul><li>元字符</li><li>限定字符</li><li>特殊字符</li></ul><h1 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h1><p><b>开头和结尾</b></p><div class="table-container"><table><thead><tr><th style="text-align:center">字符</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">^</td><td style="text-align:center">匹配字符字符串的开始位置</td></tr><tr><td style="text-align:center">$</td><td style="text-align:center">匹配字符字符串的结尾位置</td></tr></tbody></table></div><p>假如待匹配的文本如下，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hello</span><br><span class="line">elloh</span><br><span class="line">llohe</span><br></pre></td></tr></table></figure><p>正则表达式及匹配结果为，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">^h.+   # 正则表达式</span><br><span class="line">hello  # 匹配结果</span><br><span class="line"></span><br><span class="line">.+e$   # 匹配结果</span><br><span class="line">llohe  # 匹配结果</span><br></pre></td></tr></table></figure><p><b>匹配次数相关字符</b></p><div class="table-container"><table><thead><tr><th style="text-align:center">字符</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">*</td><td style="text-align:center">匹配前面子表达式0次或多次</td></tr><tr><td style="text-align:center">+</td><td style="text-align:center">匹配前面子表达式1次或多次</td></tr><tr><td style="text-align:center">？</td><td style="text-align:center">匹配前面子表达式0次或1次</td></tr></tbody></table></div><p>假设待匹配文本为，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">helloooo</span><br></pre></td></tr></table></figure><p>正则表达式及匹配结果为，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">lo+    # 正则表达式</span><br><span class="line">loooo  # 匹配结果</span><br><span class="line"></span><br><span class="line">lo*    # 正则表达式</span><br><span class="line">l      # 匹配结果</span><br><span class="line">loooo  </span><br><span class="line"></span><br><span class="line">lo?    # 正则表达式</span><br><span class="line">l      # 匹配结果</span><br><span class="line">lo</span><br></pre></td></tr></table></figure><h1 id="限定字符"><a href="#限定字符" class="headerlink" title="限定字符"></a>限定字符</h1><p>前面讲到的可以用一些元字符来匹配“次数”相关的字符，但是这些都是模糊的匹配，零次或多次、零次或1次、1次或多次，不够精确。除了这些元字符外还可以通过限定符来匹配准确数量的字符，限定符是以大括号进行标识，</p><div class="table-container"><table><thead><tr><th style="text-align:center">字符</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">{n}</td><td style="text-align:center">匹配前面子表达式n次</td></tr><tr><td style="text-align:center">{n,}</td><td style="text-align:center">匹配前面子表达式至少n次</td></tr><tr><td style="text-align:center">{n,m}</td><td style="text-align:center">匹配前面子表达式至少n次，最多m次</td></tr></tbody></table></div><p>假设待匹配为，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1919190380384083</span><br></pre></td></tr></table></figure><p>正则表达式及匹配结果为，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[0-9]&#123;4&#125;    # 正则表达式</span><br><span class="line">1919        # 匹配结果</span><br><span class="line">1903</span><br><span class="line">8038</span><br><span class="line">4083</span><br></pre></td></tr></table></figure><h1 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h1><p>有一些特殊字符在不同的场景下含义不尽相同，例如？紧跟一个字表达式，含义是匹配0次或者1次，如果跟随其他次数限定相关的字符，它就变成了非贪婪的，也就是说它就会使得匹配次数限定为“较少”的一方，例如<em>的含义是匹配0次或者多次，那么\</em>？就是匹配0次，而不能匹配多次，这就是非贪婪的含义。此外，^和正常字符在一起使用时表示匹配字符的开头，但是在中括号内使用时就成为反向范围的含义，例如[abc]匹配包括a或者b或者c，而[\^abc]的含义是匹配除a\b\c以外的任意字符，下面对特殊字符进行详细说明一下，</p><div class="table-container"><table><thead><tr><th style="text-align:center">字符</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">a\</td><td style="text-align:center">b</td><td>匹配a或b</td></tr><tr><td style="text-align:center">[abc]</td><td style="text-align:center">字符集合，匹配a或b或c</td></tr><tr><td style="text-align:center"><sup><a href="#fn_abc" id="reffn_abc">abc</a></sup></td><td style="text-align:center">反向范围，匹配a、b、c以外任意字符</td></tr><tr><td style="text-align:center">[a-z]</td><td style="text-align:center">匹配a-z26个字母</td></tr><tr><td style="text-align:center"><sup><a href="#fn_a-z" id="reffn_a-z">a-z</a></sup></td><td style="text-align:center">匹配不在a-z之间的任意字符</td></tr><tr><td style="text-align:center">\b</td><td style="text-align:center">匹配单词边界，和^、$类似</td></tr><tr><td style="text-align:center">\B</td><td style="text-align:center">\b的反义，匹配非单词边界</td></tr><tr><td style="text-align:center">\d</td><td style="text-align:center">匹配数字</td></tr><tr><td style="text-align:center">\D</td><td style="text-align:center">匹配非数字</td></tr><tr><td style="text-align:center">\s</td><td style="text-align:center">匹配任何空白字符，包括空格、制表符、换页符</td></tr><tr><td style="text-align:center">\S</td><td style="text-align:center">匹配任何非空白字符</td></tr><tr><td style="text-align:center">\w</td><td style="text-align:center">匹配字母、数字、下划线</td></tr><tr><td style="text-align:center">\W</td><td style="text-align:center">匹配非字母、数字、下划线</td></tr><tr><td style="text-align:center">\f</td><td style="text-align:center">匹配换页符</td></tr><tr><td style="text-align:center">\n</td><td style="text-align:center">匹配换行符</td></tr><tr><td style="text-align:center">\r</td><td style="text-align:center">匹配回车符</td></tr><tr><td style="text-align:center">\t</td><td style="text-align:center">匹配制表符</td></tr></tbody></table></div><p>上述就是我们常用的正则表达式符号，可以根据我们的需求，对上述这些字符进行任意的组合，来完成我们的匹配、查询、替换等工作。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;正则表达式(Regular Expression)是一种既简单，又使用非常广泛的一种技术，我在题目中称其为”必会技术”，这并不夸张，无论是从事开发工作还是做一些文案类工作，甚至日常使用电脑搜索一个文件，都会接触到正则表达式。当然，在很多场景下不使用正则表达式也可以完成同样的工作，但是相对要麻烦很多。&lt;/p&gt;
    
    </summary>
    
      <category term="IT技术" scheme="https://jackpopc.github.io/categories/IT%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="编程" scheme="https://jackpopc.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="正则表达式" scheme="https://jackpopc.github.io/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
      <category term="开发" scheme="https://jackpopc.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>开发工具 | 你真的会用jupyter吗？</title>
    <link href="https://jackpopc.github.io/2019/09/14/jupyter/"/>
    <id>https://jackpopc.github.io/2019/09/14/jupyter/</id>
    <published>2019-09-14T10:58:21.000Z</published>
    <updated>2019-10-10T11:30:45.475Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><img src="https://s2.ax1x.com/2019/09/16/nfW7c9.jpg" alt="nfW7c9.jpg"></p><p>提起jupyter notebook，应该很多学习过Python的同学都不模型。虽然用jupyter notebook的同学相对较少，但是提及这款开发工具，很多人都会赞不绝口，“jupyter很强大，交互式、富文本”，很多人都知道jupyter notebook的这几个优点，<a id="more"></a>但是，试问一下，你真的会用jupyter吗？</p><p>以Python开发为例，我们只需要在windows命令行或者linux/Mac终端输入“jupyter notebook”或者“ipython notebook”即可使用默认浏览器打开一个在线IDE，</p><p><img src="https://s2.ax1x.com/2019/10/08/uh2NDO.png" alt="uh2NDO.png"></p><p>首先说一下交互式，</p><p>jupyter notebook中一个非常重要的概念就是cell，每个cell能够单独进行运算，这样适合于代码调试。我们开发一个完整的脚本时变量会随着代码执行的结束而从内存中释放，如果我们想看中间的变量或者结构，我们只能通过断点或者输出日志信息的方式进行调试，这样无疑是非常繁琐的，如果一个程序运行很多这种方式还可行，如果运行时间长达几个小时，这样我们调试一圈耗费的时间就太长了。</p><p>而在jupyter notebook中我们可以把代码分隔到不同的cell里逐个进行调试，这样它会持续化变量的值，我们可以交互式的在不同cell里获取到我们想要测试的变量值和类型。</p><p><img src="https://s2.ax1x.com/2019/10/08/uh2UbD.png" alt="uh2UbD.png"></p><p>然后说一下富文本，</p><p>开发代码不仅是给机器去“阅读”，也需要让其他的同事、同学能够很容易的阅读，因此，注释就在开发过程中变的非常重要，一个完善的注释能够让周围人更加容易理解，协作效率也更高，避免重复性劳动。在大多数IDE中都可以进行注释，但是几乎都是相同的，只支持一些简单的文本格式注释，这显然是不够的，jupyter notebook支持Markdown编辑，它的cell不仅可以用于编码，还可以用于书写文本，Markdown可以轻松完成标题、数学公式等格式的编辑，更加有助于解释代码，适用于教学等场景。</p><p>最后在说一下轻量、触手可及，</p><p>开发过程中我经常需要测试一个小的代码块或者函数，这时候有两个选择：在IDE中新建一个测试脚本；打开命令行下的Python。我觉的这两个都不是好的选择，如果在项目下新建一个脚本后续还需要记住把它清理掉，如果写一个完善的测试脚本用于Alpha、beta测试这显然是低效不现实的。而选择在命令行下，界面不友好，操作不灵活，体验更差。</p><p>这时候就显现出jupyter notebook的优势，只需要输入jupyter notebook就会在流量器中打开一个网页，能轻量、快捷的进行开发验证，效率很好。此外，我们还可以通过搭建jupyter notebook服务使得它一直在服务器下运行来避免每次需要时都要在命令行下重复打开，我们只需要在浏览器打开对应的网页即可，这一点下文会详细介绍。</p><p>其实，除了这些我们耳熟能详的优点之外，jupyter还有很多令人惊叹的亮点：</p><ul><li>丰富的插件</li><li>主题修改</li><li>多语言支持</li></ul><p>下面就针对这3点分别介绍一下，介绍下面3个功能的前提条件是已经通过下方命令成功安装jupyter notebook，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> pip install jupyter notebook</span><br></pre></td></tr></table></figure><h1 id="丰富的插件"><a href="#丰富的插件" class="headerlink" title="丰富的插件"></a>丰富的插件</h1><p><b>安装插件管理器</b></p><p>如果没有安装插件管理器，打开jupyter notebook后菜单栏只有如下3项，</p><ul><li>Files</li><li>Running</li><li>Clusters</li></ul><p>我们需要安装插件管理器来管理我们需要的插件，</p><p>第一步：用pip安装插件管理包，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> pip install jupyter_contrib_nbextensions</span><br><span class="line"><span class="meta">$</span> pip install jupyter_nbextensions_configurator</span><br></pre></td></tr></table></figure><p>第二步：安装一些插件并启用插件管理器，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> jupyter nbextensions_configurator install --user</span><br><span class="line"><span class="meta">$</span> jupyter nbextensions_configurator enable --user</span><br></pre></td></tr></table></figure><p>然后再次打开jupyter notebook会发现菜单栏多了一个选项<b>Nbextensions</b>,</p><p><img src="https://s2.ax1x.com/2019/09/16/nffsUK.png" alt="nffsUK.png"></p><p>记得勾选disable configuration for nbextensions without explicit compatibility (they may break your notebook environment, but can be useful to show for nbextension development)，否则下方插件是不可选状态。</p><p>我们可以通过命令来管理开启或关闭某个插件，但是我觉得还是通过直接勾选我们需要的插件效率更高。</p><p><b>选择插件</b></p><p>我们从上面可以看出，jupyter notebook有很多插件，我们该用哪一个呢？我推荐5款个人认为不错的插件。</p><ul><li><b>Table of Contents</b></li><li><b>Execute Time</b></li><li><b>Nofity</b></li><li><b>Codefolding</b></li><li><b>Hinterland</b></li></ul><p>下面分别介绍一下它们的功能，</p><p><img src="https://s2.ax1x.com/2019/09/16/nffhDI.png" alt="nffhDI.png"></p><p><b>Table of Contents</b>是一款自动生成目录的工具，它能够通过我们我们富文本中定义的标题自动生成目录，这样我们能够通过点击左侧目录快速定位到我们想要的到达的代码片段。</p><p><img src="https://s2.ax1x.com/2019/09/16/nffXKs.png" alt="nffXKs.png"></p><p><b>Execute Time</b>顾名思义，执行时间，我觉得这是一款非常实用的插件，在企业项目开发中，效率是永远无法越过的一个门槛，和学术上理论效果足够优秀即可不同，在企业项目中对效率要求也很高，因此，我们需要统计代码的运行时间，其中最初级的用法就是在每个函数开始和结尾处写一个计时语句，这样比较繁琐。然后再高阶一些的用法就是通过装饰器写一些计时器，在每个函数上调用这个装饰器。其实，如果用jupyter notebook完全没必要这么麻烦。我们只需要打开<b>Execute Time</b>，它就能统计每个cell的运行耗费时间，结束时间等，非常详细，一目了然。</p><p><img src="https://s2.ax1x.com/2019/09/16/nfhGqI.png" alt="nfhGqI.png"></p><p><b>Nofity</b>同样是一款非常实用的插件，当我们运行一个耗时较长的代码时，我们不可能一直盯着屏幕等待，但是我们又希望及时知道它运行结束了，Notify这款插件就可以实现这个功能，它能够在代码运行结束时发出通知，及时告知你代码运行结束了。</p><p><img src="https://s2.ax1x.com/2019/09/16/nfhNIf.png" alt="nfhNIf.png"></p><p><b>Codefolding</b>是一款代码折叠工具，有时候我们写的一个函数非常长，但是我们又不关注 ，这样在阅读过程中会使得效率很低，代码折叠就是一个不错的选择，折叠我们不关注的代码块，<b>Codefolding</b>能够像其他IDE那样让你轻松自如的折叠代码块。</p><p><img src="https://s2.ax1x.com/2019/09/16/nfhHdx.gif" alt="nfhHdx.gif"></p><p><b>Hinterland</b>是一款自动补全插件，称一个IDE“优秀”，如果没有自动补全显然是说不过去的。jupyter notebook自带补全功能，但是每次都需要点击<b>tab</b>键来补全，这样效率比较低，我们可以通过勾选<b>Hinterland</b>让jupyter notebook具备自动补全功能，当我们输入几个包含字母后它能够快速补全我们想要的函数，补全速度堪比pycharm。</p><h1 id="主题修改"><a href="#主题修改" class="headerlink" title="主题修改"></a>主题修改</h1><p>很多同学使用jupyter notebook都会觉得，这款开发工具界面太单调了，只有纯白色的主题，其实并不是这样，jupyter notebook也支持主题修改，而且非常方便。</p><p>首先在命令行下输入下面命令安装主题，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> pip install jupyterthemes</span><br></pre></td></tr></table></figure><p>jupyter notebook的主题管理工具叫做<b>jt</b>，我们可以通过下面命令查看可用主题，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> jt -l</span><br><span class="line">Available Themes:</span><br><span class="line">   chesterish</span><br><span class="line">   grade3</span><br><span class="line">   gruvboxd</span><br><span class="line">   gruvboxl</span><br><span class="line">   monokai</span><br><span class="line">   oceans16</span><br><span class="line">   onedork</span><br><span class="line">   solarizedd</span><br><span class="line">   solarizedl</span><br></pre></td></tr></table></figure><p>然后通过下面命令设置主题，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> jt -t &lt;theme_name&gt;</span><br></pre></td></tr></table></figure><p>其中theme_name为主题名称。</p><p><img src="https://s2.ax1x.com/2019/09/16/nf4FFf.png" alt="nf4FFf.png"></p><p>如果觉得不满意，想退回默认主题，可以通过下方命令实现，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> jt -r</span><br></pre></td></tr></table></figure><h1 id="多语言支持"><a href="#多语言支持" class="headerlink" title="多语言支持"></a>多语言支持</h1><p>很多同学是因为Python而解除到jupyter notebook的，因此会认为这就是一款Python专属的开发工具，如果这样的话，那么也不足以我专门用一篇文章来介绍这款开发工具。</p><p>它更像是eclipse、IDEA、vscode，是一款综合的开发工具，它不仅支持Python，还支持C++、julia、R、ruby、Go、Scala、C#、Perl、PHP、Octave、Matlab、Lua、Tcl、等多种编程语言，功能十分强大，支持语言详情，请查看下方链接，</p><p><a href="https://github.com/jupyter/jupyter/wiki/Jupyter-kernels" target="_blank" rel="noopener">https://github.com/jupyter/jupyter/wiki/Jupyter-kernels</a></p><p>不同语言的配置方式各不相同，这里不再一一介绍，可以根据自己需要的语言自行在网上搜索相关配置资料进行配置。</p><h1 id="jupyter-notebook服务"><a href="#jupyter-notebook服务" class="headerlink" title="jupyter notebook服务"></a>jupyter notebook服务</h1><p>如果非要找出使用jupyter notebook的缺点，我认为就是每次启动的时候相对繁琐，我们启动本地安装的IDE，一个命令或者点击一下图标即可，但是如果启动jupyter notebook就需要进入命令行或终端，输入“jupyter notebook”进行打开，如果使用的是虚拟环境，首先还要激活虚拟环境，这无疑是非常繁琐的，而且启动后它会占用一个终端或命令行窗口，如果意外关闭则会终止jupyter notebook服务。其实，这也是有解决方法的，我们搭建一个持续化的jupyter notebook服务，让它一直在服务器后台运行，这样既不占用窗口，也不需要繁琐的打开步骤，我们只需要把对应的URL收藏，每次需要时能够秒级速度打开，下面就来介绍一下jupyter notebook的搭建步骤。</p><p><b>第一步：获取sha1密码</b></p><p>在命令行下输入ipython，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [1]: from IPython.lib import passwd</span><br><span class="line">In [2]: passwd()</span><br><span class="line">Enter password:</span><br><span class="line">Verify password:</span><br><span class="line">Out[2]: 'sha1:746cf729d33f:0af9cda409de9791f237a6c46c3c76a3237962fc'</span><br></pre></td></tr></table></figure><p>导入passwd函数，调用后会让你输入密码，你可以设置一个明文密码，例如123，然后它会生成一个sha1密码串，这个很重要，后面会用到。</p><p>修改jupyter配置文件，linux系统配置文件路径为<b>~/.jupyter/jupyter_notebook_config.py</b>，windows系统配置文件路径为<b>C:\\Users\\User\.jupyter\\jupyter_notebook_config.py</b>，如果没有这个文件，可以使用下面命令生成，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> jupyter notebook --generate-config</span><br></pre></td></tr></table></figure><p>这个配置文件很长，以linux为例，主要关注的是如下几项，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">c.NotebookApp.ip = <span class="string">'*'</span>  </span><br><span class="line">c.NotebookApp.password = u<span class="string">'sha1:xxx:xxx'</span> </span><br><span class="line">c.NotebookApp.open_browser = False </span><br><span class="line">c.NotebookApp.port = 8888</span><br><span class="line">c.NotebookApp.enable_mathjax = True</span><br></pre></td></tr></table></figure><p><b>c.NotebookApp.ip</b>、<b>c.NotebookApp.port</b>，ip要和服务器保持一致，端口可以自行设定，不和其他端口冲突即可，后续访问时在浏览器输入<b>ip:port</b>即可。</p><p><b>c.NotebookApp.password</b>就是前面生成的sha1密码串，复制过来即可。</p><p><b>c.NotebookApp.open_browser = False </b>的含义为是每次启动命令时是否打开浏览器，由于我们用的时候直接输入URL即可，所以这里不需要打开浏览器。</p><p><b>c.NotebookApp.enable_mathjax</b>的含义为是否用mathjax，它是一种用于数学公式显示的工具，这里选True。</p><p>配置好这几项之后保存退出，输入下面命令即可启动，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> nohup jupyter notebook &gt; /dev/null 2&gt;&amp;1 &amp;</span></span><br></pre></td></tr></table></figure><p>nohup的含义是后台运行，这样就不用占用一个窗口来了。</p><p>配置好之后只要服务器不关机，jupyter notebook的服务会一直处于运行状态，我们随时可以使用，只需要打开<b>ip:port</b>即可。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/09/16/nfW7c9.jpg&quot; alt=&quot;nfW7c9.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;提起jupyter notebook，应该很多学习过Python的同学都不模型。虽然用jupyter notebook的同学相对较少，但是提及这款开发工具，很多人都会赞不绝口，“jupyter很强大，交互式、富文本”，很多人都知道jupyter notebook的这几个优点，
    
    </summary>
    
      <category term="开发工具" scheme="https://jackpopc.github.io/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="工具" scheme="https://jackpopc.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="实用" scheme="https://jackpopc.github.io/tags/%E5%AE%9E%E7%94%A8/"/>
    
      <category term="插件" scheme="https://jackpopc.github.io/tags/%E6%8F%92%E4%BB%B6/"/>
    
      <category term="开发工具" scheme="https://jackpopc.github.io/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>【动手学计算机视觉】第十五讲：卷积神经网络之LeNet</title>
    <link href="https://jackpopc.github.io/2019/09/13/lenet/"/>
    <id>https://jackpopc.github.io/2019/09/13/lenet/</id>
    <published>2019-09-13T05:48:55.000Z</published>
    <updated>2019-09-14T10:55:19.743Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><img src="https://s2.ax1x.com/2019/09/14/n6JaHe.png" alt="n6JaHe.png"></p><p>提起卷积神经网络，也许可以避开VGG、GoogleNet，甚至可以忽略AleNet，但是很难不提及LeNet。</p><p>LeNet是由2019年图灵奖获得者、深度学习三位顶级大牛之二的Yann LeCun、Yoshua Bengio于1998年提出(Gradient-based learning applied to document recognition)，<a id="more"></a>它也被认为被认为是最早的卷积神经网络模型。但是，由于算力和数据集的限制，卷积神经网络提出之后一直都被传统目标识别算法(特征提取+分类器)所压制。终于在沉寂了14年之后的2012年，AlexNet在ImageNet挑战赛上一骑绝尘，使得卷积神经网络又一次成为了研究的热点。</p><p>近几年入门计算机视觉的同学大多数都是从AlexNet甚至更新的网络模型入手，了解比较多的就是R-CNN系列和YOLO系列，在很多知名的课程中对LeNet的介绍也是非常浅显或者没有介绍。虽然近几年卷积神经网络模型在LeNet的基础上加入了很多新的单元，在效果方面要明显优于LeNet，但是作为卷积神经网络的基础和源头，它的很多思想对后来的卷积神经网络模型具有很深的影响，因此，我认为了解一下LeNet还是非常有必要的。</p><p>本文首先介绍一下LeNet的网络模型，然后使用tensorflow来一步一步实现LeNet。</p><h1 id="LeNet"><a href="#LeNet" class="headerlink" title="LeNet"></a>LeNet</h1><p><img src="https://s2.ax1x.com/2019/09/14/n6JwAH.png" alt="n6JwAH.png"></p><p>上图就是LeNet的网络结构，LeNet又被称为LeNet-5，其之所以称为这个名称是由于原始的LeNet是一个5层的卷积神经网络，它主要包括两部分：</p><ul><li>卷积层</li><li>全连接层</li></ul><p>其中卷积层数为2，全连接层数为3。</p><p><b>这里需要注意一下</b>，之前在介绍卷积、池化时特意提到，在网络层计数中池化和卷积往往是被算作一层的，虽然池化层也被称为”层”，但是它不是一个独立的运算，往往都是紧跟着卷积层使用，因此它不单独计数。在LeNet中也是这样，卷积层块其实是包括两个单元：卷积层与池化层。</p><p>在网络模型的搭建过程中，我们关注的除了网络层的结构，还需要关注一些超参数的设定，例如，卷积层中使用卷积核的大小、池化层的步幅等，下面就来介绍一下LeNet详细的网络结构和参数。</p><p><b>第一层：卷积层</b></p><p>卷积核大小为5*5，输入通道数根据图像而定，例如灰度图像为单通道，那么通道数为1，彩色图像为三通道，那么通道数为3。虽然输入通道数是一个变量，但是输出通道数是固定的为6。</p><p>池化层中窗口大小为2*2，步幅为2。</p><p><b>第二层：卷积层</b></p><p>卷积核大小为5*5，输入通道数即为上一层的输出通道数6，输出通道数为16。</p><p>池化层和第一层相同，窗口大小为2*2，步幅为2。</p><p><b>第三层：全连接层</b></p><p>全连接层顾名思义，就是把卷积层的输出进行展开，变为一个二维的矩阵(第一维是批量样本数，第二位是前一层输出的特征展开后的向量)，输入大小为上一层的输出16，输出大小为120。</p><p><b>第四层：全连接层</b></p><p>输入大小为120，输出大小为84。</p><p><b>第五层：全连接层</b></p><p>输入大小为84，输出大小为类别个数，这个根据不同任务而定，假如是二分类问题，那么输出就是2，对于手写字识别是一个10分类问题，那么输出就是10。</p><p><b>激活函数</b></p><p>前面文章中详细的介绍了激活函数的作用和使用方法，本文就不再赘述。激活函数有很多，例如Sigmoid、relu、双曲正切等，在LeNet中选取的激活函数为Sigmoid。</p><h1 id="模型构建"><a href="#模型构建" class="headerlink" title="模型构建"></a>模型构建</h1><p><img src="https://s2.ax1x.com/2019/09/14/n6J6jf.png" alt="n6J6jf.png"></p><p>如果已经了解一个卷积神经网络模型的结构，知道它有哪些层、每一层长什么样，那样借助目前成熟的机器学习平台是非常容易的，例如tensorflow、pytorch、mxnet、caffe这些都是高度集成的深度学习框架，虽然在强化学习、图神经网络中表现一般，但是在卷积神经网络方面还是很不错的。</p><p>我绘制了模型构建的过程，详细的可以看一下上图，很多刚入门的同学会把tensorflow使用、网络搭建看成已经非常困难的事情，其实理清楚之后发现并没有那么复杂，它主要包括如下几个部分：</p><ul><li>数据输入</li><li>网络模型</li><li>训练预测</li></ul><p>其中，重点之处就在于网络模型的搭建，需要逐层的去搭建一个卷积神经网络，复杂程度因不同的模型而异。训练测试过程相对简单一些，可以通过交叉熵、均方差等构建损失函数，然后使用深度学习框架自带的优化函数进行优化即可，代码量非常少。</p><p>LeNet、AlexNet、VGG、ResNet等，各种卷积神经网络模型主要的区别之处就在于网络模型，但是网络搭建的过程是相同的，均是通过上述流程进行搭建，因此，本文单独用一块内容介绍模型搭建的过程，后续内容不再介绍网络模型的搭建，会直接使用tensorflow进行编程实践。</p><h1 id="编程实践"><a href="#编程实践" class="headerlink" title="编程实践"></a>编程实践</h1><p><b>完整代码</b>请查看github项目： <a href="https://github.com/Jackpopc/aiLearnNotes/blob/master/computer_vision/LeNet.py" target="_blank" rel="noopener">aiLearnNotes</a></p><p>首先需要说明一下，后续的内容中涉及网络模型搭建的均会选择tensorflow进行编写。虽然近几年pytorch的势头非常迅猛，关于tensorflow的批评之声不绝于耳，但是我一向认为，灵活性和易用性总是成反比的，tensorflow虽然相对复杂，但是它的灵活性非常强，而且支持强大的可视化tensorboard，虽然pytorch也可以借助tensorboard实现可视化，但是这样让我觉得有一些”不伦不类”的感觉，我更加倾向于一体化的框架。此外，有很多同学认为Gluon、keras非常好用，的确，这些在tensorflow、mxnet之上进一步封装的高级深度学习框架非常易用，很多参数甚至不需要开发者去定义，但是正是因为这样，它们已经强行的预先定义在框架里了，可想而知，它的灵活性是非常差的。因此，综合灵活性、一体化、丰富性等方面的考虑，本系列会采用tensorflow进行编程实践。</p><p>其次，需要说明的是本系列重点关注的是网络模型，因此，关于数据方面会采用MNIST进行实践。MNIST是一个成熟的手写字数据集，它提供了易用的接口，方便读取和处理。</p><p>在使用tensorflow接口读取MNIST时，如果本地有数据，它会从本地加载，否则它会从官网下载数据，如果由于代理或者网速限制的原因自动下载数据失败，可以手动从官网下载数据放在MNIST目录下，数据包括4个文件，分别是：</p><ul><li>train-images-idx3-ubyte.gz</li><li>train-labels-idx1-ubyte.gz</li><li>t10k-images-idx3-ubyte.gz</li><li>t10k-labels-idx1-ubyte.gz</li></ul><p>它们分别是训练数据集和标签，测试数据集和标签。</p><p>可能会有人有疑问，手写体识别不是图像吗？为什么是gz的压缩包？因为作者对手写体进行了序列化处理，方便读取，数据原本是衣服单通道28*28的灰度图像，处理后是784的向量，我们可以通过一段代码对它可视化一下，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> tensorflow.examples.tutorials.mnist <span class="keyword">import</span> input_data</span><br><span class="line"></span><br><span class="line">mnist = input_data.read_data_sets(<span class="string">"MNIST"</span>, one_hot=<span class="literal">True</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">12</span>):</span><br><span class="line">    plt.subplot(<span class="number">3</span>, <span class="number">4</span>, i+<span class="number">1</span>)</span><br><span class="line">    img = mnist.train.images[i + <span class="number">1</span>]</span><br><span class="line">    img = img.reshape(<span class="number">28</span>, <span class="number">28</span>)</span><br><span class="line">    plt.imshow(img)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>通过读取训练集中的12副图像，然后把它修改成28*28的图像，显示之后会发现和我们常见的图像一样，</p><p><img src="https://s2.ax1x.com/2019/09/14/n6JB4A.png" alt="n6JB4A.png"></p><p>下面开始一步一步进行搭建网络LeNet，由前面介绍的模型构建过程可以知道，其中最为核心的就是搭建模型的网络架构，所以，首先先搭建网络模型，</p><script type="math/tex; mode=display">y=wx+b</script><p>卷积的运算是符合上述公式的，因此，首先构造第一层网络，输入为批量784维的向量，需要首先把它转化为28*28的图像，然后初始化卷积核，进行卷积、激活、池化运算，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">X = tf.reshape(X, [<span class="number">-1</span>, <span class="number">28</span>, <span class="number">28</span>, <span class="number">1</span>])</span><br><span class="line">w_1 = tf.get_variable(<span class="string">"weights"</span>, shape=[<span class="number">5</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">6</span>])</span><br><span class="line">b_1 = tf.get_variable(<span class="string">"bias"</span>, shape=[<span class="number">6</span>])</span><br><span class="line">conv_1 = tf.nn.conv2d(X, w_1, strides=[<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>], padding=<span class="string">"SAME"</span>)</span><br><span class="line">act_1 = tf.sigmoid(tf.nn.bias_add(conv_1, b_1))</span><br><span class="line">max_pool_1 = tf.nn.max_pool(act_1, ksize=[<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>], strides=[<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>], padding=<span class="string">"SAME"</span>)</span><br></pre></td></tr></table></figure><p>然后构建第二层网络，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">w_2 = tf.get_variable(<span class="string">"weights"</span>, shape=[<span class="number">5</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">16</span>])</span><br><span class="line">b_2 = tf.get_variable(<span class="string">"bias"</span>, shape=[<span class="number">16</span>])</span><br><span class="line">conv_2 = tf.nn.conv2d(max_pool_1, w_2, strides=[<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>], padding=<span class="string">"SAME"</span>)</span><br><span class="line">act_2 = tf.nn.sigmoid(tf.nn.bias_add(conv_2, b_2))</span><br><span class="line">max_pool_2 = tf.nn.max_pool(act_2, ksize=[<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>], strides=[<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>], padding=<span class="string">"SAME"</span>)</span><br></pre></td></tr></table></figure><p>到这里，卷积层就搭建完了，下面就开始搭建全连接层。</p><p>首先需要把卷积层的输出进行展开成向量，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flatten = tf.reshape(max_pool_2, shape=[<span class="number">-1</span>, <span class="number">2</span> * <span class="number">2</span> * <span class="number">16</span>])</span><br></pre></td></tr></table></figure><p>然后紧接着是3个全连接层，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 全连接层1</span></span><br><span class="line"><span class="keyword">with</span> tf.variable_scope(<span class="string">"fc_1"</span>) <span class="keyword">as</span> scope:</span><br><span class="line">    w_fc_1 = tf.get_variable(<span class="string">"weight"</span>, shape=[<span class="number">2</span> * <span class="number">2</span> * <span class="number">16</span>, <span class="number">120</span>])</span><br><span class="line">    b_fc_1 = tf.get_variable(<span class="string">"bias"</span>, shape=[<span class="number">120</span>], trainable=<span class="literal">True</span>)</span><br><span class="line">fc_1 = tf.nn.xw_plus_b(flatten, w_fc_1, b_fc_1)</span><br><span class="line">act_fc_1 = tf.nn.sigmoid(fc_1)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 全连接层2</span></span><br><span class="line"><span class="keyword">with</span> tf.variable_scope(<span class="string">"fc_2"</span>) <span class="keyword">as</span> scope:</span><br><span class="line">    w_fc_2 = tf.get_variable(<span class="string">"weight"</span>, shape=[<span class="number">120</span>, <span class="number">84</span>])</span><br><span class="line">    b_fc_2 = tf.get_variable(<span class="string">"bias"</span>, shape=[<span class="number">84</span>], trainable=<span class="literal">True</span>)</span><br><span class="line">fc_2 = tf.nn.xw_plus_b(act_fc_1, w_fc_2, b_fc_2)</span><br><span class="line">act_fc_2 = tf.nn.sigmoid(fc_2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 全连接层3</span></span><br><span class="line"><span class="keyword">with</span> tf.variable_scope(<span class="string">"fc_3"</span>) <span class="keyword">as</span> scope:</span><br><span class="line">    w_fc_3 = tf.get_variable(<span class="string">"weight"</span>, shape=[<span class="number">84</span>, <span class="number">10</span>])</span><br><span class="line">    b_fc_3 = tf.get_variable(<span class="string">"bias"</span>, shape=[<span class="number">10</span>], trainable=<span class="literal">True</span>)</span><br><span class="line">fc_3 = tf.nn.xw_plus_b(act_fc_2, w_fc_3, b_fc_3)</span><br></pre></td></tr></table></figure><p>这样就把整个网络模型搭完成了，输入是批量图像X，输出是预测的图像，输出是一个10维向量，每一维的含义是当前数字的概率，选择概率最大的位置，就是图像对应的数字。</p><p>完成了网络模型的搭建，它能够将输入图像转化成预测标签进行输出，接下来要做的就是训练和测试部分。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 1. 输入数据的占位符</span></span><br><span class="line">    x = tf.placeholder(tf.float32, [<span class="literal">None</span>, <span class="number">784</span>])</span><br><span class="line">    y = tf.placeholder(tf.float32, [BATCH_SIZE, <span class="number">10</span>])</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 2. 初始化LeNet模型，构造输出标签y_</span></span><br><span class="line">    le = LeNet()</span><br><span class="line">    y_ = le.create(x)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 3. 损失函数，使用交叉熵作为损失函数</span></span><br><span class="line">    loss = tf.reduce_mean(tf.nn.softmax_cross_entropy_with_logits(logits=y_, labels=y))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 4. 优化函数，首先声明I个优化函数，然后调用minimize去最小化损失函数</span></span><br><span class="line">    optimizer = tf.train.AdamOptimizer()</span><br><span class="line">    train_op = optimizer.minimize(loss)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 5. summary用于数据保存，用于tensorboard可视化</span></span><br><span class="line">    tf.summary.scalar(<span class="string">"loss"</span>, loss)</span><br><span class="line">    merged = tf.summary.merge_all()</span><br><span class="line">    writer = tf.summary.FileWriter(<span class="string">"logs"</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 6. 构造验证函数，如果对应位置相同则返回true，否则返回false</span></span><br><span class="line">    correct_pred = tf.equal(tf.argmax(y_, <span class="number">1</span>), tf.argmax(y, <span class="number">1</span>))</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 7. 通过tf.cast把true、false布尔型的值转化为数值型，分别转化为1和0，然后相加就是判断正确的数量</span></span><br><span class="line">    accuracy = tf.reduce_mean(tf.cast(correct_pred, tf.float32))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 8. 初始化一个saver，用于后面保存训练好的模型</span></span><br><span class="line">    saver = tf.train.Saver()</span><br><span class="line">    <span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">        <span class="comment"># 9. 初始化变量</span></span><br><span class="line">        sess.run((tf.global_variables_initializer()))</span><br><span class="line">        writer.add_graph(sess.graph)</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> epoch <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">            <span class="keyword">for</span> step <span class="keyword">in</span> range(<span class="number">1000</span>):</span><br><span class="line">                <span class="comment"># 10. feed_dict把数据传递给前面定义的占位符x、y</span></span><br><span class="line">                batch_xs, batch_ys = mnist.train.next_batch(BATCH_SIZE)</span><br><span class="line">                summary, loss_value, _ = sess.run(([merged, loss, train_op]),</span><br><span class="line">                                                  feed_dict=&#123;x: batch_xs,</span><br><span class="line">                                                             y: batch_ys&#125;)</span><br><span class="line">                print(<span class="string">"epoch : &#123;&#125;----loss : &#123;&#125;"</span>.format(epoch, loss_value))</span><br><span class="line">                <span class="comment"># 11. 记录数据点</span></span><br><span class="line">                writer.add_summary(summary, i)</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">                </span><br><span class="line">        <span class="comment"># 验证准确率</span></span><br><span class="line">        test_acc = <span class="number">0</span></span><br><span class="line">        test_count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">            batch_xs, batch_ys = mnist.test.next_batch(BATCH_SIZE)</span><br><span class="line">            acc = sess.run(accuracy, feed_dict=&#123;x: batch_xs, y: batch_ys&#125;)</span><br><span class="line">            test_acc += acc</span><br><span class="line">            test_count += <span class="number">1</span></span><br><span class="line">        print(<span class="string">"accuracy : &#123;&#125;"</span>.format(test_acc / test_count))</span><br><span class="line">        saver.save(sess, os.path.join(<span class="string">"temp"</span>, <span class="string">"mode.ckpt"</span>))</span><br></pre></td></tr></table></figure><p>上述就是训练部分的完整代码，在代码中已经详细的注释了每个部分的功能，分别包含数据记录、损失函数、优化函数、验证函数、训练过程等，然后运行代码可以看到效果，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">epoch : 4----loss : 0.07602085173130035</span><br><span class="line">epoch : 4----loss : 0.05565792694687843</span><br><span class="line">epoch : 4----loss : 0.08458487689495087</span><br><span class="line">epoch : 4----loss : 0.012194767594337463</span><br><span class="line">epoch : 4----loss : 0.026294417679309845</span><br><span class="line">epoch : 4----loss : 0.04952147603034973</span><br><span class="line">accuracy : 0.9953125</span><br></pre></td></tr></table></figure><p>准确率为99.5%，可以看得出，在效果方面，LeNet在某些任务方面并不比深度卷积神经网络差。</p><p>打开tensorboard可以直观的看到网络的结构、训练的过程以及训练中数据的变换，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> tensorboard --logdir=logs</span></span><br></pre></td></tr></table></figure><p><img src="https://s2.ax1x.com/2019/09/14/n6YwrT.gif" alt="n6YwrT.gif"></p><p>通过损失函数的变化过程可以看出，训练过程在2000步左右基本达到了最优解，</p><p><img src="https://s2.ax1x.com/2019/09/14/n6J0Nd.png" alt="n6J0Nd.png"></p><hr><blockquote><p>更多精彩内容请关注公众号【平凡而诗意】，或者加入我的知识星球【平凡而诗意】~</p></blockquote><p><img src="https://s2.ax1x.com/2019/09/14/n6YcGR.png" alt="n6YcGR.png"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/09/14/n6JaHe.png&quot; alt=&quot;n6JaHe.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;提起卷积神经网络，也许可以避开VGG、GoogleNet，甚至可以忽略AleNet，但是很难不提及LeNet。&lt;/p&gt;
&lt;p&gt;LeNet是由2019年图灵奖获得者、深度学习三位顶级大牛之二的Yann LeCun、Yoshua Bengio于1998年提出(Gradient-based learning applied to document recognition)，
    
    </summary>
    
      <category term="计算机视觉" scheme="https://jackpopc.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
    
      <category term="CV" scheme="https://jackpopc.github.io/tags/CV/"/>
    
      <category term="AI" scheme="https://jackpopc.github.io/tags/AI/"/>
    
      <category term="图像处理" scheme="https://jackpopc.github.io/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>效率工具 | 神器AutoHotkey的使用教程</title>
    <link href="https://jackpopc.github.io/2019/09/06/autohotkey/"/>
    <id>https://jackpopc.github.io/2019/09/06/autohotkey/</id>
    <published>2019-09-06T13:12:49.000Z</published>
    <updated>2019-09-14T10:55:46.586Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简单示例"><a href="#简单示例" class="headerlink" title="简单示例"></a>简单示例</h1><p>AutoHotkey是一款强大、开源的热键脚本工具。在以往的文章里，我介绍了很多强大的效率提升工具，其中包括Wox、Listary、QuickLook等。如果说这些软件在某些领域独树一帜，那么AutoHotkey则是在则是“无所不能”的强大工具。</p><a id="more"></a>易用性和功能的灵活性往往是成反比的，举一个极端的例子，开发语言这类工具在使用方面非常不友好，但是经过开发语言的各种组合可以实现各种手机、PC端软件数不胜数的功能。当然，由于它的使用偏于专业，所以更多人选择定制化较强、界面友好的工具，但是却要牺牲一些灵活性。Autohotkey是一款介于纯编程语言和分发软件之间的一款工具，你可以使用它写一些简单的脚本语言，用内置的一些函数或者自定义的函数去单独或组合使用，以达到我们期望的功能，下面先来看一个示例。先看一个简单的AutoHotkey脚本，<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">^j::</span><br><span class="line">Send, This is a Hotkey!</span><br><span class="line">return</span><br><span class="line"></span><br><span class="line">::hs::This is a HotString!</span><br><span class="line"></span><br><span class="line">^#s::</span><br><span class="line">Run, D:\Sublime Text 3\sublime_text.exe</span><br></pre></td></tr></table></figure><p>然后<b>鼠标右键</b>点击编译，或者双击脚本运行，然后点击对应的快捷键，</p><p><a href="https://imgchr.com/i/nra6KK" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/09/13/nra6KK.gif" alt="nra6KK.gif"></a></p><p>这个演示包括三个动作：</p><ol><li>快捷键启动sublime</li><li>快捷键输入“This is a Hotkey!”</li><li>快捷字符输入“This is a HotString!”</li></ol><p>回到前面给出的AutoHotkey脚本，来一步一步的解释怎么实现的。</p><p><b>第一个动作：快捷键启动sublime</b></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">^#s::</span><br><span class="line">Run, D:\Sublime Text 3\sublime_text.exe</span><br></pre></td></tr></table></figure><p>这句命令实现的是<b>快捷键启动sublime</b>。</p><p>第一行中<b>^</b>和<b>#</b>是两个代表按键的符号，分别代表<b>ctrl</b>和<b>windows</b>，<b>s</b>就是键盘上的s键，<b>::</b>可以认为是命令的结束符号。</p><p>第二行中<b>Run</b>是一个内置函数，用于运行一个工具或者打开一个网页，后面跟的是要打开的网页或者软件路径(如果已经加入到环境变量，就不需要完整的安装路径)。</p><p>因此，上述两行脚本的功能就是<b>ctrl+win+s</b>就可以打开sublime这款软件。</p><p><b>第二个动作：快捷键输入“This is a Hotkey!”</b></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">^j::</span><br><span class="line">Send, This is a Hotkey!</span><br><span class="line">return</span><br></pre></td></tr></table></figure><p>看完第一个动作的介绍，应该很容易理解这个动作，</p><p>第一行的含义是<b>ctrl+j</b>快捷键。</p><p>第二行的含义是<b>发送一段字符串</b>。</p><p><b>第三个动作：快捷字符输入“This is a HotString!”</b></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">::hs::This is a HotString!</span><br></pre></td></tr></table></figure><p>这个和前两个动作不同，介绍这个动作之前需要先简单的了解一下AutoHotkey，它主要包括两个概念：</p><ul><li><p><b>hotkey</b></p></li><li><p><b>hotstring</b></p></li></ul><p>其中hotkey并不陌生，就是热键、快捷键，前两个动作实现的就是快捷键。</p><p>这里需要说一下hotstring，顾名思义，就是<b>通过一段字符串实现一个快捷功能</b>，第三个动作实现的就是一个hotstring功能。</p><p>现在回过头来解释一下第三个动作的脚本的含义，</p><p>两个<b>::</b>之间定义的是快键字符串，后面跟随的是要输入的完整字符串，这样的话在文本框输入<b>hs</b>然后点击<b>Tab</b>键即可在编辑器中输入This is a HotString!这个完整的字符串。</p><p>很多人用惯了快捷键会疑问，hostring有什么价值？我认为它对于开发者或者文本编辑相关的工作者是非常有意义的。我们可以在脚本中预先用一些hostring定义好我们常用的代码块或者文字内容，这样，当输入对应的hostring时就可以快速补全我们想要的内容，速度和资源消耗要远远小于常用的代码补全工具。</p><h1 id="热键符号"><a href="#热键符号" class="headerlink" title="热键符号"></a>热键符号</h1><p>通过前面的简单示例，想必应该对AutoHotkey有了简单的了解，它就是通过一些内置的<b>符号</b>、<b>函数</b>、<b>自定义函数</b>来任意组合，定制化的实现我们想要的功能。</p><p>通过示例中第一个动作<b>^#s</b>代表快捷键<b>ctrl+win+s</b>可以看出，热键符号具有至关重要的作用，我们怎么就知道<b>^</b>代表<b>ctrl</b>、<b>#</b>代表<b>win</b>呢？因为官网给出了不同符号的对应关系，下面是各个符号对应的热键，</p><div class="table-container"><table><thead><tr><th style="text-align:center">符号</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">#</td><td style="text-align:center">win</td></tr><tr><td style="text-align:center">！</td><td style="text-align:center">Alt</td></tr><tr><td style="text-align:center">^</td><td style="text-align:center">Ctrl</td></tr><tr><td style="text-align:center">+</td><td style="text-align:center">Shift</td></tr><tr><td style="text-align:center">&amp;</td><td style="text-align:center">可以在两个组合键之间使用</td></tr><tr><td style="text-align:center">&lt;</td><td style="text-align:center">指定快捷键的位置在左边</td></tr><tr><td style="text-align:center">&gt;</td><td style="text-align:center">指定快捷键的位置在右边</td></tr></tbody></table></div><p><b>注：</b>我们都知道，alt、ctrl、shift这些键都有两个，左右两边均有，&lt;和&gt;两个符号就指定使用左边的符号还是右边的符号，例如<b>&lt;!</b>指定使用左边的Alt键。</p><h1 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h1><p>在示例中，我们也看到使用了<b>Run</b>、<b>Send</b>，这两个称为AutoHotkey的标签，虽然我是以大写字母开头，但是标签名称其实是部分不区分大小写的，可以由空格、制表符、逗号、转义符以外的任何字符组成，但是由于样式的约定，通常最好使用字母、数字、下划线，AutoHotkey常用的内置标签有如下几个，</p><div class="table-container"><table><thead><tr><th style="text-align:center">标签</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">Send</td><td style="text-align:center">向编辑器发送一段字符</td></tr><tr><td style="text-align:center">SendInput</td><td style="text-align:center">同上</td></tr><tr><td style="text-align:center">MsgBox</td><td style="text-align:center">弹出对话框</td></tr><tr><td style="text-align:center">Run</td><td style="text-align:center">运行一个工具或打开网页</td></tr><tr><td style="text-align:center">WinActivate</td><td style="text-align:center">窗口激活</td></tr><tr><td style="text-align:center">WinWaitActive</td><td style="text-align:center">窗口等待激活</td></tr></tbody></table></div><p>下面看一个例子，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">^j::</span><br><span class="line">Run, https://www.baidu.com</span><br><span class="line">MsgBox, 已经打开网页！</span><br><span class="line">return</span><br></pre></td></tr></table></figure><p>有了前面的基础，应该很容易理解这个脚本，它是一个组合功能，分别是打开网页和弹出对话框，下面看看效果，</p><p><a href="https://imgchr.com/i/nraD81" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/09/13/nraD81.gif" alt="nraD81.gif"></a></p><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>想要更加灵活，仅仅使用上述这些符号、标签显然是不够的。和大多数编程语言一样，AutoHotkey也支持自定义函数，这才是它的强大之处。</p><p>AutoHotkey内置了一些常用的函数，如下，</p><div class="table-container"><table><thead><tr><th style="text-align:center">函数</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">FileExist</td><td style="text-align:center">检查文件或文件夹是否存在，并返回其属性</td></tr><tr><td style="text-align:center">GetKeyState</td><td style="text-align:center">获取按键状态，向下返回true，向上返回false</td></tr><tr><td style="text-align:center">InStr</td><td style="text-align:center">从左或右搜索字符串的给定出现项</td></tr><tr><td style="text-align:center">RegExMatch</td><td style="text-align:center">确定字符串是否包含正则表达式匹配模式</td></tr><tr><td style="text-align:center">RegExReplace</td><td style="text-align:center">替换字符串中出现的模式(正则表达式)</td></tr><tr><td style="text-align:center">StrLen</td><td style="text-align:center">获取字符串长度</td></tr><tr><td style="text-align:center">StrReplace</td><td style="text-align:center">替换字符串</td></tr><tr><td style="text-align:center">StrSplit</td><td style="text-align:center">用指定的分隔符分割字符串</td></tr><tr><td style="text-align:center">SubStr</td><td style="text-align:center">按指定位置返回子字符串</td></tr></tbody></table></div><p>当然，AutoHotkey内置的函数远不止这些，它还包括以下类型的函数：</p><ul><li>文件读取</li><li>数学计算</li><li>条件判断</li><li>异常处理</li><li>状态获取</li><li>鼠标键盘</li><li>屏幕状态</li><li>声音</li><li>进程管理</li><li>窗口状态</li><li>……</li></ul><p>没错，AutoHotkey在功能和丰富性方面丝毫不亚于一些老的脚本语言，但是它的优点是<b>更加实用</b>。我们可以即写即用，能够辅助我们日常生活中多种场景的工作。</p><h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><p><b>快捷启动</b></p><p>这方面它可以替代Wox、Listary这些快速启动工具，我们可以把常用的网站、软件用脚本的方式定义不同的hotkey或者hotstring，当我们需要打开一个网页或者软件时就不需要再繁琐、多步骤的去寻找、打开。</p><p>例如用下面这个脚本，能够快速打开优酷、B站、直播吧，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">^y::</span><br><span class="line">Run, https://www.youku.com/</span><br><span class="line">return</span><br><span class="line"></span><br><span class="line">^b::</span><br><span class="line">Run, https://www.bilibili.com/</span><br><span class="line">return</span><br><span class="line"></span><br><span class="line">^z::</span><br><span class="line">Run, https://www.zhibo8.cc/</span><br><span class="line">return</span><br></pre></td></tr></table></figure><p><a href="https://imgchr.com/i/nrargx" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/09/13/nrargx.gif" alt="nrargx.gif"></a></p><p><b>自动补全</b></p><p>我们在日常开发或者文本编辑时，会有大量重复的工作，以编程为例，我们会有很多重复的代码块，因此，才有各种各样的补全工具，但是目前大多数补全工具可以说是差强人意，速度方面甚至不及自己手动敲代码的速度，但是通过AutoHotkey把我们常用的代码块、文本用hotkey、hotstring代替，这样能够快速的补全我们想要的内容，</p><p>例如，用下面几行脚本补全我们常用的代码片段，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">::np::import numpy as np</span><br><span class="line">::plt::from matplotlib import pyplt as plt</span><br><span class="line">::tf::import tensorflow as tf</span><br></pre></td></tr></table></figure><p><a href="https://imgchr.com/i/nraBCR" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/09/13/nraBCR.gif" alt="nraBCR.gif"></a></p><p><b>效率提升</b></p><p>关于效率提升，这就因人而异，不同的人工作内容不同，因此常用的操作和功能也截然不同，这方面就需要发散思维，总结一下平时自己常用的操作，例如管理进程、取色、文件读取、编程、数学运算等，可以根据自己的需求，使用内置的或者自定义的函数来组合成自己想要的功能，当然，AutoHotkey内置了很多标签、函数，这足以满足日常大多数场景的需求。</p><p><b>软件分发</b></p><p>我们经常在能够在开源平台寻找到很多别人写的软件，其实自己也可以利用AutoHotkey实现一些比较有趣、高效的工具，它不像C++、Java那么难以入门，而且在代码规范方面要求没那么严格，因此门槛相对较低。此外，AutoHotkey脚本的编译非常迅速，资源消耗低，能够一键编译成我们常见的<b>exe</b>软件，这样的话可以把它分享给周围的同学、同事，或者更多的人，这样在提高周围人效率的同时能够锻炼自己的产品思维和开发规范。</p><h1 id="安装与基本操作"><a href="#安装与基本操作" class="headerlink" title="安装与基本操作"></a>安装与基本操作</h1><p><b>下载安装包</b></p><p>AutoHotkey是一款开源免费的工具，能够直接从官网下载AutoHotkey的安装包，</p><p><a href="https://www.autohotkey.com/" target="_blank" rel="noopener">https://www.autohotkey.com/</a></p><p>如果觉得麻烦，也可以在公众号后台回复关键字<font color="red"><b>hot</b></font>获取安装包。</p><p><b>安装</b></p><p><img src="https://s2.ax1x.com/2019/09/13/nra58I.png" alt="nra58I.png"></p><p>双击下载的安装包，会弹出安装界面，直接一步步往下点击即可，如果需要更改安装路径，可以在<b>location</b>页面进行更改。</p><p><b>新建脚本</b></p><p><img src="https://s2.ax1x.com/2019/09/13/nraI2t.png" alt="nraI2t.png"></p><p>成功安装后，在桌面或者其他空白处点击<b>鼠标右键-新建-AutoHotkey Script</b>，来创建一个AutoHotkey脚本。</p><p><b>编辑脚本</b></p><p><img src="https://s2.ax1x.com/2019/09/13/nra7Kf.png" alt="nra7Kf.png"></p><p>创建脚本后，鼠标右键点击脚本，可以看到有三个选项：<b>Run Script</b>、<b>Compile Script</b>、<b>Edit Script</b>。</p><p>可以先点击<b>Edit Script</b>，它会用记事本打开，当然也可以用sublime、UE、notepad++等文本编辑器打开，然后进行编辑。</p><p>编辑之后可以双击脚本直接运行，也可以点击<b>Run Script</b>运行脚本，这样就可以使用我们脚本中定义的快捷键或者快捷字符串，此外，还可以点击<b>Compile Script</b>把脚本编译成<b>exe</b>文件，这样的话脚本会被加密，可以用于分发，其他使用者就无法看到工具源码。</p><p><img src="https://s2.ax1x.com/2019/09/13/nraHr8.png" alt="nraHr8.png"></p><hr><blockquote><p>更多精彩内容请关注公众号【平凡而诗意】，或者加入我的知识星球【平凡而诗意】~</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;简单示例&quot;&gt;&lt;a href=&quot;#简单示例&quot; class=&quot;headerlink&quot; title=&quot;简单示例&quot;&gt;&lt;/a&gt;简单示例&lt;/h1&gt;&lt;p&gt;AutoHotkey是一款强大、开源的热键脚本工具。在以往的文章里，我介绍了很多强大的效率提升工具，其中包括Wox、Listary、QuickLook等。如果说这些软件在某些领域独树一帜，那么AutoHotkey则是在则是“无所不能”的强大工具。&lt;/p&gt;
    
    </summary>
    
      <category term="实用工具" scheme="https://jackpopc.github.io/categories/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="文件查找" scheme="https://jackpopc.github.io/tags/%E6%96%87%E4%BB%B6%E6%9F%A5%E6%89%BE/"/>
    
      <category term="工具" scheme="https://jackpopc.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="实用" scheme="https://jackpopc.github.io/tags/%E5%AE%9E%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>【动手学计算机视觉】第十四讲：正则化之Dropout</title>
    <link href="https://jackpopc.github.io/2019/09/01/cnn-dropout/"/>
    <id>https://jackpopc.github.io/2019/09/01/cnn-dropout/</id>
    <published>2019-09-01T05:10:08.000Z</published>
    <updated>2019-09-01T10:05:47.006Z</updated>
    
    <content type="html"><![CDATA[<p>本文完整代码请查看：<a href="https://github.com/Jackpopc/aiLearnNotes/blob/master/computer_vision/dropout.py" target="_blank" rel="noopener">aiLearnNotes</a></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在前几讲里已经介绍了卷积神经网络中常用的一些单元，例如，</p><ul><li>卷积层</li><li>池化层</li><li>填充</li><li>激活函数</li><li>批量归一化</li></ul><a id="more"></a>本文会介绍最后一个卷积神经网络中常用的单元Dropout，可以称之为“丢弃法”，或者“随机失活”。它在2012年由Alex Krizhevsky、Geoffrey Hinton提出的那个大名鼎鼎的卷积神经网络模型AlexNet中首次提出并使用，Dropout的使用也是AlexNet与20世纪90年代提出的LeNet的最大不同之处。随后，Krizhevsky和Hinton在文章《Dropout: A Simple Way to Prevent Neural Networks from Overtting》又详细的介绍了介绍了Dropout的原理。发展至今，Dropout已经成为深度学习领域一个举足轻重的技术，它的价值主要体现在解决模型的<b>过拟合</b>问题，虽然它不是唯一的解决过拟合的手段，但它却是兼备轻量化和高效两点做的最好的一个手段。“丢弃法”，从字面意思很好理解，就是丢弃网络中的一些东西。丢弃的是什么？神经元，<b>有放回的随机丢弃一些神经元</b>。很多刚接触或者使用过Dropout的同学都会觉得“这有什么好讲的？这是一个非常简单的东西啊。”，如果仅仅从<b>使用</b>角度来讲，这的确非常简单。以目前主流的机器学习平台而言，tensorflow、mxnet、pytorch，均是传入一个<b>概率值</b>即可，一行代码即可完成。但是，我认为学习深度学习如果仅仅是为了<b>会使用</b>，那么真的没什么可以学习的，抽空把tensorflow教程看一下既可以称得上<b>入门深度学习</b>。如果剖开表象看一下Dropout的原理，会发现，它的理论基础是非常深的，从作者先后用《Improving neural networks by preventing co-adaptation of feature detectors》《Dropout: A Simple Way to Prevent Neural Networks from Overtting》等多篇文章来阐述这个算法就可以看出它的不可小觑的价值。和往常<b>先讲理论再讲用法</b>不同，本文先介绍一下它在tensorflow中的用法，然后做一个了解后带着问题去介绍它的理论知识，本文主要包括如下几块内容，- tensorflow中Dropout的使用- 优化与机器学习的区别- 过拟合- Dropout理论知识# tensorflow中Dropout的使用在tensorflow中Dropout的函数为，<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tf.nn.dropout(x, keep_prob, noise_shape=<span class="literal">None</span>, seed=<span class="literal">None</span>, name=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure><p>函数中的参数分别是：</p><p><b>x：</b>Dropout的输入，即为上一层网络的输出</p><p><b>keep_prob：</b>和x尺寸相同的张量(多维向量)，它用于定义每个神经元的被保留的概率，假如keep_prob=0.8，那么它被保留的概率为0.8，换个角度说，它有20%的概率被丢弃。</p><p><b>noise_shape：</b>表示随机生成的保存/删除标志的形状，默认值为None。</p><p><b>seed：</b>一个用于创建随机种子的整数，默认值为None。</p><p><b>name：</b>运算或操作的名称，可自行定义，默认值为None。</p><p>上述5个参数中x和keep_prob为必须参数，其他很少用到，所以不多介绍。x不难理解，就是上一层网络的输出。这里主要提示一下keep_prob，它是Dropout使用中最为重要的参数。</p><p><b>注意：</b>keep_prob是网络中每个神经元被保留的概率，并非是神经网络中神经元被保留个数的概率。举个例子，加入有个3层神经网络，共100个神经元，定义keep_prob=0.6，那么并不是说要保留60个神经元而丢弃40个。而是每个神经元将会有60%的概率被保留，40%的概率被丢弃，所以最终剩余的神经元并不是确切的60个，可能多于60也可能少于60。</p><p><b>策略：</b>深度学习是一门经验主义非常重的方向，Dropout的使用同样需要很多经验。一般情况下建议靠近输入层的把keep_prob设置大一些，就是靠近输入层经历多保留神经元。</p><h1 id="优化与机器学习的区别"><a href="#优化与机器学习的区别" class="headerlink" title="优化与机器学习的区别"></a>优化与机器学习的区别</h1><p>讲完Dropout的使用，话说回来，为什么要用Dropout？</p><p>提到这个问题，就不得不先做一下铺垫，先谈一下优化与机器学习的区别。</p><p>机器学习主要包括如下几块内容：</p><ul><li>数据集</li><li>模型</li><li>损失函数</li><li>优化算法</li></ul><p>其中优化算法直接决定着最终模型效果的好坏，因此，很多人都肆意的扩大优化算法的价值，认为“机器学习就是优化算法”。</p><p>我认为这是不严谨的说法机器学习与优化算法有这本质的区别。优化算法主要用于已知或未知数学模型的优化问题，它主要关注的是在既定模型上的误差，而不关注它的泛化误差。而机器学习则不同，它是在训练集上训练书模型，训练过程中与优化算法类似，考虑在训练集上的误差，但是它对比于优化算法还要多一步，要考虑在测试集上的泛化误差。</p><h1 id="过拟合"><a href="#过拟合" class="headerlink" title="过拟合"></a>过拟合</h1><p><img src="https://s2.ax1x.com/2019/09/01/np6Aa9.png" alt="np6Aa9.png"></p><center><font size="2">(图片截取自吴恩达《深度学习工程师》)</font></center><p>在训练集和测试集这两个数据集上的精确度就引出几种情况：</p><ul><li>在训练集上效果不好，在测试集上效果也不好：欠拟合(上图中第一种情况)</li><li>在训练集上效果很好，在测试集上效果不好：过拟合(上图中第三种情况)</li></ul><p>在实际项目中，这两种情况是非常常见的，显然，这并不是我们想要的，我们追求的是第三种情况：</p><ul><li>在训练集和测试集上的效果都相对较好(上图中第二种情况)</li></ul><p>但是，事与愿违，欠拟合和过拟合是机器学习中非常常见的现象，尤其是<b>过拟合</b>。</p><p>过拟合的形成原因主要包括如下几点：</p><ul><li>训练数据集太少</li><li>参数过多</li><li>特征维度过高</li><li>模型过于复杂</li><li>噪声多</li></ul><p>很多研究者把目光和精力都聚焦在解决过拟合这个问题上，目前用于解决过拟合问题的算法有很多，例如，</p><ul><li>权重衰减</li><li>Early stopping</li><li>批量归一化(没错，就是前一讲讲的BN，它也带有一些正则化的功能)</li></ul><p>在解决过拟合问题的算法中最为知名的词汇莫过于<b>正则化</b>。</p><p>提到正则化，很多同学会想到L1、L2正则化，其实它是一类方法的统称，并非仅限于L1、L2正则化，目前用于结果过拟合的正则化方法主要包括如下几种：</p><ul><li>数据扩充</li><li>L1、L2正则化</li><li>Dropout</li></ul><p>没错，Dropout也是正则化方法中的一种！铺垫这么多，终于引出本文的主角了。</p><p>数据扩充解决过拟合，这一点不难理解，因为数据缺少是引起过拟合的主要原因之一，由于数据的却是导致模型学习过程中不能学到全局特征，只能通过少量数据学习到一个类别的部分特征，通过数据的扩充能够让模型学习到全局特征，减少过拟合现象。</p><p>L1、L2正则化主要为损失函数添加一个L1或L2的正则化惩罚项，防止学习过程中过于偏向于某一个方向引起过拟合。</p><p>最后就轮到Dropout，下面来详细讲一下Dropout的原理。</p><h1 id="Dropout"><a href="#Dropout" class="headerlink" title="Dropout"></a>Dropout</h1><p><b>如何使用Dropout？</b></p><p><img src="https://s2.ax1x.com/2019/09/01/npyTv8.png" alt="npyTv8.png"></p><center><font size="2">(图片来自于《Dropout: A Simple Way to Prevent Neural Networks from Overtting》)</font></center><p>上图中左图为一个标准的神经网络，右图是采用Dropout之后的神经网络，其中的区别一目了然，就是丢弃了一些神经元。</p><p>前面已经讲解了在tensorflow中如何使用Dropout，已经清楚，对于Dropout最为核心的就是保留概率或者丢弃概率，简述它的原理就是：遍历神经网络的每一层中每一个神经元，以一定概率丢弃或保留某个神经元。用数学语言描述如下，</p><p>假设某一个神经元的输入有4个，那么神经元的计算表达式为，</p><script type="math/tex; mode=display">h_{i}=\phi\left(x_{1} w_{1 i}+x_{2} w_{2 i}+x_{3} w_{3 i}+x_{4} w_{4 i}+b_{i}\right)</script><p>其中$x_i$是输入，$w$是权重，$b$是偏差。</p><p>假设保留概率为$p$，那么丢弃改为就为$1-p$，那么神经元$h_i$就有$1-p$的概率被丢弃，那么经过Dropout运算后的神经元为，</p><script type="math/tex; mode=display">h_{i}^{\prime}=\frac{\xi_{i}}{1-p} h_{i}</script><p>其中$\xi_{i}$为0或者1，它为0或者1的概率分别为$1-p$和$p$，如果为0,则这个神经元被清零，<b>临时</b>被丢弃，一定要注意，是临时的丢弃，Dropout是有放回的采样。在一轮训练中前向或反向传播都会用丢弃后的神经网络，下一轮训练又会随机丢弃，用一个新的网络去训练。</p><p>编程实现Dropout其实只需要几行代码，下面结合代码来解释，会更容易理解，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dropout</span><span class="params">(X, keep_prob)</span>:</span></span><br><span class="line">    <span class="keyword">assert</span> <span class="number">0</span> &lt; keep_prob &lt; <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> keep_prob == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> np.zeros(X.shape)</span><br><span class="line">    mask = np.random.uniform(<span class="number">0</span>, <span class="number">1</span>, X.shape) &lt; keep_prob</span><br><span class="line">    <span class="keyword">return</span> mask * X / keep_prob</span><br></pre></td></tr></table></figure><p>输入参数为上一层的激活值和保留概率，</p><p>第3行：如果保留概率为0，也就是不保留的话，则全部元素都丢弃。</p><p>第5行：生成一个随机的掩码，掩码和输入X形状相同，每个位置非0即1，然后用这个掩码与X相乘，如果对应位置乘以0，则这个神经元被丢弃，反之保留。</p><p><b>Dropout为什么起作用？</b></p><p><a href="https://imgchr.com/i/npybDg" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/09/01/npybDg.png" alt="npybDg.png"></a></p><center><font size="2">(图片来自《深度学习》)</font></center><p>这里不得不提一下Bagging集成集成学习方法，在Bagging集成学习方法中，预先会定义k的模型，然后采用k个训练集，然后分别训练k个模型，然后以各种方式去评价、选取最终学习的模型。</p><p>Dropout的训练过程中与Bagging集成学习方法类似，以上图为例，有一个三层神经网络(两个输入神经元、两个隐藏神经元、一个输出神经元)，从这个基础的网络中随机删除<b>非输出神经元</b>来构建一些子集。这样每一次训练就如同在这些子集中随机选择一个不同的网络模型进行训练，最后通过”投票”或者平均等策略而选择出一个最好的模型。</p><p>其实这个思想并不陌生，在传统机器学习中Adaboost、随机森林都是采用集成学习的思想，效果非常好。采用Dropout后的深度神经网络和这类思想也是类似的，这样能够结合不同网络模型的训练结果对最终学习的模型进行评价，能够综合多数，筛选掉少数，即便是某个网络模型出现了过拟合，最终经过综合也会过滤掉，效果自然会好很多。</p><p>需要说明一点的是，虽然采用Dropout和其他集成学习方法思想有异曲同工之处，但是也有一些细节的差异。在Bagging中所有模型都是独立的，但是在Dropout中所有模型是共享参数的，每个子模型会继承父网络的网络参数，这样可以有效的节省内存的占用。</p><h1 id="需要注意的点"><a href="#需要注意的点" class="headerlink" title="需要注意的点"></a>需要注意的点</h1><p>到这里，Dropout的内容就讲解完了，总结一些本文，需要有几点需要注意，</p><ul><li>keep_prob是每个<b>神经元</b>被保留的概率</li><li>Dropout和L1、L2、数据扩充都属于正则化方法</li><li>Dropout的丢弃是<b>有放回</b>的</li></ul><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ol><li>Dropout: A Simple Way to Prevent Neural Networks from Overtting</li><li>Dropout as data augmentation</li><li>Improving Neural Networks with Dropout</li><li>Improving neural networks by preventing co-adaptation of feature detectors</li><li>《深度学习》</li></ol><h1 id="资源获取"><a href="#资源获取" class="headerlink" title="资源获取"></a>资源获取</h1><p>我把参考文献中列出的4片文章和《深度学习》这本书籍的电子版进行整理共享了，感兴趣的可以关注公众号，回复关键字“<font color="red"><b>dl</b></font>”获取。</p><p><img src="https://s2.ax1x.com/2019/09/01/np6CKU.png" alt="np6CKU.png"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文完整代码请查看：&lt;a href=&quot;https://github.com/Jackpopc/aiLearnNotes/blob/master/computer_vision/dropout.py&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;aiLearnNotes&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;在前几讲里已经介绍了卷积神经网络中常用的一些单元，例如，&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;卷积层&lt;/li&gt;
&lt;li&gt;池化层&lt;/li&gt;
&lt;li&gt;填充&lt;/li&gt;
&lt;li&gt;激活函数&lt;/li&gt;
&lt;li&gt;批量归一化&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="计算机视觉" scheme="https://jackpopc.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
    
      <category term="CV" scheme="https://jackpopc.github.io/tags/CV/"/>
    
      <category term="AI" scheme="https://jackpopc.github.io/tags/AI/"/>
    
      <category term="图像处理" scheme="https://jackpopc.github.io/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>【进阶Python】第四讲：类的特殊方法(下篇)</title>
    <link href="https://jackpopc.github.io/2019/08/28/python-4/"/>
    <id>https://jackpopc.github.io/2019/08/28/python-4/</id>
    <published>2019-08-28T11:44:57.000Z</published>
    <updated>2019-08-28T14:13:54.343Z</updated>
    
    <content type="html"><![CDATA[<p><strong>完整代码</strong>请查看github项目: <a href="https://github.com/Jackpopc/advance-python/blob/master/2-magic-method_2.ipynb" target="_blank" rel="noopener">advance-python</a></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>特殊方法是为我们定义的类添加上某些特殊功能的方法，上一讲分组讲解了Python的几对特殊方法(或者成为魔术方法)，分别是，</p><ul><li>__new__与__init__</li><li>__enter__与__exit__</li><li>__str__与__repr__</li><li>__setattr__、__getattr__、__getattribute__与__delattr__</li></ul><a id="more"></a>这些都是相对较为常用的。Python中类的特殊方法远不止这些，其中还有一些不太常用，或者在某些特定场景下用到的特殊方法。本讲会按照功能对剩余的特殊方法进行分类，不再详细的把每个特殊方法的使用都展开阐述，会着重的从每种功能中挑选出具有代表性的特殊方法进行实现、详细讲解。# 函数调用假如我们定义一个用于算数运算的类，<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Operation</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x, y)</span>:</span></span><br><span class="line">        self.x = x</span><br><span class="line">        self.y = y</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"The result is &#123;&#125;"</span>.format(self.x + self.y))</span><br><span class="line">      </span><br><span class="line">opt = Operation(<span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">opt.add()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">The result <span class="keyword">is</span> <span class="number">4</span></span><br></pre></td></tr></table></figure><p>从这段代码可以看出 ，这是我们一贯使用类及类方法的方式，实例化—调用，其实Python提供有特殊方法__call__能够让类的调用像调用函数的方式一样。</p><p>这句话听着似乎很绕口，具体什么含义呢？用一段代码来说明，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Operation</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.x = <span class="literal">None</span></span><br><span class="line">        self.y = <span class="literal">None</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"The result is &#123;&#125;"</span>.format(self.x + self.y))</span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, x, y)</span>:</span></span><br><span class="line">        self.x = x</span><br><span class="line">        self.y = y</span><br><span class="line">        self.add()</span><br><span class="line">        </span><br><span class="line">opt = Operation()</span><br><span class="line">opt(<span class="number">3</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">The result <span class="keyword">is</span> <span class="number">6</span></span><br></pre></td></tr></table></figure><p>当我们给类添加特殊方法__call__后，我们可以直接使用实例名(opt)来调用类的方法，就不用在用instance.method的方法去调用。换句话说就是，当我们定义__call__后，我们使用实例名进行调用时，它会首先进入__call__方法，执行__call__中的程序。</p><h1 id="容器与序列"><a href="#容器与序列" class="headerlink" title="容器与序列"></a>容器与序列</h1><p>容器和序列分别涉及2个特殊方法：__contains__、__len__。</p><p>从__len__名称就可以看出它的功能，给类添加一个获取序列长度的功能，所以这里着重讲解一下容器，顺带讲解一下__len__。</p><p>我们在<b>条件语句</b>中经常会用到这样的语句<b>if … in</b>、<b>if … not in</b>，其中__contains__就可以给类添加这样一个功能，可以通过<b>if … in</b>、<b>if … not in</b>来调用类的实例，以一段代码来举例，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Contain</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, data)</span>:</span></span><br><span class="line">        self.data = data</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__contains__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> x <span class="keyword">in</span> self.data</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> len(self.data)</span><br><span class="line">    </span><br><span class="line">contain = Contain([<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="number">2</span> <span class="keyword">in</span> contain:</span><br><span class="line">    print(<span class="string">"222222"</span>)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> <span class="number">6</span> <span class="keyword">not</span> <span class="keyword">in</span> contain:</span><br><span class="line">    print(<span class="string">"666666"</span>)</span><br><span class="line">    </span><br><span class="line">len(contain)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line"><span class="number">222222</span></span><br><span class="line"><span class="number">666666</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure><p>从代码中可以看出，当我们调用<b>if 2 in contain</b>时会调用__contains__这个特殊方法，通过方法中的语句返回一个布尔型的值。</p><p>此外，可以看到代码中有这样一句调用<b>len(contain)</b>，它就是前面提到的特殊方法__len__的功能，它可以给类添加一个<b>获取序列长度</b>的功能，当使用len(instance)时会调用__len__方法中的程序。</p><h1 id="算数运算"><a href="#算数运算" class="headerlink" title="算数运算"></a>算数运算</h1><p>用于实现算数运算的有以下类的特殊方法的有以下几个，</p><div class="table-container"><table><thead><tr><th>运算</th><th>代码</th><th>特殊方法</th></tr></thead><tbody><tr><td>加法</td><td>a + b</td><td>__add__</td></tr><tr><td>减法</td><td>a - b</td><td>__sub__</td></tr><tr><td>乘法</td><td>a * b</td><td>__mul__</td></tr><tr><td>除法</td><td>a / b</td><td>__truediv__</td></tr><tr><td>向下取整除法</td><td>a // b</td><td>__floordiv__</td></tr><tr><td>取余</td><td>a % b</td><td>__mod__</td></tr></tbody></table></div><p>以一段代码举例说名加法与乘法的使用，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Operation</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        self.value = value</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__add__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> Operation(self.value + other.value)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__mul__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> Operation(self.value * other.value)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"the value if &#123;&#125;"</span>.format(self.value)</span><br><span class="line">    </span><br><span class="line">a = Operation(<span class="number">3</span>)</span><br><span class="line">b = Operation(<span class="number">5</span>)</span><br><span class="line">print(a + b)</span><br><span class="line">print(a * b)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">the value <span class="keyword">if</span> <span class="number">8</span></span><br><span class="line">the value <span class="keyword">if</span> <span class="number">15</span></span><br></pre></td></tr></table></figure><p>同理，其他几种算法运算的使用方法同加法、乘法相同。</p><h1 id="比较运算"><a href="#比较运算" class="headerlink" title="比较运算"></a>比较运算</h1><p>类的特殊方法不仅提供了算术运算，还提供了比较运算的特殊方法，它们分别是，<br>| 运算         | 代码   | 特殊方法         |<br>| —————— | ——— | ———————— |<br>| 等于         | a == b  | __eq__      |<br>| 不等         | a != b  | __ne__      |<br>| 大于         | a &gt; b  | __gt__      |<br>| 小于         | a &lt; b  | __lt__  |<br>| 大于等于 | a &gt;= b | __ge__ |<br>| 小于等于         | a &lt;= b  | __le__      |</p><p>以一段代码解释比较运算符的使用，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cmp</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        self.value = value</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__eq__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.value == other.value</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__gt__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.value &gt; other.value</span><br><span class="line">a = Cmp(<span class="number">3</span>)</span><br><span class="line">b = Cmp(<span class="number">3</span>)</span><br><span class="line">a == b</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><p>可以看出，比较运算和算术运算的使用非常相似。</p><h1 id="字典功能"><a href="#字典功能" class="headerlink" title="字典功能"></a>字典功能</h1><p>我们可以通过如下几个特殊方法为类添加如同字典一样的功能，<br>| 运算         | 代码   | 特殊方法         |<br>| —————— | ——— | ———————— |<br>| 取值         | x[key]  | __setitem__      |<br>| 设置值         | x[key]=value  | __getitem__      |<br>| 删除值         | del x[key]  | __delitem__      |</p><p>下面以一段代码举例说明，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dictionaries</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__setitem__</span><span class="params">(self, key, value)</span>:</span></span><br><span class="line">        self.__dict__[key] = value</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, key)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.__dict__[key]</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__delitem__</span><span class="params">(self, key)</span>:</span></span><br><span class="line">        <span class="keyword">del</span> self.__dict__[key]</span><br><span class="line"></span><br><span class="line">diction = Dictionaries()</span><br><span class="line">diction[<span class="string">"one"</span>] = <span class="number">1</span></span><br><span class="line">diction[<span class="string">"two"</span>] = <span class="number">2</span></span><br><span class="line">diction[<span class="string">"three"</span>] = <span class="number">3</span></span><br><span class="line">diction[<span class="string">'three'</span>]</span><br><span class="line"><span class="keyword">del</span> diction[<span class="string">'three'</span>]</span><br><span class="line">diction[<span class="string">'three'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">KeyError                                  Traceback (most recent call last)</span><br><span class="line">&lt;ipython-input<span class="number">-57</span>-dfe1a566046b&gt; <span class="keyword">in</span> &lt;module&gt;()</span><br><span class="line">----&gt; 1 diction['three']</span><br><span class="line"></span><br><span class="line">&lt;ipython-input<span class="number">-55</span><span class="number">-21</span>dcfd1e91cb&gt; <span class="keyword">in</span> __getitem__(self, key)</span><br><span class="line">      <span class="number">4</span> </span><br><span class="line">      <span class="number">5</span>     <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, key)</span>:</span></span><br><span class="line">----&gt; 6         return self.__dict__[key]</span><br><span class="line">      <span class="number">7</span> </span><br><span class="line">      <span class="number">8</span>     <span class="function"><span class="keyword">def</span> <span class="title">__delitem__</span><span class="params">(self, key)</span>:</span></span><br><span class="line"></span><br><span class="line">KeyError: <span class="string">'three'</span></span><br></pre></td></tr></table></figure><p>可以看出，当删除键值为three的值之后再次去获取会报错。</p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>除了上述提到的特殊方法之后，Python还有很多特殊方法，这里不一一举例说明，下面列举出这些特殊方法以及它们的功能和使用方法，如果感兴趣的可以对应的去查找文档学习。</p><div class="table-container"><table><thead><tr><th>运算</th><th>代码</th><th>特殊方法</th></tr></thead><tbody><tr><td>类析构函数</td><td>del instant</td><td>__del__</td></tr><tr><td>格式化字符串</td><td>format(x, format_spec)</td><td>__format__</td></tr><tr><td>遍历迭代器</td><td>iter(list)</td><td>__iter__</td></tr><tr><td>取迭代器下一个值</td><td>next(list)</td><td>__next__</td></tr><tr><td>列出类的所有属性和方法</td><td>dir(instance)</td><td>__dir__</td></tr><tr><td>自定义散列值</td><td>hash(instance)</td><td>__hash__</td></tr><tr><td>自定义拷贝</td><td>copy.copy(instance)</td><td>__copy__</td></tr><tr><td>自定义深层拷贝</td><td>copy.deepcopy(instance)</td><td>__deepcopy__</td></tr><tr><td>上下文环境布尔值</td><td>if instance:</td><td>__bool__</td></tr></tbody></table></div><p>当然，除了这些，Python还有其他的特殊方法，例如逻辑运算、按位运算等，感兴趣的可以参考官方文档仔细学习一下，本文仅列举一些相对常用的一些特殊方法。</p><h1 id="文档获取"><a href="#文档获取" class="headerlink" title="文档获取"></a>文档获取</h1><p>本讲的Markdown格式文档我进行共享了，需要的可以关注公众号【平凡而诗意】回复关键字”<font color="red"><b>python</b></font>“获取。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;完整代码&lt;/strong&gt;请查看github项目: &lt;a href=&quot;https://github.com/Jackpopc/advance-python/blob/master/2-magic-method_2.ipynb&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;advance-python&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;特殊方法是为我们定义的类添加上某些特殊功能的方法，上一讲分组讲解了Python的几对特殊方法(或者成为魔术方法)，分别是，&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;__new__与__init__&lt;/li&gt;
&lt;li&gt;__enter__与__exit__&lt;/li&gt;
&lt;li&gt;__str__与__repr__&lt;/li&gt;
&lt;li&gt;__setattr__、__getattr__、__getattribute__与__delattr__&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Python" scheme="https://jackpopc.github.io/categories/Python/"/>
    
    
      <category term="编程" scheme="https://jackpopc.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Python" scheme="https://jackpopc.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>【动手学计算机视觉】第十三讲：批量归一化</title>
    <link href="https://jackpopc.github.io/2019/08/24/cnn-bn/"/>
    <id>https://jackpopc.github.io/2019/08/24/cnn-bn/</id>
    <published>2019-08-24T12:37:58.000Z</published>
    <updated>2019-08-25T12:04:10.762Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>当我们用一些数据做一个预测系统时，我们首先需要对数据进行预处理，例如标准化、正则化、滑动窗口等，比如常用的Z-score、最大最小标准化，它能将数据转化为同一个量级，这样的话能够保证数据的稳定性、可比性。</p><a id="more"></a>这些标准化方法在浅层神经网络中已经足够使用，效果已经很不错。但是在深度学习中，网络越来越深，使用这些标准化方法就难以解决相应的问题。<b>为什么需要批量归一化？</b>在训练过程中，每层输入的分布不断的变化，这使得下一层需要不断的去适应新的数据分布，在深度神经网络中，这让训练变得非常复杂而且缓慢。对于这样，往往需要设置更小的学习率、更严格的参数初始化。通过使用批量归一化(Batch Normalization, BN)，在模型的训练过程中利用小批量的均值和方差调整神经网络中间的输出，从而使得各层之间的输出都符合均值、方差相同高斯分布，这样的话会使得数据更加稳定，无论隐藏层的参数如何变化，可以确定的是前一层网络输出数据的均值、方差是已知的、固定的，这样就解决了数据分布不断改变带来的训练缓慢、小学习率等问题。<b>在哪里使用批量归一化？</b>批量归一化是卷积神经网络中一个可选单元，如果使用BN能够保证训练速度更快，同时还可以具备一些正则化功能。在卷积神经网络中卷积层和全连接层都可以使用批量归一化。对于卷积层，它的位置是在卷积计算之后、激活函数之前。对于全连接层，它是在仿射变换之后，激活函数之前，如下所示：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">conv_1 = tf.nn.conv2d()</span><br><span class="line">norm_1 = tf.nn.batch_normalization(conv_1)</span><br><span class="line">relu_1 = tf.nn.relu(norm_1)</span><br><span class="line">pool_1 = tf.nn.max_pool(relu_1)</span><br></pre></td></tr></table></figure><p>以卷积层为例，网络架构的流程为：</p><ul><li>卷积运算</li><li>批量归一化</li><li>激活函数</li><li>池化</li></ul><h1 id="批量归一化"><a href="#批量归一化" class="headerlink" title="批量归一化"></a>批量归一化</h1><p><img src="https://s2.ax1x.com/2019/08/25/m2YzZR.png" alt="m2YzZR.png"></p><p>在讲批量归一化之前，首先讲一下数据标准化处理算法Z-score。</p><p>Z-score标准化也成为标准差标准化，它是将数据处理成均值为0，方差为1的标准正态分布，它的转化公式为，</p><script type="math/tex; mode=display">x^{*}=\frac{x-\overline{x}}{\sigma}</script><p>其中$x$是处理前的数据，$x^{*}$是处理后的数据，$\overline{x}$是原始数据的均值，$\sigma$是原始的标准差。这样的话就可以把数据进行标准化。</p><p>其实批量归一化在思想上和Z-score是有很多共通之处的。</p><p>在深度学习训练过程中会选取一个小批量，然后计算小批量数据的均值和方差，</p><script type="math/tex; mode=display">\boldsymbol{\mu}_{\mathcal{B}} \leftarrow \frac{1}{m} \sum_{i=1}^{m} \boldsymbol{x}^{(i)}</script><script type="math/tex; mode=display">\sigma_{\mathcal{B}}^{2} \leftarrow \frac{1}{m} \sum_{i=1}^{m}\left(\boldsymbol{x}^{(i)}-\boldsymbol{\mu}_{\mathcal{B}}\right)^{2}</script><p>然后对数据进行归一化处理，</p><script type="math/tex; mode=display">\hat{\boldsymbol{x}}^{(i)} \leftarrow \frac{\boldsymbol{x}^{(i)}-\boldsymbol{\mu}_{\mathcal{B}}}{\sqrt{\boldsymbol{\sigma}_{\mathcal{B}}^{2}+\epsilon}}</script><script type="math/tex; mode=display">\boldsymbol{y}^{(i)} \leftarrow \boldsymbol{\gamma} \odot \hat{\boldsymbol{x}}^{(i)}+\boldsymbol{\beta}</script><p>经过这样处理，就可以使得数据符合均值为$\boldsymbol{\mu}$、方差为$\sigma_{\mathcal{B}}^{2}$的高斯分布。</p><p>下面看一下原文中批量归一化的算法步骤：</p><p><img src="https://s2.ax1x.com/2019/08/25/m2tpIx.png" alt="m2tpIx.png"></p><ul><li>获取每次训练过程中的样本</li><li>就算小批量样本的均值、方差</li><li>归一化</li><li>拉伸和偏移</li></ul><p>这里要着重介绍一下最后一步尺度变换(scale and shift)，前面3步已经对数据进行了归一化，为什么还需要拉伸和偏移呢？</p><p>因为经过前三步的计算使得数据被严格的限制为均值为0、方差为1的正态分布之下，这样虽然一定程度上解决了训练困难的问题，但是这样的严格限制网络的表达能力，通过加入$\gamma$和$\beta$这两个参数可以使得数据分布的自由度更高，网络表达能力更强。另外，这两个参数和其他参数相同，通过不断的学习得出。</p><h1 id="tensorflow中BN的使用"><a href="#tensorflow中BN的使用" class="headerlink" title="tensorflow中BN的使用"></a>tensorflow中BN的使用</h1><p>在tensorflow中可以直接调用批量归一化对数据进行处理，它的函数为，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tf.nn.batch_normalization(x, mean, variance, offset, scale, variance_epsilon, name=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure><p>来解释一下函数中参数的含义：</p><ul><li>x：输入的数据，可以是卷积层的输出，也可以是全连接层的输出</li><li>mean：输出数据的均值</li><li>variance：输出数据的方差</li><li>offset：偏移，就是前面提到的beta</li><li>scale：缩放，前面提到的gamma</li><li>variance_epsilon：一个极小的值，避免分母为0</li></ul><hr><p>更多内容，请关注公众号【平凡而诗意】~</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;当我们用一些数据做一个预测系统时，我们首先需要对数据进行预处理，例如标准化、正则化、滑动窗口等，比如常用的Z-score、最大最小标准化，它能将数据转化为同一个量级，这样的话能够保证数据的稳定性、可比性。&lt;/p&gt;
    
    </summary>
    
      <category term="计算机视觉" scheme="https://jackpopc.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
    
      <category term="CV" scheme="https://jackpopc.github.io/tags/CV/"/>
    
      <category term="AI" scheme="https://jackpopc.github.io/tags/AI/"/>
    
      <category term="图像处理" scheme="https://jackpopc.github.io/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>实用资源 | 推荐6个高赞有趣的Github项目</title>
    <link href="https://jackpopc.github.io/2019/08/23/github-project/"/>
    <id>https://jackpopc.github.io/2019/08/23/github-project/</id>
    <published>2019-08-23T13:36:09.000Z</published>
    <updated>2019-08-25T12:05:45.760Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Github，应该很多同学都听过这个鼎鼎大名的开源项目托管平台。</p><p>刚开始接触github，我和大多数同学一样，仅仅把它当作一个开源项目搜索工具。比如当看到一篇文章，会去搜索一下看看作者有没有开源源代码，仅此而已，因此一直以来对github的依赖都不太强。</p><p><a id="more"></a>最近几个月以来，我每天会特意抽出一段时间去github看一下，看看近期有没有什么热门有趣的项目，慢慢的，在github上发现了很多不错的项目，久而久之就对其产生了依赖。现在每天都会去看一下，在这个过程总的确从这些优质的开源项目上学到了很多，收获了很多，下面我就推荐5个我个人觉得不错的开源项目。</p><h1 id="free-programming-books-zh-CN"><a href="#free-programming-books-zh-CN" class="headerlink" title="free-programming-books-zh_CN"></a>free-programming-books-zh_CN</h1><p>项目地址：<a href="https://github.com/justjavac/free-programming-books-zh_CN" target="_blank" rel="noopener">https://github.com/justjavac/free-programming-books-zh_CN</a></p><p><strong>star：54k+</strong></p><p><img src="https://s2.ax1x.com/2019/08/25/m2YGUx.jpg" alt="m2YGUx.jpg"></p><p>在从事IT、互联网相关的开发过程中，我们会用到各种各样的知识，linux、数据库、编程语言、虚拟化等。这样就需要我们不断的去学习，很多时间和金钱比较充足的可以选择一些课程或者买一些书籍，但是大多数人是不会把所用到知识相关的书籍都购买一遍。这样就面临一个问题：<strong>我们该去哪获取相应的学习资源？</strong></p><p>free-programming-books-zh_CN收集了计算机领域很多知名的书籍，它包括但不限于以下种类：</p><ul><li>各种编程语言</li><li>版本控制</li><li>数据库</li><li>大数据</li><li>操作系统</li><li>编译原理</li><li>web</li><li>…</li></ul><p>有了这个项目就再也不用担心学习资源的问题了，它手机了计算机各个分支相关的经典书籍和优质学习资源，避免了在茫茫的网络中去搜索的麻烦。</p><h1 id="sherlock"><a href="#sherlock" class="headerlink" title="sherlock"></a>sherlock</h1><p>项目地址：<a href="https://github.com/sherlock-project/sherlock" target="_blank" rel="noopener">https://github.com/sherlock-project/sherlock</a></p><p><strong>star：6.8k+</strong></p><p>在到处充斥着互联网、社交的时代，<strong>用户名</strong>是每个人都不陌生的词汇，当我们注册一个社交网站，例如知乎、微博等，需要起一个名称。很多人都喜欢独一无二、与众不同，但是在这么多用户名字，一不小心就和别人重复了，sherlock这个项目就可以解决这个问题，它能够在不同的社交网站上搜索是否存在指定的用户名，这样的话你就可以看到自己起的用户名有没有重复？有哪些重复。</p><p><img src="https://s2.ax1x.com/2019/08/25/m2YtPK.gif" alt="m2YtPK.gif"></p><h1 id="weekly"><a href="#weekly" class="headerlink" title="weekly"></a>weekly</h1><p>项目地址：<a href="http://link.zhihu.com/?target=https%3A//github.com/ruanyf/weekly" target="_blank" rel="noopener">http://link.zhihu.com/?target=https%3A//github.com/ruanyf/weekly</a><br><strong>star：8.1k+</strong></p><p>这是一个科技爱好者周刊。</p><p>现在是一个信息爆炸的社会，各种新媒体、自媒体，每天各个APP有看不完、层出不穷的新闻，但是，我个人认为大多数自媒体的水平有待商榷，在他们看来，一个吸引人的标题比实际的内容还要重要。所以我很苦恼，每天喜欢看看新闻，但是花费几十分钟后发现都是一些乱七八糟没有价值的新闻。</p><p>直到几个月前我在github看到weekly这个项目，它每周五定期更新一次，慢慢的，周五在我心里有了一些期待，期待着这个项目更新周刊。</p><p>为什么它如此吸引我？</p><p><img src="https://s2.ax1x.com/2019/08/25/m2Y0rd.png" alt="m2Y0rd.png"></p><p>它与众不同，而且都是经过筛选的一些新奇有趣的新闻，我觉得称其为新闻，但它不仅限于新闻，它包含如下内容：</p><ul><li>新奇的资讯</li><li>优质中文、英文文章</li><li>高效工具</li><li>资源</li><li>精选图片</li><li>文摘</li><li>言论</li></ul><h2 id="UnblockNeteaseMusic"><a href="#UnblockNeteaseMusic" class="headerlink" title="UnblockNeteaseMusic"></a>UnblockNeteaseMusic</h2><p>项目地址：<a href="http://link.zhihu.com/?target=https%3A//github.com/nondanee/UnblockNeteaseMusic" target="_blank" rel="noopener">http://link.zhihu.com/?target=https%3A//github.com/nondanee/UnblockNeteaseMusic</a></p><p><strong>star：4.4k+</strong></p><p><img src="https://s2.ax1x.com/2019/08/25/m2Ysat.png" alt="m2Ysat.png"></p><p>从这个项目的名称即可看出它的功能，<strong>unblock netease music</strong>。</p><p>网易云音乐是很多人喜欢的一款音乐播放器，我也不例外，但是发现它上面的音乐越来越少，当你想听一首歌时发现，它竟然是灰色的，也就是不能听。</p><p>有了这个项目，它可以从QQ / 虾米 / 百度 / 酷狗 / 酷我 / 咕咪 / JOOX等音乐源寻找资源进行替换，也就是说，有了UnblockNeteaseMusic+网易云音乐，你可以听来自不同音乐源的歌曲。</p><h1 id="ChineseBQB"><a href="#ChineseBQB" class="headerlink" title="ChineseBQB"></a>ChineseBQB</h1><p>项目地址：<a href="https://github.com/zhaoolee/ChineseBQB" target="_blank" rel="noopener">https://github.com/zhaoolee/ChineseBQB</a></p><p><strong>star：5k+</strong></p><p>这个一个表情包博物馆，目前共收录了3319个表情包，包含各种各样热门、搞笑的表情包，有了这个github项目，再也不用为”斗图”担心了。</p><p>先来几个看一下，</p><p><img src="https://s2.ax1x.com/2019/08/25/m2Yoaq.gif" alt="m2Yoaq.gif"><br><img src="https://s2.ax1x.com/2019/08/25/m2Y4qs.gif" alt="m2Y4qs.gif"><br><img src="https://s2.ax1x.com/2019/08/25/m2YIZn.gif" alt="m2YIZn.gif"></p><h1 id="LeetCodeAnimation"><a href="#LeetCodeAnimation" class="headerlink" title="LeetCodeAnimation"></a>LeetCodeAnimation</h1><p>项目地址：<a href="https://github.com/MisterBooo/LeetCodeAnimation" target="_blank" rel="noopener">https://github.com/MisterBooo/LeetCodeAnimation</a></p><p><strong>star：38k+</strong></p><p>娱乐之后不得不说一些沉重的话题，已经是8月底了，大批量的校招马上就要开始了 ~</p><p>不知道关注我的同学里有多少位要参加今年的校园招聘，如果有，首先预祝各位找到理想的工作！</p><p>其次，就是推荐一份不错的学习资源。</p><p>LeetCode，这个大名鼎鼎的平台应该很多参加过校招或者即将参加校招的同学应该都有所耳闻，是很多参加互联网、IT方向校招同学的必经之路，甚至周围有同事说”没有刷过LeetCode的校招，是不完整的！”。</p><p>github上有关leetcode的项目有很多，但是99%都是如出一辙，把leetcode上的题目做一下或者寻找一些答案，然后上传到github，只有静态的代码和简短的文字描述，这对于很多初学者是很难以理解的。</p><p>LeetCodeAnimation这个项目却与众不同，它通过动画的形式来阐述不同算法的解题思路，更加生动形象，下面就看一个例子—无重复字符的最长子串，</p><p><img src="https://s2.ax1x.com/2019/08/25/m2YvL9.gif" alt="m2YvL9.gif"></p><hr><p>更多内容，请关注公众号【平凡而诗意】~</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;Github，应该很多同学都听过这个鼎鼎大名的开源项目托管平台。&lt;/p&gt;
&lt;p&gt;刚开始接触github，我和大多数同学一样，仅仅把它当作一个开源项目搜索工具。比如当看到一篇文章，会去搜索一下看看作者有没有开源源代码，仅此而已，因此一直以来对github的依赖都不太强。&lt;/p&gt;
&lt;p&gt;
    
    </summary>
    
      <category term="学习资源" scheme="https://jackpopc.github.io/categories/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90/"/>
    
    
      <category term="机器学习" scheme="https://jackpopc.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="Github" scheme="https://jackpopc.github.io/tags/Github/"/>
    
      <category term="资源" scheme="https://jackpopc.github.io/tags/%E8%B5%84%E6%BA%90/"/>
    
  </entry>
  
</feed>
